const std = @import("std");
const builtin = @import("builtin");
const log = std.log.scoped(.gl);

const tracy = @import("tracy");

pub const validation: bool = switch (builtin.mode) {
    .Debug, .ReleaseSafe => true,
    else => false,
};

pub const FunctionPointer: type = *align(@alignOf(fn (u32) callconv(.C) u32)) const anyopaque;

pub const GLenum = c_uint;
pub const GLboolean = u8;
pub const GLbitfield = c_uint;
pub const GLbyte = i8;
pub const GLubyte = u8;
pub const GLshort = i16;
pub const GLushort = u16;
pub const GLint = c_int;
pub const GLuint = c_uint;
pub const GLclampx = i32;
pub const GLsizei = c_int;
pub const GLfloat = f32;
pub const GLclampf = f32;
pub const GLdouble = f64;
pub const GLclampd = f64;
pub const GLeglClientBufferEXT = void;
pub const GLeglImageOES = void;
pub const GLchar = u8;
pub const GLcharARB = u8;

pub const GLhandleARB = if (builtin.os.tag == .macos) *anyopaque else c_uint;

pub const GLhalf = u16;
pub const GLhalfARB = u16;
pub const GLfixed = i32;
pub const GLintptr = usize;
pub const GLintptrARB = usize;
pub const GLsizeiptr = isize;
pub const GLsizeiptrARB = isize;
pub const GLint64 = i64;
pub const GLint64EXT = i64;
pub const GLuint64 = u64;
pub const GLuint64EXT = u64;

pub const GLsync = *opaque {};

pub const _cl_context = opaque {};
pub const _cl_event = opaque {};

pub const GLDEBUGPROC = *const fn (source: GLenum, _type: GLenum, id: GLuint, severity: GLenum, length: GLsizei, message: [*:0]const u8, userParam: ?*anyopaque) callconv(.C) void;
pub const GLDEBUGPROCARB = *const fn (source: GLenum, _type: GLenum, id: GLuint, severity: GLenum, length: GLsizei, message: [*:0]const u8, userParam: ?*anyopaque) callconv(.C) void;
pub const GLDEBUGPROCKHR = *const fn (source: GLenum, _type: GLenum, id: GLuint, severity: GLenum, length: GLsizei, message: [*:0]const u8, userParam: ?*anyopaque) callconv(.C) void;

pub const GLDEBUGPROCAMD = *const fn (id: GLuint, category: GLenum, severity: GLenum, length: GLsizei, message: [*:0]const u8, userParam: ?*anyopaque) callconv(.C) void;

pub const GLhalfNV = u16;
pub const GLvdpauSurfaceNV = GLintptr;
pub const GLVULKANPROCNV = *const fn () callconv(.C) void;

pub const CURRENT_BIT = 0x00000001;
pub const POINT_BIT = 0x00000002;
pub const LINE_BIT = 0x00000004;
pub const POLYGON_BIT = 0x00000008;
pub const POLYGON_STIPPLE_BIT = 0x00000010;
pub const PIXEL_MODE_BIT = 0x00000020;
pub const LIGHTING_BIT = 0x00000040;
pub const FOG_BIT = 0x00000080;
pub const DEPTH_BUFFER_BIT = 0x00000100;
pub const ACCUM_BUFFER_BIT = 0x00000200;
pub const STENCIL_BUFFER_BIT = 0x00000400;
pub const VIEWPORT_BIT = 0x00000800;
pub const TRANSFORM_BIT = 0x00001000;
pub const ENABLE_BIT = 0x00002000;
pub const COLOR_BUFFER_BIT = 0x00004000;
pub const HINT_BIT = 0x00008000;
pub const EVAL_BIT = 0x00010000;
pub const LIST_BIT = 0x00020000;
pub const TEXTURE_BIT = 0x00040000;
pub const SCISSOR_BIT = 0x00080000;
pub const MULTISAMPLE_BIT = 0x20000000;
pub const MULTISAMPLE_BIT_ARB = 0x20000000;
pub const MULTISAMPLE_BIT_EXT = 0x20000000;
pub const MULTISAMPLE_BIT_3DFX = 0x20000000;
pub const ALL_ATTRIB_BITS = 0xFFFFFFFF;
pub const DYNAMIC_STORAGE_BIT = 0x0100;
pub const DYNAMIC_STORAGE_BIT_EXT = 0x0100;
pub const CLIENT_STORAGE_BIT = 0x0200;
pub const CLIENT_STORAGE_BIT_EXT = 0x0200;
pub const SPARSE_STORAGE_BIT_ARB = 0x0400;
pub const LGPU_SEPARATE_STORAGE_BIT_NVX = 0x0800;
pub const PER_GPU_STORAGE_BIT_NV = 0x0800;
pub const EXTERNAL_STORAGE_BIT_NVX = 0x2000;
pub const COVERAGE_BUFFER_BIT_NV = 0x00008000;
pub const CLIENT_PIXEL_STORE_BIT = 0x00000001;
pub const CLIENT_VERTEX_ARRAY_BIT = 0x00000002;
pub const CLIENT_ALL_ATTRIB_BITS = 0xFFFFFFFF;
pub const CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT = 0x00000001;
pub const CONTEXT_FLAG_DEBUG_BIT = 0x00000002;
pub const CONTEXT_FLAG_DEBUG_BIT_KHR = 0x00000002;
pub const CONTEXT_FLAG_ROBUST_ACCESS_BIT = 0x00000004;
pub const CONTEXT_FLAG_ROBUST_ACCESS_BIT_ARB = 0x00000004;
pub const CONTEXT_FLAG_NO_ERROR_BIT = 0x00000008;
pub const CONTEXT_FLAG_NO_ERROR_BIT_KHR = 0x00000008;
pub const CONTEXT_FLAG_PROTECTED_CONTENT_BIT_EXT = 0x00000010;
pub const CONTEXT_CORE_PROFILE_BIT = 0x00000001;
pub const CONTEXT_COMPATIBILITY_PROFILE_BIT = 0x00000002;
pub const MAP_READ_BIT = 0x0001;
pub const MAP_READ_BIT_EXT = 0x0001;
pub const MAP_WRITE_BIT = 0x0002;
pub const MAP_WRITE_BIT_EXT = 0x0002;
pub const MAP_INVALIDATE_RANGE_BIT = 0x0004;
pub const MAP_INVALIDATE_RANGE_BIT_EXT = 0x0004;
pub const MAP_INVALIDATE_BUFFER_BIT = 0x0008;
pub const MAP_INVALIDATE_BUFFER_BIT_EXT = 0x0008;
pub const MAP_FLUSH_EXPLICIT_BIT = 0x0010;
pub const MAP_FLUSH_EXPLICIT_BIT_EXT = 0x0010;
pub const MAP_UNSYNCHRONIZED_BIT = 0x0020;
pub const MAP_UNSYNCHRONIZED_BIT_EXT = 0x0020;
pub const MAP_PERSISTENT_BIT = 0x0040;
pub const MAP_PERSISTENT_BIT_EXT = 0x0040;
pub const MAP_COHERENT_BIT = 0x0080;
pub const MAP_COHERENT_BIT_EXT = 0x0080;
pub const VERTEX_ATTRIB_ARRAY_BARRIER_BIT = 0x00000001;
pub const VERTEX_ATTRIB_ARRAY_BARRIER_BIT_EXT = 0x00000001;
pub const ELEMENT_ARRAY_BARRIER_BIT = 0x00000002;
pub const ELEMENT_ARRAY_BARRIER_BIT_EXT = 0x00000002;
pub const UNIFORM_BARRIER_BIT = 0x00000004;
pub const UNIFORM_BARRIER_BIT_EXT = 0x00000004;
pub const TEXTURE_FETCH_BARRIER_BIT = 0x00000008;
pub const TEXTURE_FETCH_BARRIER_BIT_EXT = 0x00000008;
pub const SHADER_GLOBAL_ACCESS_BARRIER_BIT_NV = 0x00000010;
pub const SHADER_IMAGE_ACCESS_BARRIER_BIT = 0x00000020;
pub const SHADER_IMAGE_ACCESS_BARRIER_BIT_EXT = 0x00000020;
pub const COMMAND_BARRIER_BIT = 0x00000040;
pub const COMMAND_BARRIER_BIT_EXT = 0x00000040;
pub const PIXEL_BUFFER_BARRIER_BIT = 0x00000080;
pub const PIXEL_BUFFER_BARRIER_BIT_EXT = 0x00000080;
pub const TEXTURE_UPDATE_BARRIER_BIT = 0x00000100;
pub const TEXTURE_UPDATE_BARRIER_BIT_EXT = 0x00000100;
pub const BUFFER_UPDATE_BARRIER_BIT = 0x00000200;
pub const BUFFER_UPDATE_BARRIER_BIT_EXT = 0x00000200;
pub const FRAMEBUFFER_BARRIER_BIT = 0x00000400;
pub const FRAMEBUFFER_BARRIER_BIT_EXT = 0x00000400;
pub const TRANSFORM_FEEDBACK_BARRIER_BIT = 0x00000800;
pub const TRANSFORM_FEEDBACK_BARRIER_BIT_EXT = 0x00000800;
pub const ATOMIC_COUNTER_BARRIER_BIT = 0x00001000;
pub const ATOMIC_COUNTER_BARRIER_BIT_EXT = 0x00001000;
pub const SHADER_STORAGE_BARRIER_BIT = 0x00002000;
pub const CLIENT_MAPPED_BUFFER_BARRIER_BIT = 0x00004000;
pub const CLIENT_MAPPED_BUFFER_BARRIER_BIT_EXT = 0x00004000;
pub const QUERY_BUFFER_BARRIER_BIT = 0x00008000;
pub const ALL_BARRIER_BITS = 0xFFFFFFFF;
pub const ALL_BARRIER_BITS_EXT = 0xFFFFFFFF;
pub const QUERY_DEPTH_PASS_EVENT_BIT_AMD = 0x00000001;
pub const QUERY_DEPTH_FAIL_EVENT_BIT_AMD = 0x00000002;
pub const QUERY_STENCIL_FAIL_EVENT_BIT_AMD = 0x00000004;
pub const QUERY_DEPTH_BOUNDS_FAIL_EVENT_BIT_AMD = 0x00000008;
pub const QUERY_ALL_EVENT_BITS_AMD = 0xFFFFFFFF;
pub const SYNC_FLUSH_COMMANDS_BIT = 0x00000001;
pub const SYNC_FLUSH_COMMANDS_BIT_APPLE = 0x00000001;
pub const VERTEX_SHADER_BIT = 0x00000001;
pub const VERTEX_SHADER_BIT_EXT = 0x00000001;
pub const FRAGMENT_SHADER_BIT = 0x00000002;
pub const FRAGMENT_SHADER_BIT_EXT = 0x00000002;
pub const GEOMETRY_SHADER_BIT = 0x00000004;
pub const GEOMETRY_SHADER_BIT_EXT = 0x00000004;
pub const GEOMETRY_SHADER_BIT_OES = 0x00000004;
pub const TESS_CONTROL_SHADER_BIT = 0x00000008;
pub const TESS_CONTROL_SHADER_BIT_EXT = 0x00000008;
pub const TESS_CONTROL_SHADER_BIT_OES = 0x00000008;
pub const TESS_EVALUATION_SHADER_BIT = 0x00000010;
pub const TESS_EVALUATION_SHADER_BIT_EXT = 0x00000010;
pub const TESS_EVALUATION_SHADER_BIT_OES = 0x00000010;
pub const COMPUTE_SHADER_BIT = 0x00000020;
pub const MESH_SHADER_BIT_NV = 0x00000040;
pub const TASK_SHADER_BIT_NV = 0x00000080;
pub const ALL_SHADER_BITS = 0xFFFFFFFF;
pub const ALL_SHADER_BITS_EXT = 0xFFFFFFFF;
pub const SUBGROUP_FEATURE_BASIC_BIT_KHR = 0x00000001;
pub const SUBGROUP_FEATURE_VOTE_BIT_KHR = 0x00000002;
pub const SUBGROUP_FEATURE_ARITHMETIC_BIT_KHR = 0x00000004;
pub const SUBGROUP_FEATURE_BALLOT_BIT_KHR = 0x00000008;
pub const SUBGROUP_FEATURE_SHUFFLE_BIT_KHR = 0x00000010;
pub const SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT_KHR = 0x00000020;
pub const SUBGROUP_FEATURE_CLUSTERED_BIT_KHR = 0x00000040;
pub const SUBGROUP_FEATURE_QUAD_BIT_KHR = 0x00000080;
pub const SUBGROUP_FEATURE_PARTITIONED_BIT_NV = 0x00000100;
pub const TEXTURE_STORAGE_SPARSE_BIT_AMD = 0x00000001;
pub const RED_BIT_ATI = 0x00000001;
pub const GREEN_BIT_ATI = 0x00000002;
pub const BLUE_BIT_ATI = 0x00000004;
pub const @"2X_BIT_ATI" = 0x00000001;
pub const @"4X_BIT_ATI" = 0x00000002;
pub const @"8X_BIT_ATI" = 0x00000004;
pub const HALF_BIT_ATI = 0x00000008;
pub const QUARTER_BIT_ATI = 0x00000010;
pub const EIGHTH_BIT_ATI = 0x00000020;
pub const SATURATE_BIT_ATI = 0x00000040;
pub const COMP_BIT_ATI = 0x00000002;
pub const NEGATE_BIT_ATI = 0x00000004;
pub const BIAS_BIT_ATI = 0x00000008;
pub const TRACE_OPERATIONS_BIT_MESA = 0x0001;
pub const TRACE_PRIMITIVES_BIT_MESA = 0x0002;
pub const TRACE_ARRAYS_BIT_MESA = 0x0004;
pub const TRACE_TEXTURES_BIT_MESA = 0x0008;
pub const TRACE_PIXELS_BIT_MESA = 0x0010;
pub const TRACE_ERRORS_BIT_MESA = 0x0020;
pub const TRACE_ALL_BITS_MESA = 0xFFFF;
pub const BOLD_BIT_NV = 0x01;
pub const ITALIC_BIT_NV = 0x02;
pub const GLYPH_WIDTH_BIT_NV = 0x01;
pub const GLYPH_HEIGHT_BIT_NV = 0x02;
pub const GLYPH_HORIZONTAL_BEARING_X_BIT_NV = 0x04;
pub const GLYPH_HORIZONTAL_BEARING_Y_BIT_NV = 0x08;
pub const GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV = 0x10;
pub const GLYPH_VERTICAL_BEARING_X_BIT_NV = 0x20;
pub const GLYPH_VERTICAL_BEARING_Y_BIT_NV = 0x40;
pub const GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV = 0x80;
pub const GLYPH_HAS_KERNING_BIT_NV = 0x100;
pub const FONT_X_MIN_BOUNDS_BIT_NV = 0x00010000;
pub const FONT_Y_MIN_BOUNDS_BIT_NV = 0x00020000;
pub const FONT_X_MAX_BOUNDS_BIT_NV = 0x00040000;
pub const FONT_Y_MAX_BOUNDS_BIT_NV = 0x00080000;
pub const FONT_UNITS_PER_EM_BIT_NV = 0x00100000;
pub const FONT_ASCENDER_BIT_NV = 0x00200000;
pub const FONT_DESCENDER_BIT_NV = 0x00400000;
pub const FONT_HEIGHT_BIT_NV = 0x00800000;
pub const FONT_MAX_ADVANCE_WIDTH_BIT_NV = 0x01000000;
pub const FONT_MAX_ADVANCE_HEIGHT_BIT_NV = 0x02000000;
pub const FONT_UNDERLINE_POSITION_BIT_NV = 0x04000000;
pub const FONT_UNDERLINE_THICKNESS_BIT_NV = 0x08000000;
pub const FONT_HAS_KERNING_BIT_NV = 0x10000000;
pub const FONT_NUM_GLYPH_INDICES_BIT_NV = 0x20000000;
pub const PERFQUERY_SINGLE_CONTEXT_INTEL = 0x00000000;
pub const PERFQUERY_GLOBAL_CONTEXT_INTEL = 0x00000001;
pub const VERTEX23_BIT_PGI = 0x00000004;
pub const VERTEX4_BIT_PGI = 0x00000008;
pub const COLOR3_BIT_PGI = 0x00010000;
pub const COLOR4_BIT_PGI = 0x00020000;
pub const EDGEFLAG_BIT_PGI = 0x00040000;
pub const INDEX_BIT_PGI = 0x00080000;
pub const MAT_AMBIENT_BIT_PGI = 0x00100000;
pub const MAT_AMBIENT_AND_DIFFUSE_BIT_PGI = 0x00200000;
pub const MAT_DIFFUSE_BIT_PGI = 0x00400000;
pub const MAT_EMISSION_BIT_PGI = 0x00800000;
pub const MAT_COLOR_INDEXES_BIT_PGI = 0x01000000;
pub const MAT_SHININESS_BIT_PGI = 0x02000000;
pub const MAT_SPECULAR_BIT_PGI = 0x04000000;
pub const NORMAL_BIT_PGI = 0x08000000;
pub const TEXCOORD1_BIT_PGI = 0x10000000;
pub const TEXCOORD2_BIT_PGI = 0x20000000;
pub const TEXCOORD3_BIT_PGI = 0x40000000;
pub const TEXCOORD4_BIT_PGI = 0x80000000;
pub const COLOR_BUFFER_BIT0_QCOM = 0x00000001;
pub const COLOR_BUFFER_BIT1_QCOM = 0x00000002;
pub const COLOR_BUFFER_BIT2_QCOM = 0x00000004;
pub const COLOR_BUFFER_BIT3_QCOM = 0x00000008;
pub const COLOR_BUFFER_BIT4_QCOM = 0x00000010;
pub const COLOR_BUFFER_BIT5_QCOM = 0x00000020;
pub const COLOR_BUFFER_BIT6_QCOM = 0x00000040;
pub const COLOR_BUFFER_BIT7_QCOM = 0x00000080;
pub const DEPTH_BUFFER_BIT0_QCOM = 0x00000100;
pub const DEPTH_BUFFER_BIT1_QCOM = 0x00000200;
pub const DEPTH_BUFFER_BIT2_QCOM = 0x00000400;
pub const DEPTH_BUFFER_BIT3_QCOM = 0x00000800;
pub const DEPTH_BUFFER_BIT4_QCOM = 0x00001000;
pub const DEPTH_BUFFER_BIT5_QCOM = 0x00002000;
pub const DEPTH_BUFFER_BIT6_QCOM = 0x00004000;
pub const DEPTH_BUFFER_BIT7_QCOM = 0x00008000;
pub const STENCIL_BUFFER_BIT0_QCOM = 0x00010000;
pub const STENCIL_BUFFER_BIT1_QCOM = 0x00020000;
pub const STENCIL_BUFFER_BIT2_QCOM = 0x00040000;
pub const STENCIL_BUFFER_BIT3_QCOM = 0x00080000;
pub const STENCIL_BUFFER_BIT4_QCOM = 0x00100000;
pub const STENCIL_BUFFER_BIT5_QCOM = 0x00200000;
pub const STENCIL_BUFFER_BIT6_QCOM = 0x00400000;
pub const STENCIL_BUFFER_BIT7_QCOM = 0x00800000;
pub const MULTISAMPLE_BUFFER_BIT0_QCOM = 0x01000000;
pub const MULTISAMPLE_BUFFER_BIT1_QCOM = 0x02000000;
pub const MULTISAMPLE_BUFFER_BIT2_QCOM = 0x04000000;
pub const MULTISAMPLE_BUFFER_BIT3_QCOM = 0x08000000;
pub const MULTISAMPLE_BUFFER_BIT4_QCOM = 0x10000000;
pub const MULTISAMPLE_BUFFER_BIT5_QCOM = 0x20000000;
pub const MULTISAMPLE_BUFFER_BIT6_QCOM = 0x40000000;
pub const MULTISAMPLE_BUFFER_BIT7_QCOM = 0x80000000;
pub const FOVEATION_ENABLE_BIT_QCOM = 0x00000001;
pub const FOVEATION_SCALED_BIN_METHOD_BIT_QCOM = 0x00000002;
pub const FOVEATION_SUBSAMPLED_LAYOUT_METHOD_BIT_QCOM = 0x00000004;
pub const TEXTURE_DEFORMATION_BIT_SGIX = 0x00000001;
pub const GEOMETRY_DEFORMATION_BIT_SGIX = 0x00000002;
pub const TERMINATE_SEQUENCE_COMMAND_NV = 0x0000;
pub const NOP_COMMAND_NV = 0x0001;
pub const DRAW_ELEMENTS_COMMAND_NV = 0x0002;
pub const DRAW_ARRAYS_COMMAND_NV = 0x0003;
pub const DRAW_ELEMENTS_STRIP_COMMAND_NV = 0x0004;
pub const DRAW_ARRAYS_STRIP_COMMAND_NV = 0x0005;
pub const DRAW_ELEMENTS_INSTANCED_COMMAND_NV = 0x0006;
pub const DRAW_ARRAYS_INSTANCED_COMMAND_NV = 0x0007;
pub const ELEMENT_ADDRESS_COMMAND_NV = 0x0008;
pub const ATTRIBUTE_ADDRESS_COMMAND_NV = 0x0009;
pub const UNIFORM_ADDRESS_COMMAND_NV = 0x000A;
pub const BLEND_COLOR_COMMAND_NV = 0x000B;
pub const STENCIL_REF_COMMAND_NV = 0x000C;
pub const LINE_WIDTH_COMMAND_NV = 0x000D;
pub const POLYGON_OFFSET_COMMAND_NV = 0x000E;
pub const ALPHA_REF_COMMAND_NV = 0x000F;
pub const VIEWPORT_COMMAND_NV = 0x0010;
pub const SCISSOR_COMMAND_NV = 0x0011;
pub const FRONT_FACE_COMMAND_NV = 0x0012;
pub const LAYOUT_DEFAULT_INTEL = 0;
pub const LAYOUT_LINEAR_INTEL = 1;
pub const LAYOUT_LINEAR_CPU_CACHED_INTEL = 2;
pub const CLOSE_PATH_NV = 0x00;
pub const MOVE_TO_NV = 0x02;
pub const RELATIVE_MOVE_TO_NV = 0x03;
pub const LINE_TO_NV = 0x04;
pub const RELATIVE_LINE_TO_NV = 0x05;
pub const HORIZONTAL_LINE_TO_NV = 0x06;
pub const RELATIVE_HORIZONTAL_LINE_TO_NV = 0x07;
pub const VERTICAL_LINE_TO_NV = 0x08;
pub const RELATIVE_VERTICAL_LINE_TO_NV = 0x09;
pub const QUADRATIC_CURVE_TO_NV = 0x0A;
pub const RELATIVE_QUADRATIC_CURVE_TO_NV = 0x0B;
pub const CUBIC_CURVE_TO_NV = 0x0C;
pub const RELATIVE_CUBIC_CURVE_TO_NV = 0x0D;
pub const SMOOTH_QUADRATIC_CURVE_TO_NV = 0x0E;
pub const RELATIVE_SMOOTH_QUADRATIC_CURVE_TO_NV = 0x0F;
pub const SMOOTH_CUBIC_CURVE_TO_NV = 0x10;
pub const RELATIVE_SMOOTH_CUBIC_CURVE_TO_NV = 0x11;
pub const SMALL_CCW_ARC_TO_NV = 0x12;
pub const RELATIVE_SMALL_CCW_ARC_TO_NV = 0x13;
pub const SMALL_CW_ARC_TO_NV = 0x14;
pub const RELATIVE_SMALL_CW_ARC_TO_NV = 0x15;
pub const LARGE_CCW_ARC_TO_NV = 0x16;
pub const RELATIVE_LARGE_CCW_ARC_TO_NV = 0x17;
pub const LARGE_CW_ARC_TO_NV = 0x18;
pub const RELATIVE_LARGE_CW_ARC_TO_NV = 0x19;
pub const CONIC_CURVE_TO_NV = 0x1A;
pub const RELATIVE_CONIC_CURVE_TO_NV = 0x1B;
pub const SHARED_EDGE_NV = 0xC0;
pub const ROUNDED_RECT_NV = 0xE8;
pub const RELATIVE_ROUNDED_RECT_NV = 0xE9;
pub const ROUNDED_RECT2_NV = 0xEA;
pub const RELATIVE_ROUNDED_RECT2_NV = 0xEB;
pub const ROUNDED_RECT4_NV = 0xEC;
pub const RELATIVE_ROUNDED_RECT4_NV = 0xED;
pub const ROUNDED_RECT8_NV = 0xEE;
pub const RELATIVE_ROUNDED_RECT8_NV = 0xEF;
pub const RESTART_PATH_NV = 0xF0;
pub const DUP_FIRST_CUBIC_CURVE_TO_NV = 0xF2;
pub const DUP_LAST_CUBIC_CURVE_TO_NV = 0xF4;
pub const RECT_NV = 0xF6;
pub const RELATIVE_RECT_NV = 0xF7;
pub const CIRCULAR_CCW_ARC_TO_NV = 0xF8;
pub const CIRCULAR_CW_ARC_TO_NV = 0xFA;
pub const CIRCULAR_TANGENT_ARC_TO_NV = 0xFC;
pub const ARC_TO_NV = 0xFE;
pub const RELATIVE_ARC_TO_NV = 0xFF;
pub const NEXT_BUFFER_NV = -2;
pub const SKIP_COMPONENTS4_NV = -3;
pub const SKIP_COMPONENTS3_NV = -4;
pub const SKIP_COMPONENTS2_NV = -5;
pub const SKIP_COMPONENTS1_NV = -6;
pub const RESTART_SUN = 0x0001;
pub const REPLACE_MIDDLE_SUN = 0x0002;
pub const REPLACE_OLDEST_SUN = 0x0003;
pub const FALSE = 0;
pub const NO_ERROR = 0;
pub const ZERO = 0;
pub const NONE = 0;
pub const NONE_OES = 0;
pub const TRUE = 1;
pub const ONE = 1;
pub const INVALID_INDEX = 0xFFFFFFFF;
pub const ALL_PIXELS_AMD = 0xFFFFFFFF;
pub const TIMEOUT_IGNORED = 0xFFFFFFFFFFFFFFFF;
pub const TIMEOUT_IGNORED_APPLE = 0xFFFFFFFFFFFFFFFF;
pub const VERSION_ES_CL_1_0 = 1;
pub const VERSION_ES_CM_1_1 = 1;
pub const VERSION_ES_CL_1_1 = 1;
pub const UUID_SIZE_EXT = 16;
pub const LUID_SIZE_EXT = 8;
pub const POINTS = 0x0000;
pub const LINES = 0x0001;
pub const LINE_LOOP = 0x0002;
pub const LINE_STRIP = 0x0003;
pub const TRIANGLES = 0x0004;
pub const TRIANGLE_STRIP = 0x0005;
pub const TRIANGLE_FAN = 0x0006;
pub const QUADS = 0x0007;
pub const QUADS_EXT = 0x0007;
pub const QUADS_OES = 0x0007;
pub const QUAD_STRIP = 0x0008;
pub const POLYGON = 0x0009;
pub const LINES_ADJACENCY = 0x000A;
pub const LINES_ADJACENCY_ARB = 0x000A;
pub const LINES_ADJACENCY_EXT = 0x000A;
pub const LINES_ADJACENCY_OES = 0x000A;
pub const LINE_STRIP_ADJACENCY = 0x000B;
pub const LINE_STRIP_ADJACENCY_ARB = 0x000B;
pub const LINE_STRIP_ADJACENCY_EXT = 0x000B;
pub const LINE_STRIP_ADJACENCY_OES = 0x000B;
pub const TRIANGLES_ADJACENCY = 0x000C;
pub const TRIANGLES_ADJACENCY_ARB = 0x000C;
pub const TRIANGLES_ADJACENCY_EXT = 0x000C;
pub const TRIANGLES_ADJACENCY_OES = 0x000C;
pub const TRIANGLE_STRIP_ADJACENCY = 0x000D;
pub const TRIANGLE_STRIP_ADJACENCY_ARB = 0x000D;
pub const TRIANGLE_STRIP_ADJACENCY_EXT = 0x000D;
pub const TRIANGLE_STRIP_ADJACENCY_OES = 0x000D;
pub const PATCHES = 0x000E;
pub const PATCHES_EXT = 0x000E;
pub const PATCHES_OES = 0x000E;
pub const ACCUM = 0x0100;
pub const LOAD = 0x0101;
pub const RETURN = 0x0102;
pub const MULT = 0x0103;
pub const ADD = 0x0104;
pub const NEVER = 0x0200;
pub const LESS = 0x0201;
pub const EQUAL = 0x0202;
pub const LEQUAL = 0x0203;
pub const GREATER = 0x0204;
pub const NOTEQUAL = 0x0205;
pub const GEQUAL = 0x0206;
pub const ALWAYS = 0x0207;
pub const SRC_COLOR = 0x0300;
pub const ONE_MINUS_SRC_COLOR = 0x0301;
pub const SRC_ALPHA = 0x0302;
pub const ONE_MINUS_SRC_ALPHA = 0x0303;
pub const DST_ALPHA = 0x0304;
pub const ONE_MINUS_DST_ALPHA = 0x0305;
pub const DST_COLOR = 0x0306;
pub const ONE_MINUS_DST_COLOR = 0x0307;
pub const SRC_ALPHA_SATURATE = 0x0308;
pub const SRC_ALPHA_SATURATE_EXT = 0x0308;
pub const FRONT_LEFT = 0x0400;
pub const FRONT_RIGHT = 0x0401;
pub const BACK_LEFT = 0x0402;
pub const BACK_RIGHT = 0x0403;
pub const FRONT = 0x0404;
pub const BACK = 0x0405;
pub const LEFT = 0x0406;
pub const RIGHT = 0x0407;
pub const FRONT_AND_BACK = 0x0408;
pub const AUX0 = 0x0409;
pub const AUX1 = 0x040A;
pub const AUX2 = 0x040B;
pub const AUX3 = 0x040C;
pub const INVALID_ENUM = 0x0500;
pub const INVALID_VALUE = 0x0501;
pub const INVALID_OPERATION = 0x0502;
pub const STACK_OVERFLOW = 0x0503;
pub const STACK_OVERFLOW_KHR = 0x0503;
pub const STACK_UNDERFLOW = 0x0504;
pub const STACK_UNDERFLOW_KHR = 0x0504;
pub const OUT_OF_MEMORY = 0x0505;
pub const INVALID_FRAMEBUFFER_OPERATION = 0x0506;
pub const INVALID_FRAMEBUFFER_OPERATION_EXT = 0x0506;
pub const INVALID_FRAMEBUFFER_OPERATION_OES = 0x0506;
pub const CONTEXT_LOST = 0x0507;
pub const CONTEXT_LOST_KHR = 0x0507;
pub const @"2D" = 0x0600;
pub const @"3D" = 0x0601;
pub const @"3D_COLOR" = 0x0602;
pub const @"3D_COLOR_TEXTURE" = 0x0603;
pub const @"4D_COLOR_TEXTURE" = 0x0604;
pub const PASS_THROUGH_TOKEN = 0x0700;
pub const POINT_TOKEN = 0x0701;
pub const LINE_TOKEN = 0x0702;
pub const POLYGON_TOKEN = 0x0703;
pub const BITMAP_TOKEN = 0x0704;
pub const DRAW_PIXEL_TOKEN = 0x0705;
pub const COPY_PIXEL_TOKEN = 0x0706;
pub const LINE_RESET_TOKEN = 0x0707;
pub const EXP = 0x0800;
pub const EXP2 = 0x0801;
pub const CW = 0x0900;
pub const CCW = 0x0901;
pub const COEFF = 0x0A00;
pub const ORDER = 0x0A01;
pub const DOMAIN = 0x0A02;
pub const CURRENT_COLOR = 0x0B00;
pub const CURRENT_INDEX = 0x0B01;
pub const CURRENT_NORMAL = 0x0B02;
pub const CURRENT_TEXTURE_COORDS = 0x0B03;
pub const CURRENT_RASTER_COLOR = 0x0B04;
pub const CURRENT_RASTER_INDEX = 0x0B05;
pub const CURRENT_RASTER_TEXTURE_COORDS = 0x0B06;
pub const CURRENT_RASTER_POSITION = 0x0B07;
pub const CURRENT_RASTER_POSITION_VALID = 0x0B08;
pub const CURRENT_RASTER_DISTANCE = 0x0B09;
pub const POINT_SMOOTH = 0x0B10;
pub const POINT_SIZE = 0x0B11;
pub const POINT_SIZE_RANGE = 0x0B12;
pub const SMOOTH_POINT_SIZE_RANGE = 0x0B12;
pub const POINT_SIZE_GRANULARITY = 0x0B13;
pub const SMOOTH_POINT_SIZE_GRANULARITY = 0x0B13;
pub const LINE_SMOOTH = 0x0B20;
pub const LINE_WIDTH = 0x0B21;
pub const LINE_WIDTH_RANGE = 0x0B22;
pub const SMOOTH_LINE_WIDTH_RANGE = 0x0B22;
pub const LINE_WIDTH_GRANULARITY = 0x0B23;
pub const SMOOTH_LINE_WIDTH_GRANULARITY = 0x0B23;
pub const LINE_STIPPLE = 0x0B24;
pub const LINE_STIPPLE_PATTERN = 0x0B25;
pub const LINE_STIPPLE_REPEAT = 0x0B26;
pub const LIST_MODE = 0x0B30;
pub const MAX_LIST_NESTING = 0x0B31;
pub const LIST_BASE = 0x0B32;
pub const LIST_INDEX = 0x0B33;
pub const POLYGON_MODE = 0x0B40;
pub const POLYGON_MODE_NV = 0x0B40;
pub const POLYGON_SMOOTH = 0x0B41;
pub const POLYGON_STIPPLE = 0x0B42;
pub const EDGE_FLAG = 0x0B43;
pub const CULL_FACE = 0x0B44;
pub const CULL_FACE_MODE = 0x0B45;
pub const FRONT_FACE = 0x0B46;
pub const LIGHTING = 0x0B50;
pub const LIGHT_MODEL_LOCAL_VIEWER = 0x0B51;
pub const LIGHT_MODEL_TWO_SIDE = 0x0B52;
pub const LIGHT_MODEL_AMBIENT = 0x0B53;
pub const SHADE_MODEL = 0x0B54;
pub const COLOR_MATERIAL_FACE = 0x0B55;
pub const COLOR_MATERIAL_PARAMETER = 0x0B56;
pub const COLOR_MATERIAL = 0x0B57;
pub const FOG = 0x0B60;
pub const FOG_INDEX = 0x0B61;
pub const FOG_DENSITY = 0x0B62;
pub const FOG_START = 0x0B63;
pub const FOG_END = 0x0B64;
pub const FOG_MODE = 0x0B65;
pub const FOG_COLOR = 0x0B66;
pub const DEPTH_RANGE = 0x0B70;
pub const DEPTH_TEST = 0x0B71;
pub const DEPTH_WRITEMASK = 0x0B72;
pub const DEPTH_CLEAR_VALUE = 0x0B73;
pub const DEPTH_FUNC = 0x0B74;
pub const ACCUM_CLEAR_VALUE = 0x0B80;
pub const STENCIL_TEST = 0x0B90;
pub const STENCIL_CLEAR_VALUE = 0x0B91;
pub const STENCIL_FUNC = 0x0B92;
pub const STENCIL_VALUE_MASK = 0x0B93;
pub const STENCIL_FAIL = 0x0B94;
pub const STENCIL_PASS_DEPTH_FAIL = 0x0B95;
pub const STENCIL_PASS_DEPTH_PASS = 0x0B96;
pub const STENCIL_REF = 0x0B97;
pub const STENCIL_WRITEMASK = 0x0B98;
pub const MATRIX_MODE = 0x0BA0;
pub const NORMALIZE = 0x0BA1;
pub const VIEWPORT = 0x0BA2;
pub const MODELVIEW_STACK_DEPTH = 0x0BA3;
pub const MODELVIEW0_STACK_DEPTH_EXT = 0x0BA3;
pub const PATH_MODELVIEW_STACK_DEPTH_NV = 0x0BA3;
pub const PROJECTION_STACK_DEPTH = 0x0BA4;
pub const PATH_PROJECTION_STACK_DEPTH_NV = 0x0BA4;
pub const TEXTURE_STACK_DEPTH = 0x0BA5;
pub const MODELVIEW_MATRIX = 0x0BA6;
pub const MODELVIEW0_MATRIX_EXT = 0x0BA6;
pub const PATH_MODELVIEW_MATRIX_NV = 0x0BA6;
pub const PROJECTION_MATRIX = 0x0BA7;
pub const PATH_PROJECTION_MATRIX_NV = 0x0BA7;
pub const TEXTURE_MATRIX = 0x0BA8;
pub const ATTRIB_STACK_DEPTH = 0x0BB0;
pub const CLIENT_ATTRIB_STACK_DEPTH = 0x0BB1;
pub const ALPHA_TEST = 0x0BC0;
pub const ALPHA_TEST_QCOM = 0x0BC0;
pub const ALPHA_TEST_FUNC = 0x0BC1;
pub const ALPHA_TEST_FUNC_QCOM = 0x0BC1;
pub const ALPHA_TEST_REF = 0x0BC2;
pub const ALPHA_TEST_REF_QCOM = 0x0BC2;
pub const DITHER = 0x0BD0;
pub const BLEND_DST = 0x0BE0;
pub const BLEND_SRC = 0x0BE1;
pub const BLEND = 0x0BE2;
pub const LOGIC_OP_MODE = 0x0BF0;
pub const INDEX_LOGIC_OP = 0x0BF1;
pub const LOGIC_OP = 0x0BF1;
pub const COLOR_LOGIC_OP = 0x0BF2;
pub const AUX_BUFFERS = 0x0C00;
pub const DRAW_BUFFER = 0x0C01;
pub const DRAW_BUFFER_EXT = 0x0C01;
pub const READ_BUFFER = 0x0C02;
pub const READ_BUFFER_EXT = 0x0C02;
pub const READ_BUFFER_NV = 0x0C02;
pub const SCISSOR_BOX = 0x0C10;
pub const SCISSOR_TEST = 0x0C11;
pub const INDEX_CLEAR_VALUE = 0x0C20;
pub const INDEX_WRITEMASK = 0x0C21;
pub const COLOR_CLEAR_VALUE = 0x0C22;
pub const COLOR_WRITEMASK = 0x0C23;
pub const INDEX_MODE = 0x0C30;
pub const RGBA_MODE = 0x0C31;
pub const DOUBLEBUFFER = 0x0C32;
pub const STEREO = 0x0C33;
pub const RENDER_MODE = 0x0C40;
pub const PERSPECTIVE_CORRECTION_HINT = 0x0C50;
pub const POINT_SMOOTH_HINT = 0x0C51;
pub const LINE_SMOOTH_HINT = 0x0C52;
pub const POLYGON_SMOOTH_HINT = 0x0C53;
pub const FOG_HINT = 0x0C54;
pub const TEXTURE_GEN_S = 0x0C60;
pub const TEXTURE_GEN_T = 0x0C61;
pub const TEXTURE_GEN_R = 0x0C62;
pub const TEXTURE_GEN_Q = 0x0C63;
pub const PIXEL_MAP_I_TO_I = 0x0C70;
pub const PIXEL_MAP_S_TO_S = 0x0C71;
pub const PIXEL_MAP_I_TO_R = 0x0C72;
pub const PIXEL_MAP_I_TO_G = 0x0C73;
pub const PIXEL_MAP_I_TO_B = 0x0C74;
pub const PIXEL_MAP_I_TO_A = 0x0C75;
pub const PIXEL_MAP_R_TO_R = 0x0C76;
pub const PIXEL_MAP_G_TO_G = 0x0C77;
pub const PIXEL_MAP_B_TO_B = 0x0C78;
pub const PIXEL_MAP_A_TO_A = 0x0C79;
pub const PIXEL_MAP_I_TO_I_SIZE = 0x0CB0;
pub const PIXEL_MAP_S_TO_S_SIZE = 0x0CB1;
pub const PIXEL_MAP_I_TO_R_SIZE = 0x0CB2;
pub const PIXEL_MAP_I_TO_G_SIZE = 0x0CB3;
pub const PIXEL_MAP_I_TO_B_SIZE = 0x0CB4;
pub const PIXEL_MAP_I_TO_A_SIZE = 0x0CB5;
pub const PIXEL_MAP_R_TO_R_SIZE = 0x0CB6;
pub const PIXEL_MAP_G_TO_G_SIZE = 0x0CB7;
pub const PIXEL_MAP_B_TO_B_SIZE = 0x0CB8;
pub const PIXEL_MAP_A_TO_A_SIZE = 0x0CB9;
pub const UNPACK_SWAP_BYTES = 0x0CF0;
pub const UNPACK_LSB_FIRST = 0x0CF1;
pub const UNPACK_ROW_LENGTH = 0x0CF2;
pub const UNPACK_ROW_LENGTH_EXT = 0x0CF2;
pub const UNPACK_SKIP_ROWS = 0x0CF3;
pub const UNPACK_SKIP_ROWS_EXT = 0x0CF3;
pub const UNPACK_SKIP_PIXELS = 0x0CF4;
pub const UNPACK_SKIP_PIXELS_EXT = 0x0CF4;
pub const UNPACK_ALIGNMENT = 0x0CF5;
pub const PACK_SWAP_BYTES = 0x0D00;
pub const PACK_LSB_FIRST = 0x0D01;
pub const PACK_ROW_LENGTH = 0x0D02;
pub const PACK_SKIP_ROWS = 0x0D03;
pub const PACK_SKIP_PIXELS = 0x0D04;
pub const PACK_ALIGNMENT = 0x0D05;
pub const MAP_COLOR = 0x0D10;
pub const MAP_STENCIL = 0x0D11;
pub const INDEX_SHIFT = 0x0D12;
pub const INDEX_OFFSET = 0x0D13;
pub const RED_SCALE = 0x0D14;
pub const RED_BIAS = 0x0D15;
pub const ZOOM_X = 0x0D16;
pub const ZOOM_Y = 0x0D17;
pub const GREEN_SCALE = 0x0D18;
pub const GREEN_BIAS = 0x0D19;
pub const BLUE_SCALE = 0x0D1A;
pub const BLUE_BIAS = 0x0D1B;
pub const ALPHA_SCALE = 0x0D1C;
pub const ALPHA_BIAS = 0x0D1D;
pub const DEPTH_SCALE = 0x0D1E;
pub const DEPTH_BIAS = 0x0D1F;
pub const MAX_EVAL_ORDER = 0x0D30;
pub const MAX_LIGHTS = 0x0D31;
pub const MAX_CLIP_PLANES = 0x0D32;
pub const MAX_CLIP_PLANES_IMG = 0x0D32;
pub const MAX_CLIP_DISTANCES = 0x0D32;
pub const MAX_CLIP_DISTANCES_EXT = 0x0D32;
pub const MAX_CLIP_DISTANCES_APPLE = 0x0D32;
pub const MAX_TEXTURE_SIZE = 0x0D33;
pub const MAX_PIXEL_MAP_TABLE = 0x0D34;
pub const MAX_ATTRIB_STACK_DEPTH = 0x0D35;
pub const MAX_MODELVIEW_STACK_DEPTH = 0x0D36;
pub const PATH_MAX_MODELVIEW_STACK_DEPTH_NV = 0x0D36;
pub const MAX_NAME_STACK_DEPTH = 0x0D37;
pub const MAX_PROJECTION_STACK_DEPTH = 0x0D38;
pub const PATH_MAX_PROJECTION_STACK_DEPTH_NV = 0x0D38;
pub const MAX_TEXTURE_STACK_DEPTH = 0x0D39;
pub const MAX_VIEWPORT_DIMS = 0x0D3A;
pub const MAX_CLIENT_ATTRIB_STACK_DEPTH = 0x0D3B;
pub const SUBPIXEL_BITS = 0x0D50;
pub const INDEX_BITS = 0x0D51;
pub const RED_BITS = 0x0D52;
pub const GREEN_BITS = 0x0D53;
pub const BLUE_BITS = 0x0D54;
pub const ALPHA_BITS = 0x0D55;
pub const DEPTH_BITS = 0x0D56;
pub const STENCIL_BITS = 0x0D57;
pub const ACCUM_RED_BITS = 0x0D58;
pub const ACCUM_GREEN_BITS = 0x0D59;
pub const ACCUM_BLUE_BITS = 0x0D5A;
pub const ACCUM_ALPHA_BITS = 0x0D5B;
pub const NAME_STACK_DEPTH = 0x0D70;
pub const AUTO_NORMAL = 0x0D80;
pub const MAP1_COLOR_4 = 0x0D90;
pub const MAP1_INDEX = 0x0D91;
pub const MAP1_NORMAL = 0x0D92;
pub const MAP1_TEXTURE_COORD_1 = 0x0D93;
pub const MAP1_TEXTURE_COORD_2 = 0x0D94;
pub const MAP1_TEXTURE_COORD_3 = 0x0D95;
pub const MAP1_TEXTURE_COORD_4 = 0x0D96;
pub const MAP1_VERTEX_3 = 0x0D97;
pub const MAP1_VERTEX_4 = 0x0D98;
pub const MAP2_COLOR_4 = 0x0DB0;
pub const MAP2_INDEX = 0x0DB1;
pub const MAP2_NORMAL = 0x0DB2;
pub const MAP2_TEXTURE_COORD_1 = 0x0DB3;
pub const MAP2_TEXTURE_COORD_2 = 0x0DB4;
pub const MAP2_TEXTURE_COORD_3 = 0x0DB5;
pub const MAP2_TEXTURE_COORD_4 = 0x0DB6;
pub const MAP2_VERTEX_3 = 0x0DB7;
pub const MAP2_VERTEX_4 = 0x0DB8;
pub const MAP1_GRID_DOMAIN = 0x0DD0;
pub const MAP1_GRID_SEGMENTS = 0x0DD1;
pub const MAP2_GRID_DOMAIN = 0x0DD2;
pub const MAP2_GRID_SEGMENTS = 0x0DD3;
pub const TEXTURE_1D = 0x0DE0;
pub const TEXTURE_2D = 0x0DE1;
pub const FEEDBACK_BUFFER_POINTER = 0x0DF0;
pub const FEEDBACK_BUFFER_SIZE = 0x0DF1;
pub const FEEDBACK_BUFFER_TYPE = 0x0DF2;
pub const SELECTION_BUFFER_POINTER = 0x0DF3;
pub const SELECTION_BUFFER_SIZE = 0x0DF4;
pub const TEXTURE_WIDTH = 0x1000;
pub const TEXTURE_HEIGHT = 0x1001;
pub const TEXTURE_INTERNAL_FORMAT = 0x1003;
pub const TEXTURE_COMPONENTS = 0x1003;
pub const TEXTURE_BORDER_COLOR = 0x1004;
pub const TEXTURE_BORDER_COLOR_EXT = 0x1004;
pub const TEXTURE_BORDER_COLOR_NV = 0x1004;
pub const TEXTURE_BORDER_COLOR_OES = 0x1004;
pub const TEXTURE_BORDER = 0x1005;
pub const TEXTURE_TARGET = 0x1006;
pub const DONT_CARE = 0x1100;
pub const FASTEST = 0x1101;
pub const NICEST = 0x1102;
pub const AMBIENT = 0x1200;
pub const DIFFUSE = 0x1201;
pub const SPECULAR = 0x1202;
pub const POSITION = 0x1203;
pub const SPOT_DIRECTION = 0x1204;
pub const SPOT_EXPONENT = 0x1205;
pub const SPOT_CUTOFF = 0x1206;
pub const CONSTANT_ATTENUATION = 0x1207;
pub const LINEAR_ATTENUATION = 0x1208;
pub const QUADRATIC_ATTENUATION = 0x1209;
pub const COMPILE = 0x1300;
pub const COMPILE_AND_EXECUTE = 0x1301;
pub const BYTE = 0x1400;
pub const UNSIGNED_BYTE = 0x1401;
pub const SHORT = 0x1402;
pub const UNSIGNED_SHORT = 0x1403;
pub const INT = 0x1404;
pub const UNSIGNED_INT = 0x1405;
pub const FLOAT = 0x1406;
pub const @"2_BYTES" = 0x1407;
pub const @"2_BYTES_NV" = 0x1407;
pub const @"3_BYTES" = 0x1408;
pub const @"3_BYTES_NV" = 0x1408;
pub const @"4_BYTES" = 0x1409;
pub const @"4_BYTES_NV" = 0x1409;
pub const DOUBLE = 0x140A;
pub const DOUBLE_EXT = 0x140A;
pub const HALF_FLOAT = 0x140B;
pub const HALF_FLOAT_ARB = 0x140B;
pub const HALF_FLOAT_NV = 0x140B;
pub const HALF_APPLE = 0x140B;
pub const FIXED = 0x140C;
pub const FIXED_OES = 0x140C;
pub const INT64_ARB = 0x140E;
pub const INT64_NV = 0x140E;
pub const UNSIGNED_INT64_ARB = 0x140F;
pub const UNSIGNED_INT64_NV = 0x140F;
pub const CLEAR = 0x1500;
pub const AND = 0x1501;
pub const AND_REVERSE = 0x1502;
pub const COPY = 0x1503;
pub const AND_INVERTED = 0x1504;
pub const NOOP = 0x1505;
pub const XOR = 0x1506;
pub const XOR_NV = 0x1506;
pub const OR = 0x1507;
pub const NOR = 0x1508;
pub const EQUIV = 0x1509;
pub const INVERT = 0x150A;
pub const OR_REVERSE = 0x150B;
pub const COPY_INVERTED = 0x150C;
pub const OR_INVERTED = 0x150D;
pub const NAND = 0x150E;
pub const SET = 0x150F;
pub const EMISSION = 0x1600;
pub const SHININESS = 0x1601;
pub const AMBIENT_AND_DIFFUSE = 0x1602;
pub const COLOR_INDEXES = 0x1603;
pub const MODELVIEW = 0x1700;
pub const MODELVIEW0_ARB = 0x1700;
pub const MODELVIEW0_EXT = 0x1700;
pub const PATH_MODELVIEW_NV = 0x1700;
pub const PROJECTION = 0x1701;
pub const PATH_PROJECTION_NV = 0x1701;
pub const TEXTURE = 0x1702;
pub const COLOR = 0x1800;
pub const COLOR_EXT = 0x1800;
pub const DEPTH = 0x1801;
pub const DEPTH_EXT = 0x1801;
pub const STENCIL = 0x1802;
pub const STENCIL_EXT = 0x1802;
pub const COLOR_INDEX = 0x1900;
pub const STENCIL_INDEX = 0x1901;
pub const STENCIL_INDEX_OES = 0x1901;
pub const DEPTH_COMPONENT = 0x1902;
pub const RED = 0x1903;
pub const RED_EXT = 0x1903;
pub const RED_NV = 0x1903;
pub const GREEN = 0x1904;
pub const GREEN_NV = 0x1904;
pub const BLUE = 0x1905;
pub const BLUE_NV = 0x1905;
pub const ALPHA = 0x1906;
pub const RGB = 0x1907;
pub const RGBA = 0x1908;
pub const LUMINANCE = 0x1909;
pub const LUMINANCE_ALPHA = 0x190A;
pub const BITMAP = 0x1A00;
pub const POINT = 0x1B00;
pub const POINT_NV = 0x1B00;
pub const LINE = 0x1B01;
pub const LINE_NV = 0x1B01;
pub const FILL = 0x1B02;
pub const FILL_NV = 0x1B02;
pub const RENDER = 0x1C00;
pub const FEEDBACK = 0x1C01;
pub const SELECT = 0x1C02;
pub const FLAT = 0x1D00;
pub const SMOOTH = 0x1D01;
pub const KEEP = 0x1E00;
pub const REPLACE = 0x1E01;
pub const INCR = 0x1E02;
pub const DECR = 0x1E03;
pub const VENDOR = 0x1F00;
pub const RENDERER = 0x1F01;
pub const VERSION = 0x1F02;
pub const EXTENSIONS = 0x1F03;
pub const S = 0x2000;
pub const T = 0x2001;
pub const R = 0x2002;
pub const Q = 0x2003;
pub const MODULATE = 0x2100;
pub const DECAL = 0x2101;
pub const TEXTURE_ENV_MODE = 0x2200;
pub const TEXTURE_ENV_COLOR = 0x2201;
pub const TEXTURE_ENV = 0x2300;
pub const EYE_LINEAR = 0x2400;
pub const EYE_LINEAR_NV = 0x2400;
pub const OBJECT_LINEAR = 0x2401;
pub const OBJECT_LINEAR_NV = 0x2401;
pub const SPHERE_MAP = 0x2402;
pub const TEXTURE_GEN_MODE = 0x2500;
pub const TEXTURE_GEN_MODE_OES = 0x2500;
pub const OBJECT_PLANE = 0x2501;
pub const EYE_PLANE = 0x2502;
pub const NEAREST = 0x2600;
pub const LINEAR = 0x2601;
pub const NEAREST_MIPMAP_NEAREST = 0x2700;
pub const LINEAR_MIPMAP_NEAREST = 0x2701;
pub const NEAREST_MIPMAP_LINEAR = 0x2702;
pub const LINEAR_MIPMAP_LINEAR = 0x2703;
pub const TEXTURE_MAG_FILTER = 0x2800;
pub const TEXTURE_MIN_FILTER = 0x2801;
pub const TEXTURE_WRAP_S = 0x2802;
pub const TEXTURE_WRAP_T = 0x2803;
pub const CLAMP = 0x2900;
pub const REPEAT = 0x2901;
pub const POLYGON_OFFSET_UNITS = 0x2A00;
pub const POLYGON_OFFSET_POINT = 0x2A01;
pub const POLYGON_OFFSET_POINT_NV = 0x2A01;
pub const POLYGON_OFFSET_LINE = 0x2A02;
pub const POLYGON_OFFSET_LINE_NV = 0x2A02;
pub const R3_G3_B2 = 0x2A10;
pub const V2F = 0x2A20;
pub const V3F = 0x2A21;
pub const C4UB_V2F = 0x2A22;
pub const C4UB_V3F = 0x2A23;
pub const C3F_V3F = 0x2A24;
pub const N3F_V3F = 0x2A25;
pub const C4F_N3F_V3F = 0x2A26;
pub const T2F_V3F = 0x2A27;
pub const T4F_V4F = 0x2A28;
pub const T2F_C4UB_V3F = 0x2A29;
pub const T2F_C3F_V3F = 0x2A2A;
pub const T2F_N3F_V3F = 0x2A2B;
pub const T2F_C4F_N3F_V3F = 0x2A2C;
pub const T4F_C4F_N3F_V4F = 0x2A2D;
pub const CLIP_PLANE0 = 0x3000;
pub const CLIP_PLANE0_IMG = 0x3000;
pub const CLIP_DISTANCE0 = 0x3000;
pub const CLIP_DISTANCE0_EXT = 0x3000;
pub const CLIP_DISTANCE0_APPLE = 0x3000;
pub const CLIP_PLANE1 = 0x3001;
pub const CLIP_PLANE1_IMG = 0x3001;
pub const CLIP_DISTANCE1 = 0x3001;
pub const CLIP_DISTANCE1_EXT = 0x3001;
pub const CLIP_DISTANCE1_APPLE = 0x3001;
pub const CLIP_PLANE2 = 0x3002;
pub const CLIP_PLANE2_IMG = 0x3002;
pub const CLIP_DISTANCE2 = 0x3002;
pub const CLIP_DISTANCE2_EXT = 0x3002;
pub const CLIP_DISTANCE2_APPLE = 0x3002;
pub const CLIP_PLANE3 = 0x3003;
pub const CLIP_PLANE3_IMG = 0x3003;
pub const CLIP_DISTANCE3 = 0x3003;
pub const CLIP_DISTANCE3_EXT = 0x3003;
pub const CLIP_DISTANCE3_APPLE = 0x3003;
pub const CLIP_PLANE4 = 0x3004;
pub const CLIP_PLANE4_IMG = 0x3004;
pub const CLIP_DISTANCE4 = 0x3004;
pub const CLIP_DISTANCE4_EXT = 0x3004;
pub const CLIP_DISTANCE4_APPLE = 0x3004;
pub const CLIP_PLANE5 = 0x3005;
pub const CLIP_PLANE5_IMG = 0x3005;
pub const CLIP_DISTANCE5 = 0x3005;
pub const CLIP_DISTANCE5_EXT = 0x3005;
pub const CLIP_DISTANCE5_APPLE = 0x3005;
pub const CLIP_DISTANCE6 = 0x3006;
pub const CLIP_DISTANCE6_EXT = 0x3006;
pub const CLIP_DISTANCE6_APPLE = 0x3006;
pub const CLIP_DISTANCE7 = 0x3007;
pub const CLIP_DISTANCE7_EXT = 0x3007;
pub const CLIP_DISTANCE7_APPLE = 0x3007;
pub const LIGHT0 = 0x4000;
pub const LIGHT1 = 0x4001;
pub const LIGHT2 = 0x4002;
pub const LIGHT3 = 0x4003;
pub const LIGHT4 = 0x4004;
pub const LIGHT5 = 0x4005;
pub const LIGHT6 = 0x4006;
pub const LIGHT7 = 0x4007;
pub const ABGR_EXT = 0x8000;
pub const CONSTANT_COLOR = 0x8001;
pub const CONSTANT_COLOR_EXT = 0x8001;
pub const ONE_MINUS_CONSTANT_COLOR = 0x8002;
pub const ONE_MINUS_CONSTANT_COLOR_EXT = 0x8002;
pub const CONSTANT_ALPHA = 0x8003;
pub const CONSTANT_ALPHA_EXT = 0x8003;
pub const ONE_MINUS_CONSTANT_ALPHA = 0x8004;
pub const ONE_MINUS_CONSTANT_ALPHA_EXT = 0x8004;
pub const BLEND_COLOR = 0x8005;
pub const BLEND_COLOR_EXT = 0x8005;
pub const FUNC_ADD = 0x8006;
pub const FUNC_ADD_EXT = 0x8006;
pub const FUNC_ADD_OES = 0x8006;
pub const MIN = 0x8007;
pub const MIN_EXT = 0x8007;
pub const MAX = 0x8008;
pub const MAX_EXT = 0x8008;
pub const BLEND_EQUATION = 0x8009;
pub const BLEND_EQUATION_EXT = 0x8009;
pub const BLEND_EQUATION_OES = 0x8009;
pub const BLEND_EQUATION_RGB = 0x8009;
pub const BLEND_EQUATION_RGB_EXT = 0x8009;
pub const BLEND_EQUATION_RGB_OES = 0x8009;
pub const FUNC_SUBTRACT = 0x800A;
pub const FUNC_SUBTRACT_EXT = 0x800A;
pub const FUNC_SUBTRACT_OES = 0x800A;
pub const FUNC_REVERSE_SUBTRACT = 0x800B;
pub const FUNC_REVERSE_SUBTRACT_EXT = 0x800B;
pub const FUNC_REVERSE_SUBTRACT_OES = 0x800B;
pub const CMYK_EXT = 0x800C;
pub const CMYKA_EXT = 0x800D;
pub const PACK_CMYK_HINT_EXT = 0x800E;
pub const UNPACK_CMYK_HINT_EXT = 0x800F;
pub const CONVOLUTION_1D = 0x8010;
pub const CONVOLUTION_1D_EXT = 0x8010;
pub const CONVOLUTION_2D = 0x8011;
pub const CONVOLUTION_2D_EXT = 0x8011;
pub const SEPARABLE_2D = 0x8012;
pub const SEPARABLE_2D_EXT = 0x8012;
pub const CONVOLUTION_BORDER_MODE = 0x8013;
pub const CONVOLUTION_BORDER_MODE_EXT = 0x8013;
pub const CONVOLUTION_FILTER_SCALE = 0x8014;
pub const CONVOLUTION_FILTER_SCALE_EXT = 0x8014;
pub const CONVOLUTION_FILTER_BIAS = 0x8015;
pub const CONVOLUTION_FILTER_BIAS_EXT = 0x8015;
pub const REDUCE = 0x8016;
pub const REDUCE_EXT = 0x8016;
pub const CONVOLUTION_FORMAT = 0x8017;
pub const CONVOLUTION_FORMAT_EXT = 0x8017;
pub const CONVOLUTION_WIDTH = 0x8018;
pub const CONVOLUTION_WIDTH_EXT = 0x8018;
pub const CONVOLUTION_HEIGHT = 0x8019;
pub const CONVOLUTION_HEIGHT_EXT = 0x8019;
pub const MAX_CONVOLUTION_WIDTH = 0x801A;
pub const MAX_CONVOLUTION_WIDTH_EXT = 0x801A;
pub const MAX_CONVOLUTION_HEIGHT = 0x801B;
pub const MAX_CONVOLUTION_HEIGHT_EXT = 0x801B;
pub const POST_CONVOLUTION_RED_SCALE = 0x801C;
pub const POST_CONVOLUTION_RED_SCALE_EXT = 0x801C;
pub const POST_CONVOLUTION_GREEN_SCALE = 0x801D;
pub const POST_CONVOLUTION_GREEN_SCALE_EXT = 0x801D;
pub const POST_CONVOLUTION_BLUE_SCALE = 0x801E;
pub const POST_CONVOLUTION_BLUE_SCALE_EXT = 0x801E;
pub const POST_CONVOLUTION_ALPHA_SCALE = 0x801F;
pub const POST_CONVOLUTION_ALPHA_SCALE_EXT = 0x801F;
pub const POST_CONVOLUTION_RED_BIAS = 0x8020;
pub const POST_CONVOLUTION_RED_BIAS_EXT = 0x8020;
pub const POST_CONVOLUTION_GREEN_BIAS = 0x8021;
pub const POST_CONVOLUTION_GREEN_BIAS_EXT = 0x8021;
pub const POST_CONVOLUTION_BLUE_BIAS = 0x8022;
pub const POST_CONVOLUTION_BLUE_BIAS_EXT = 0x8022;
pub const POST_CONVOLUTION_ALPHA_BIAS = 0x8023;
pub const POST_CONVOLUTION_ALPHA_BIAS_EXT = 0x8023;
pub const HISTOGRAM = 0x8024;
pub const HISTOGRAM_EXT = 0x8024;
pub const PROXY_HISTOGRAM = 0x8025;
pub const PROXY_HISTOGRAM_EXT = 0x8025;
pub const HISTOGRAM_WIDTH = 0x8026;
pub const HISTOGRAM_WIDTH_EXT = 0x8026;
pub const HISTOGRAM_FORMAT = 0x8027;
pub const HISTOGRAM_FORMAT_EXT = 0x8027;
pub const HISTOGRAM_RED_SIZE = 0x8028;
pub const HISTOGRAM_RED_SIZE_EXT = 0x8028;
pub const HISTOGRAM_GREEN_SIZE = 0x8029;
pub const HISTOGRAM_GREEN_SIZE_EXT = 0x8029;
pub const HISTOGRAM_BLUE_SIZE = 0x802A;
pub const HISTOGRAM_BLUE_SIZE_EXT = 0x802A;
pub const HISTOGRAM_ALPHA_SIZE = 0x802B;
pub const HISTOGRAM_ALPHA_SIZE_EXT = 0x802B;
pub const HISTOGRAM_LUMINANCE_SIZE = 0x802C;
pub const HISTOGRAM_LUMINANCE_SIZE_EXT = 0x802C;
pub const HISTOGRAM_SINK = 0x802D;
pub const HISTOGRAM_SINK_EXT = 0x802D;
pub const MINMAX = 0x802E;
pub const MINMAX_EXT = 0x802E;
pub const MINMAX_FORMAT = 0x802F;
pub const MINMAX_FORMAT_EXT = 0x802F;
pub const MINMAX_SINK = 0x8030;
pub const MINMAX_SINK_EXT = 0x8030;
pub const TABLE_TOO_LARGE_EXT = 0x8031;
pub const TABLE_TOO_LARGE = 0x8031;
pub const UNSIGNED_BYTE_3_3_2 = 0x8032;
pub const UNSIGNED_BYTE_3_3_2_EXT = 0x8032;
pub const UNSIGNED_SHORT_4_4_4_4 = 0x8033;
pub const UNSIGNED_SHORT_4_4_4_4_EXT = 0x8033;
pub const UNSIGNED_SHORT_5_5_5_1 = 0x8034;
pub const UNSIGNED_SHORT_5_5_5_1_EXT = 0x8034;
pub const UNSIGNED_INT_8_8_8_8 = 0x8035;
pub const UNSIGNED_INT_8_8_8_8_EXT = 0x8035;
pub const UNSIGNED_INT_10_10_10_2 = 0x8036;
pub const UNSIGNED_INT_10_10_10_2_EXT = 0x8036;
pub const POLYGON_OFFSET_EXT = 0x8037;
pub const POLYGON_OFFSET_FILL = 0x8037;
pub const POLYGON_OFFSET_FACTOR = 0x8038;
pub const POLYGON_OFFSET_FACTOR_EXT = 0x8038;
pub const POLYGON_OFFSET_BIAS_EXT = 0x8039;
pub const RESCALE_NORMAL = 0x803A;
pub const RESCALE_NORMAL_EXT = 0x803A;
pub const ALPHA4 = 0x803B;
pub const ALPHA4_EXT = 0x803B;
pub const ALPHA8 = 0x803C;
pub const ALPHA8_EXT = 0x803C;
pub const ALPHA8_OES = 0x803C;
pub const ALPHA12 = 0x803D;
pub const ALPHA12_EXT = 0x803D;
pub const ALPHA16 = 0x803E;
pub const ALPHA16_EXT = 0x803E;
pub const LUMINANCE4 = 0x803F;
pub const LUMINANCE4_EXT = 0x803F;
pub const LUMINANCE8 = 0x8040;
pub const LUMINANCE8_EXT = 0x8040;
pub const LUMINANCE8_OES = 0x8040;
pub const LUMINANCE12 = 0x8041;
pub const LUMINANCE12_EXT = 0x8041;
pub const LUMINANCE16 = 0x8042;
pub const LUMINANCE16_EXT = 0x8042;
pub const LUMINANCE4_ALPHA4 = 0x8043;
pub const LUMINANCE4_ALPHA4_EXT = 0x8043;
pub const LUMINANCE4_ALPHA4_OES = 0x8043;
pub const LUMINANCE6_ALPHA2 = 0x8044;
pub const LUMINANCE6_ALPHA2_EXT = 0x8044;
pub const LUMINANCE8_ALPHA8 = 0x8045;
pub const LUMINANCE8_ALPHA8_EXT = 0x8045;
pub const LUMINANCE8_ALPHA8_OES = 0x8045;
pub const LUMINANCE12_ALPHA4 = 0x8046;
pub const LUMINANCE12_ALPHA4_EXT = 0x8046;
pub const LUMINANCE12_ALPHA12 = 0x8047;
pub const LUMINANCE12_ALPHA12_EXT = 0x8047;
pub const LUMINANCE16_ALPHA16 = 0x8048;
pub const LUMINANCE16_ALPHA16_EXT = 0x8048;
pub const INTENSITY = 0x8049;
pub const INTENSITY_EXT = 0x8049;
pub const INTENSITY4 = 0x804A;
pub const INTENSITY4_EXT = 0x804A;
pub const INTENSITY8 = 0x804B;
pub const INTENSITY8_EXT = 0x804B;
pub const INTENSITY12 = 0x804C;
pub const INTENSITY12_EXT = 0x804C;
pub const INTENSITY16 = 0x804D;
pub const INTENSITY16_EXT = 0x804D;
pub const RGB2_EXT = 0x804E;
pub const RGB4 = 0x804F;
pub const RGB4_EXT = 0x804F;
pub const RGB5 = 0x8050;
pub const RGB5_EXT = 0x8050;
pub const RGB8 = 0x8051;
pub const RGB8_EXT = 0x8051;
pub const RGB8_OES = 0x8051;
pub const RGB10 = 0x8052;
pub const RGB10_EXT = 0x8052;
pub const RGB12 = 0x8053;
pub const RGB12_EXT = 0x8053;
pub const RGB16 = 0x8054;
pub const RGB16_EXT = 0x8054;
pub const RGBA2 = 0x8055;
pub const RGBA2_EXT = 0x8055;
pub const RGBA4 = 0x8056;
pub const RGBA4_EXT = 0x8056;
pub const RGBA4_OES = 0x8056;
pub const RGB5_A1 = 0x8057;
pub const RGB5_A1_EXT = 0x8057;
pub const RGB5_A1_OES = 0x8057;
pub const RGBA8 = 0x8058;
pub const RGBA8_EXT = 0x8058;
pub const RGBA8_OES = 0x8058;
pub const RGB10_A2 = 0x8059;
pub const RGB10_A2_EXT = 0x8059;
pub const RGBA12 = 0x805A;
pub const RGBA12_EXT = 0x805A;
pub const RGBA16 = 0x805B;
pub const RGBA16_EXT = 0x805B;
pub const TEXTURE_RED_SIZE = 0x805C;
pub const TEXTURE_RED_SIZE_EXT = 0x805C;
pub const TEXTURE_GREEN_SIZE = 0x805D;
pub const TEXTURE_GREEN_SIZE_EXT = 0x805D;
pub const TEXTURE_BLUE_SIZE = 0x805E;
pub const TEXTURE_BLUE_SIZE_EXT = 0x805E;
pub const TEXTURE_ALPHA_SIZE = 0x805F;
pub const TEXTURE_ALPHA_SIZE_EXT = 0x805F;
pub const TEXTURE_LUMINANCE_SIZE = 0x8060;
pub const TEXTURE_LUMINANCE_SIZE_EXT = 0x8060;
pub const TEXTURE_INTENSITY_SIZE = 0x8061;
pub const TEXTURE_INTENSITY_SIZE_EXT = 0x8061;
pub const REPLACE_EXT = 0x8062;
pub const PROXY_TEXTURE_1D = 0x8063;
pub const PROXY_TEXTURE_1D_EXT = 0x8063;
pub const PROXY_TEXTURE_2D = 0x8064;
pub const PROXY_TEXTURE_2D_EXT = 0x8064;
pub const TEXTURE_TOO_LARGE_EXT = 0x8065;
pub const TEXTURE_PRIORITY = 0x8066;
pub const TEXTURE_PRIORITY_EXT = 0x8066;
pub const TEXTURE_RESIDENT = 0x8067;
pub const TEXTURE_RESIDENT_EXT = 0x8067;
pub const TEXTURE_1D_BINDING_EXT = 0x8068;
pub const TEXTURE_BINDING_1D = 0x8068;
pub const TEXTURE_2D_BINDING_EXT = 0x8069;
pub const TEXTURE_BINDING_2D = 0x8069;
pub const TEXTURE_3D_BINDING_EXT = 0x806A;
pub const TEXTURE_3D_BINDING_OES = 0x806A;
pub const TEXTURE_BINDING_3D = 0x806A;
pub const TEXTURE_BINDING_3D_OES = 0x806A;
pub const PACK_SKIP_IMAGES = 0x806B;
pub const PACK_SKIP_IMAGES_EXT = 0x806B;
pub const PACK_IMAGE_HEIGHT = 0x806C;
pub const PACK_IMAGE_HEIGHT_EXT = 0x806C;
pub const UNPACK_SKIP_IMAGES = 0x806D;
pub const UNPACK_SKIP_IMAGES_EXT = 0x806D;
pub const UNPACK_IMAGE_HEIGHT = 0x806E;
pub const UNPACK_IMAGE_HEIGHT_EXT = 0x806E;
pub const TEXTURE_3D = 0x806F;
pub const TEXTURE_3D_EXT = 0x806F;
pub const TEXTURE_3D_OES = 0x806F;
pub const PROXY_TEXTURE_3D = 0x8070;
pub const PROXY_TEXTURE_3D_EXT = 0x8070;
pub const TEXTURE_DEPTH = 0x8071;
pub const TEXTURE_DEPTH_EXT = 0x8071;
pub const TEXTURE_WRAP_R = 0x8072;
pub const TEXTURE_WRAP_R_EXT = 0x8072;
pub const TEXTURE_WRAP_R_OES = 0x8072;
pub const MAX_3D_TEXTURE_SIZE = 0x8073;
pub const MAX_3D_TEXTURE_SIZE_EXT = 0x8073;
pub const MAX_3D_TEXTURE_SIZE_OES = 0x8073;
pub const VERTEX_ARRAY = 0x8074;
pub const VERTEX_ARRAY_EXT = 0x8074;
pub const VERTEX_ARRAY_KHR = 0x8074;
pub const NORMAL_ARRAY = 0x8075;
pub const NORMAL_ARRAY_EXT = 0x8075;
pub const COLOR_ARRAY = 0x8076;
pub const COLOR_ARRAY_EXT = 0x8076;
pub const INDEX_ARRAY = 0x8077;
pub const INDEX_ARRAY_EXT = 0x8077;
pub const TEXTURE_COORD_ARRAY = 0x8078;
pub const TEXTURE_COORD_ARRAY_EXT = 0x8078;
pub const EDGE_FLAG_ARRAY = 0x8079;
pub const EDGE_FLAG_ARRAY_EXT = 0x8079;
pub const VERTEX_ARRAY_SIZE = 0x807A;
pub const VERTEX_ARRAY_SIZE_EXT = 0x807A;
pub const VERTEX_ARRAY_TYPE = 0x807B;
pub const VERTEX_ARRAY_TYPE_EXT = 0x807B;
pub const VERTEX_ARRAY_STRIDE = 0x807C;
pub const VERTEX_ARRAY_STRIDE_EXT = 0x807C;
pub const VERTEX_ARRAY_COUNT_EXT = 0x807D;
pub const NORMAL_ARRAY_TYPE = 0x807E;
pub const NORMAL_ARRAY_TYPE_EXT = 0x807E;
pub const NORMAL_ARRAY_STRIDE = 0x807F;
pub const NORMAL_ARRAY_STRIDE_EXT = 0x807F;
pub const NORMAL_ARRAY_COUNT_EXT = 0x8080;
pub const COLOR_ARRAY_SIZE = 0x8081;
pub const COLOR_ARRAY_SIZE_EXT = 0x8081;
pub const COLOR_ARRAY_TYPE = 0x8082;
pub const COLOR_ARRAY_TYPE_EXT = 0x8082;
pub const COLOR_ARRAY_STRIDE = 0x8083;
pub const COLOR_ARRAY_STRIDE_EXT = 0x8083;
pub const COLOR_ARRAY_COUNT_EXT = 0x8084;
pub const INDEX_ARRAY_TYPE = 0x8085;
pub const INDEX_ARRAY_TYPE_EXT = 0x8085;
pub const INDEX_ARRAY_STRIDE = 0x8086;
pub const INDEX_ARRAY_STRIDE_EXT = 0x8086;
pub const INDEX_ARRAY_COUNT_EXT = 0x8087;
pub const TEXTURE_COORD_ARRAY_SIZE = 0x8088;
pub const TEXTURE_COORD_ARRAY_SIZE_EXT = 0x8088;
pub const TEXTURE_COORD_ARRAY_TYPE = 0x8089;
pub const TEXTURE_COORD_ARRAY_TYPE_EXT = 0x8089;
pub const TEXTURE_COORD_ARRAY_STRIDE = 0x808A;
pub const TEXTURE_COORD_ARRAY_STRIDE_EXT = 0x808A;
pub const TEXTURE_COORD_ARRAY_COUNT_EXT = 0x808B;
pub const EDGE_FLAG_ARRAY_STRIDE = 0x808C;
pub const EDGE_FLAG_ARRAY_STRIDE_EXT = 0x808C;
pub const EDGE_FLAG_ARRAY_COUNT_EXT = 0x808D;
pub const VERTEX_ARRAY_POINTER = 0x808E;
pub const VERTEX_ARRAY_POINTER_EXT = 0x808E;
pub const NORMAL_ARRAY_POINTER = 0x808F;
pub const NORMAL_ARRAY_POINTER_EXT = 0x808F;
pub const COLOR_ARRAY_POINTER = 0x8090;
pub const COLOR_ARRAY_POINTER_EXT = 0x8090;
pub const INDEX_ARRAY_POINTER = 0x8091;
pub const INDEX_ARRAY_POINTER_EXT = 0x8091;
pub const TEXTURE_COORD_ARRAY_POINTER = 0x8092;
pub const TEXTURE_COORD_ARRAY_POINTER_EXT = 0x8092;
pub const EDGE_FLAG_ARRAY_POINTER = 0x8093;
pub const EDGE_FLAG_ARRAY_POINTER_EXT = 0x8093;
pub const INTERLACE_SGIX = 0x8094;
pub const DETAIL_TEXTURE_2D_SGIS = 0x8095;
pub const DETAIL_TEXTURE_2D_BINDING_SGIS = 0x8096;
pub const LINEAR_DETAIL_SGIS = 0x8097;
pub const LINEAR_DETAIL_ALPHA_SGIS = 0x8098;
pub const LINEAR_DETAIL_COLOR_SGIS = 0x8099;
pub const DETAIL_TEXTURE_LEVEL_SGIS = 0x809A;
pub const DETAIL_TEXTURE_MODE_SGIS = 0x809B;
pub const DETAIL_TEXTURE_FUNC_POINTS_SGIS = 0x809C;
pub const MULTISAMPLE = 0x809D;
pub const MULTISAMPLE_ARB = 0x809D;
pub const MULTISAMPLE_EXT = 0x809D;
pub const MULTISAMPLE_SGIS = 0x809D;
pub const SAMPLE_ALPHA_TO_COVERAGE = 0x809E;
pub const SAMPLE_ALPHA_TO_COVERAGE_ARB = 0x809E;
pub const SAMPLE_ALPHA_TO_MASK_EXT = 0x809E;
pub const SAMPLE_ALPHA_TO_MASK_SGIS = 0x809E;
pub const SAMPLE_ALPHA_TO_ONE = 0x809F;
pub const SAMPLE_ALPHA_TO_ONE_ARB = 0x809F;
pub const SAMPLE_ALPHA_TO_ONE_EXT = 0x809F;
pub const SAMPLE_ALPHA_TO_ONE_SGIS = 0x809F;
pub const SAMPLE_COVERAGE = 0x80A0;
pub const SAMPLE_COVERAGE_ARB = 0x80A0;
pub const SAMPLE_MASK_EXT = 0x80A0;
pub const SAMPLE_MASK_SGIS = 0x80A0;
pub const @"1PASS_EXT" = 0x80A1;
pub const @"1PASS_SGIS" = 0x80A1;
pub const @"2PASS_0_EXT" = 0x80A2;
pub const @"2PASS_0_SGIS" = 0x80A2;
pub const @"2PASS_1_EXT" = 0x80A3;
pub const @"2PASS_1_SGIS" = 0x80A3;
pub const @"4PASS_0_EXT" = 0x80A4;
pub const @"4PASS_0_SGIS" = 0x80A4;
pub const @"4PASS_1_EXT" = 0x80A5;
pub const @"4PASS_1_SGIS" = 0x80A5;
pub const @"4PASS_2_EXT" = 0x80A6;
pub const @"4PASS_2_SGIS" = 0x80A6;
pub const @"4PASS_3_EXT" = 0x80A7;
pub const @"4PASS_3_SGIS" = 0x80A7;
pub const SAMPLE_BUFFERS = 0x80A8;
pub const SAMPLE_BUFFERS_ARB = 0x80A8;
pub const SAMPLE_BUFFERS_EXT = 0x80A8;
pub const SAMPLE_BUFFERS_SGIS = 0x80A8;
pub const SAMPLES = 0x80A9;
pub const SAMPLES_ARB = 0x80A9;
pub const SAMPLES_EXT = 0x80A9;
pub const SAMPLES_SGIS = 0x80A9;
pub const SAMPLE_COVERAGE_VALUE = 0x80AA;
pub const SAMPLE_COVERAGE_VALUE_ARB = 0x80AA;
pub const SAMPLE_MASK_VALUE_EXT = 0x80AA;
pub const SAMPLE_MASK_VALUE_SGIS = 0x80AA;
pub const SAMPLE_COVERAGE_INVERT = 0x80AB;
pub const SAMPLE_COVERAGE_INVERT_ARB = 0x80AB;
pub const SAMPLE_MASK_INVERT_EXT = 0x80AB;
pub const SAMPLE_MASK_INVERT_SGIS = 0x80AB;
pub const SAMPLE_PATTERN_EXT = 0x80AC;
pub const SAMPLE_PATTERN_SGIS = 0x80AC;
pub const LINEAR_SHARPEN_SGIS = 0x80AD;
pub const LINEAR_SHARPEN_ALPHA_SGIS = 0x80AE;
pub const LINEAR_SHARPEN_COLOR_SGIS = 0x80AF;
pub const SHARPEN_TEXTURE_FUNC_POINTS_SGIS = 0x80B0;
pub const COLOR_MATRIX = 0x80B1;
pub const COLOR_MATRIX_SGI = 0x80B1;
pub const COLOR_MATRIX_STACK_DEPTH = 0x80B2;
pub const COLOR_MATRIX_STACK_DEPTH_SGI = 0x80B2;
pub const MAX_COLOR_MATRIX_STACK_DEPTH = 0x80B3;
pub const MAX_COLOR_MATRIX_STACK_DEPTH_SGI = 0x80B3;
pub const POST_COLOR_MATRIX_RED_SCALE = 0x80B4;
pub const POST_COLOR_MATRIX_RED_SCALE_SGI = 0x80B4;
pub const POST_COLOR_MATRIX_GREEN_SCALE = 0x80B5;
pub const POST_COLOR_MATRIX_GREEN_SCALE_SGI = 0x80B5;
pub const POST_COLOR_MATRIX_BLUE_SCALE = 0x80B6;
pub const POST_COLOR_MATRIX_BLUE_SCALE_SGI = 0x80B6;
pub const POST_COLOR_MATRIX_ALPHA_SCALE = 0x80B7;
pub const POST_COLOR_MATRIX_ALPHA_SCALE_SGI = 0x80B7;
pub const POST_COLOR_MATRIX_RED_BIAS = 0x80B8;
pub const POST_COLOR_MATRIX_RED_BIAS_SGI = 0x80B8;
pub const POST_COLOR_MATRIX_GREEN_BIAS = 0x80B9;
pub const POST_COLOR_MATRIX_GREEN_BIAS_SGI = 0x80B9;
pub const POST_COLOR_MATRIX_BLUE_BIAS = 0x80BA;
pub const POST_COLOR_MATRIX_BLUE_BIAS_SGI = 0x80BA;
pub const POST_COLOR_MATRIX_ALPHA_BIAS = 0x80BB;
pub const POST_COLOR_MATRIX_ALPHA_BIAS_SGI = 0x80BB;
pub const TEXTURE_COLOR_TABLE_SGI = 0x80BC;
pub const PROXY_TEXTURE_COLOR_TABLE_SGI = 0x80BD;
pub const TEXTURE_ENV_BIAS_SGIX = 0x80BE;
pub const SHADOW_AMBIENT_SGIX = 0x80BF;
pub const TEXTURE_COMPARE_FAIL_VALUE_ARB = 0x80BF;
pub const BLEND_DST_RGB = 0x80C8;
pub const BLEND_DST_RGB_EXT = 0x80C8;
pub const BLEND_DST_RGB_OES = 0x80C8;
pub const BLEND_SRC_RGB = 0x80C9;
pub const BLEND_SRC_RGB_EXT = 0x80C9;
pub const BLEND_SRC_RGB_OES = 0x80C9;
pub const BLEND_DST_ALPHA = 0x80CA;
pub const BLEND_DST_ALPHA_EXT = 0x80CA;
pub const BLEND_DST_ALPHA_OES = 0x80CA;
pub const BLEND_SRC_ALPHA = 0x80CB;
pub const BLEND_SRC_ALPHA_EXT = 0x80CB;
pub const BLEND_SRC_ALPHA_OES = 0x80CB;
pub const @"422_EXT" = 0x80CC;
pub const @"422_REV_EXT" = 0x80CD;
pub const @"422_AVERAGE_EXT" = 0x80CE;
pub const @"422_REV_AVERAGE_EXT" = 0x80CF;
pub const COLOR_TABLE = 0x80D0;
pub const COLOR_TABLE_SGI = 0x80D0;
pub const POST_CONVOLUTION_COLOR_TABLE = 0x80D1;
pub const POST_CONVOLUTION_COLOR_TABLE_SGI = 0x80D1;
pub const POST_COLOR_MATRIX_COLOR_TABLE = 0x80D2;
pub const POST_COLOR_MATRIX_COLOR_TABLE_SGI = 0x80D2;
pub const PROXY_COLOR_TABLE = 0x80D3;
pub const PROXY_COLOR_TABLE_SGI = 0x80D3;
pub const PROXY_POST_CONVOLUTION_COLOR_TABLE = 0x80D4;
pub const PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI = 0x80D4;
pub const PROXY_POST_COLOR_MATRIX_COLOR_TABLE = 0x80D5;
pub const PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI = 0x80D5;
pub const COLOR_TABLE_SCALE = 0x80D6;
pub const COLOR_TABLE_SCALE_SGI = 0x80D6;
pub const COLOR_TABLE_BIAS = 0x80D7;
pub const COLOR_TABLE_BIAS_SGI = 0x80D7;
pub const COLOR_TABLE_FORMAT = 0x80D8;
pub const COLOR_TABLE_FORMAT_SGI = 0x80D8;
pub const COLOR_TABLE_WIDTH = 0x80D9;
pub const COLOR_TABLE_WIDTH_SGI = 0x80D9;
pub const COLOR_TABLE_RED_SIZE = 0x80DA;
pub const COLOR_TABLE_RED_SIZE_SGI = 0x80DA;
pub const COLOR_TABLE_GREEN_SIZE = 0x80DB;
pub const COLOR_TABLE_GREEN_SIZE_SGI = 0x80DB;
pub const COLOR_TABLE_BLUE_SIZE = 0x80DC;
pub const COLOR_TABLE_BLUE_SIZE_SGI = 0x80DC;
pub const COLOR_TABLE_ALPHA_SIZE = 0x80DD;
pub const COLOR_TABLE_ALPHA_SIZE_SGI = 0x80DD;
pub const COLOR_TABLE_LUMINANCE_SIZE = 0x80DE;
pub const COLOR_TABLE_LUMINANCE_SIZE_SGI = 0x80DE;
pub const COLOR_TABLE_INTENSITY_SIZE = 0x80DF;
pub const COLOR_TABLE_INTENSITY_SIZE_SGI = 0x80DF;
pub const BGR = 0x80E0;
pub const BGR_EXT = 0x80E0;
pub const BGRA = 0x80E1;
pub const BGRA_EXT = 0x80E1;
pub const BGRA_IMG = 0x80E1;
pub const COLOR_INDEX1_EXT = 0x80E2;
pub const COLOR_INDEX2_EXT = 0x80E3;
pub const COLOR_INDEX4_EXT = 0x80E4;
pub const COLOR_INDEX8_EXT = 0x80E5;
pub const COLOR_INDEX12_EXT = 0x80E6;
pub const COLOR_INDEX16_EXT = 0x80E7;
pub const MAX_ELEMENTS_VERTICES = 0x80E8;
pub const MAX_ELEMENTS_VERTICES_EXT = 0x80E8;
pub const MAX_ELEMENTS_INDICES = 0x80E9;
pub const MAX_ELEMENTS_INDICES_EXT = 0x80E9;
pub const PHONG_WIN = 0x80EA;
pub const PHONG_HINT_WIN = 0x80EB;
pub const FOG_SPECULAR_TEXTURE_WIN = 0x80EC;
pub const TEXTURE_INDEX_SIZE_EXT = 0x80ED;
pub const PARAMETER_BUFFER = 0x80EE;
pub const PARAMETER_BUFFER_ARB = 0x80EE;
pub const PARAMETER_BUFFER_BINDING = 0x80EF;
pub const PARAMETER_BUFFER_BINDING_ARB = 0x80EF;
pub const CLIP_VOLUME_CLIPPING_HINT_EXT = 0x80F0;
pub const DUAL_ALPHA4_SGIS = 0x8110;
pub const DUAL_ALPHA8_SGIS = 0x8111;
pub const DUAL_ALPHA12_SGIS = 0x8112;
pub const DUAL_ALPHA16_SGIS = 0x8113;
pub const DUAL_LUMINANCE4_SGIS = 0x8114;
pub const DUAL_LUMINANCE8_SGIS = 0x8115;
pub const DUAL_LUMINANCE12_SGIS = 0x8116;
pub const DUAL_LUMINANCE16_SGIS = 0x8117;
pub const DUAL_INTENSITY4_SGIS = 0x8118;
pub const DUAL_INTENSITY8_SGIS = 0x8119;
pub const DUAL_INTENSITY12_SGIS = 0x811A;
pub const DUAL_INTENSITY16_SGIS = 0x811B;
pub const DUAL_LUMINANCE_ALPHA4_SGIS = 0x811C;
pub const DUAL_LUMINANCE_ALPHA8_SGIS = 0x811D;
pub const QUAD_ALPHA4_SGIS = 0x811E;
pub const QUAD_ALPHA8_SGIS = 0x811F;
pub const QUAD_LUMINANCE4_SGIS = 0x8120;
pub const QUAD_LUMINANCE8_SGIS = 0x8121;
pub const QUAD_INTENSITY4_SGIS = 0x8122;
pub const QUAD_INTENSITY8_SGIS = 0x8123;
pub const DUAL_TEXTURE_SELECT_SGIS = 0x8124;
pub const QUAD_TEXTURE_SELECT_SGIS = 0x8125;
pub const POINT_SIZE_MIN = 0x8126;
pub const POINT_SIZE_MIN_ARB = 0x8126;
pub const POINT_SIZE_MIN_EXT = 0x8126;
pub const POINT_SIZE_MIN_SGIS = 0x8126;
pub const POINT_SIZE_MAX = 0x8127;
pub const POINT_SIZE_MAX_ARB = 0x8127;
pub const POINT_SIZE_MAX_EXT = 0x8127;
pub const POINT_SIZE_MAX_SGIS = 0x8127;
pub const POINT_FADE_THRESHOLD_SIZE = 0x8128;
pub const POINT_FADE_THRESHOLD_SIZE_ARB = 0x8128;
pub const POINT_FADE_THRESHOLD_SIZE_EXT = 0x8128;
pub const POINT_FADE_THRESHOLD_SIZE_SGIS = 0x8128;
pub const DISTANCE_ATTENUATION_EXT = 0x8129;
pub const DISTANCE_ATTENUATION_SGIS = 0x8129;
pub const POINT_DISTANCE_ATTENUATION = 0x8129;
pub const POINT_DISTANCE_ATTENUATION_ARB = 0x8129;
pub const FOG_FUNC_SGIS = 0x812A;
pub const FOG_FUNC_POINTS_SGIS = 0x812B;
pub const MAX_FOG_FUNC_POINTS_SGIS = 0x812C;
pub const CLAMP_TO_BORDER = 0x812D;
pub const CLAMP_TO_BORDER_ARB = 0x812D;
pub const CLAMP_TO_BORDER_EXT = 0x812D;
pub const CLAMP_TO_BORDER_NV = 0x812D;
pub const CLAMP_TO_BORDER_SGIS = 0x812D;
pub const CLAMP_TO_BORDER_OES = 0x812D;
pub const TEXTURE_MULTI_BUFFER_HINT_SGIX = 0x812E;
pub const CLAMP_TO_EDGE = 0x812F;
pub const CLAMP_TO_EDGE_SGIS = 0x812F;
pub const PACK_SKIP_VOLUMES_SGIS = 0x8130;
pub const PACK_IMAGE_DEPTH_SGIS = 0x8131;
pub const UNPACK_SKIP_VOLUMES_SGIS = 0x8132;
pub const UNPACK_IMAGE_DEPTH_SGIS = 0x8133;
pub const TEXTURE_4D_SGIS = 0x8134;
pub const PROXY_TEXTURE_4D_SGIS = 0x8135;
pub const TEXTURE_4DSIZE_SGIS = 0x8136;
pub const TEXTURE_WRAP_Q_SGIS = 0x8137;
pub const MAX_4D_TEXTURE_SIZE_SGIS = 0x8138;
pub const PIXEL_TEX_GEN_SGIX = 0x8139;
pub const TEXTURE_MIN_LOD = 0x813A;
pub const TEXTURE_MIN_LOD_SGIS = 0x813A;
pub const TEXTURE_MAX_LOD = 0x813B;
pub const TEXTURE_MAX_LOD_SGIS = 0x813B;
pub const TEXTURE_BASE_LEVEL = 0x813C;
pub const TEXTURE_BASE_LEVEL_SGIS = 0x813C;
pub const TEXTURE_MAX_LEVEL = 0x813D;
pub const TEXTURE_MAX_LEVEL_APPLE = 0x813D;
pub const TEXTURE_MAX_LEVEL_SGIS = 0x813D;
pub const PIXEL_TILE_BEST_ALIGNMENT_SGIX = 0x813E;
pub const PIXEL_TILE_CACHE_INCREMENT_SGIX = 0x813F;
pub const PIXEL_TILE_WIDTH_SGIX = 0x8140;
pub const PIXEL_TILE_HEIGHT_SGIX = 0x8141;
pub const PIXEL_TILE_GRID_WIDTH_SGIX = 0x8142;
pub const PIXEL_TILE_GRID_HEIGHT_SGIX = 0x8143;
pub const PIXEL_TILE_GRID_DEPTH_SGIX = 0x8144;
pub const PIXEL_TILE_CACHE_SIZE_SGIX = 0x8145;
pub const FILTER4_SGIS = 0x8146;
pub const TEXTURE_FILTER4_SIZE_SGIS = 0x8147;
pub const SPRITE_SGIX = 0x8148;
pub const SPRITE_MODE_SGIX = 0x8149;
pub const SPRITE_AXIS_SGIX = 0x814A;
pub const SPRITE_TRANSLATION_SGIX = 0x814B;
pub const SPRITE_AXIAL_SGIX = 0x814C;
pub const SPRITE_OBJECT_ALIGNED_SGIX = 0x814D;
pub const SPRITE_EYE_ALIGNED_SGIX = 0x814E;
pub const TEXTURE_4D_BINDING_SGIS = 0x814F;
pub const IGNORE_BORDER_HP = 0x8150;
pub const CONSTANT_BORDER = 0x8151;
pub const CONSTANT_BORDER_HP = 0x8151;
pub const REPLICATE_BORDER = 0x8153;
pub const REPLICATE_BORDER_HP = 0x8153;
pub const CONVOLUTION_BORDER_COLOR = 0x8154;
pub const CONVOLUTION_BORDER_COLOR_HP = 0x8154;
pub const IMAGE_SCALE_X_HP = 0x8155;
pub const IMAGE_SCALE_Y_HP = 0x8156;
pub const IMAGE_TRANSLATE_X_HP = 0x8157;
pub const IMAGE_TRANSLATE_Y_HP = 0x8158;
pub const IMAGE_ROTATE_ANGLE_HP = 0x8159;
pub const IMAGE_ROTATE_ORIGIN_X_HP = 0x815A;
pub const IMAGE_ROTATE_ORIGIN_Y_HP = 0x815B;
pub const IMAGE_MAG_FILTER_HP = 0x815C;
pub const IMAGE_MIN_FILTER_HP = 0x815D;
pub const IMAGE_CUBIC_WEIGHT_HP = 0x815E;
pub const CUBIC_HP = 0x815F;
pub const AVERAGE_HP = 0x8160;
pub const IMAGE_TRANSFORM_2D_HP = 0x8161;
pub const POST_IMAGE_TRANSFORM_COLOR_TABLE_HP = 0x8162;
pub const PROXY_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP = 0x8163;
pub const OCCLUSION_TEST_HP = 0x8165;
pub const OCCLUSION_TEST_RESULT_HP = 0x8166;
pub const TEXTURE_LIGHTING_MODE_HP = 0x8167;
pub const TEXTURE_POST_SPECULAR_HP = 0x8168;
pub const TEXTURE_PRE_SPECULAR_HP = 0x8169;
pub const LINEAR_CLIPMAP_LINEAR_SGIX = 0x8170;
pub const TEXTURE_CLIPMAP_CENTER_SGIX = 0x8171;
pub const TEXTURE_CLIPMAP_FRAME_SGIX = 0x8172;
pub const TEXTURE_CLIPMAP_OFFSET_SGIX = 0x8173;
pub const TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX = 0x8174;
pub const TEXTURE_CLIPMAP_LOD_OFFSET_SGIX = 0x8175;
pub const TEXTURE_CLIPMAP_DEPTH_SGIX = 0x8176;
pub const MAX_CLIPMAP_DEPTH_SGIX = 0x8177;
pub const MAX_CLIPMAP_VIRTUAL_DEPTH_SGIX = 0x8178;
pub const POST_TEXTURE_FILTER_BIAS_SGIX = 0x8179;
pub const POST_TEXTURE_FILTER_SCALE_SGIX = 0x817A;
pub const POST_TEXTURE_FILTER_BIAS_RANGE_SGIX = 0x817B;
pub const POST_TEXTURE_FILTER_SCALE_RANGE_SGIX = 0x817C;
pub const REFERENCE_PLANE_SGIX = 0x817D;
pub const REFERENCE_PLANE_EQUATION_SGIX = 0x817E;
pub const IR_INSTRUMENT1_SGIX = 0x817F;
pub const INSTRUMENT_BUFFER_POINTER_SGIX = 0x8180;
pub const INSTRUMENT_MEASUREMENTS_SGIX = 0x8181;
pub const LIST_PRIORITY_SGIX = 0x8182;
pub const CALLIGRAPHIC_FRAGMENT_SGIX = 0x8183;
pub const PIXEL_TEX_GEN_Q_CEILING_SGIX = 0x8184;
pub const PIXEL_TEX_GEN_Q_ROUND_SGIX = 0x8185;
pub const PIXEL_TEX_GEN_Q_FLOOR_SGIX = 0x8186;
pub const PIXEL_TEX_GEN_ALPHA_REPLACE_SGIX = 0x8187;
pub const PIXEL_TEX_GEN_ALPHA_NO_REPLACE_SGIX = 0x8188;
pub const PIXEL_TEX_GEN_ALPHA_LS_SGIX = 0x8189;
pub const PIXEL_TEX_GEN_ALPHA_MS_SGIX = 0x818A;
pub const FRAMEZOOM_SGIX = 0x818B;
pub const FRAMEZOOM_FACTOR_SGIX = 0x818C;
pub const MAX_FRAMEZOOM_FACTOR_SGIX = 0x818D;
pub const TEXTURE_LOD_BIAS_S_SGIX = 0x818E;
pub const TEXTURE_LOD_BIAS_T_SGIX = 0x818F;
pub const TEXTURE_LOD_BIAS_R_SGIX = 0x8190;
pub const GENERATE_MIPMAP = 0x8191;
pub const GENERATE_MIPMAP_SGIS = 0x8191;
pub const GENERATE_MIPMAP_HINT = 0x8192;
pub const GENERATE_MIPMAP_HINT_SGIS = 0x8192;
pub const GEOMETRY_DEFORMATION_SGIX = 0x8194;
pub const TEXTURE_DEFORMATION_SGIX = 0x8195;
pub const DEFORMATIONS_MASK_SGIX = 0x8196;
pub const MAX_DEFORMATION_ORDER_SGIX = 0x8197;
pub const FOG_OFFSET_SGIX = 0x8198;
pub const FOG_OFFSET_VALUE_SGIX = 0x8199;
pub const TEXTURE_COMPARE_SGIX = 0x819A;
pub const TEXTURE_COMPARE_OPERATOR_SGIX = 0x819B;
pub const TEXTURE_LEQUAL_R_SGIX = 0x819C;
pub const TEXTURE_GEQUAL_R_SGIX = 0x819D;
pub const DEPTH_COMPONENT16 = 0x81A5;
pub const DEPTH_COMPONENT16_ARB = 0x81A5;
pub const DEPTH_COMPONENT16_OES = 0x81A5;
pub const DEPTH_COMPONENT16_SGIX = 0x81A5;
pub const DEPTH_COMPONENT24 = 0x81A6;
pub const DEPTH_COMPONENT24_ARB = 0x81A6;
pub const DEPTH_COMPONENT24_OES = 0x81A6;
pub const DEPTH_COMPONENT24_SGIX = 0x81A6;
pub const DEPTH_COMPONENT32 = 0x81A7;
pub const DEPTH_COMPONENT32_ARB = 0x81A7;
pub const DEPTH_COMPONENT32_OES = 0x81A7;
pub const DEPTH_COMPONENT32_SGIX = 0x81A7;
pub const ARRAY_ELEMENT_LOCK_FIRST_EXT = 0x81A8;
pub const ARRAY_ELEMENT_LOCK_COUNT_EXT = 0x81A9;
pub const CULL_VERTEX_EXT = 0x81AA;
pub const CULL_VERTEX_EYE_POSITION_EXT = 0x81AB;
pub const CULL_VERTEX_OBJECT_POSITION_EXT = 0x81AC;
pub const IUI_V2F_EXT = 0x81AD;
pub const IUI_V3F_EXT = 0x81AE;
pub const IUI_N3F_V2F_EXT = 0x81AF;
pub const IUI_N3F_V3F_EXT = 0x81B0;
pub const T2F_IUI_V2F_EXT = 0x81B1;
pub const T2F_IUI_V3F_EXT = 0x81B2;
pub const T2F_IUI_N3F_V2F_EXT = 0x81B3;
pub const T2F_IUI_N3F_V3F_EXT = 0x81B4;
pub const INDEX_TEST_EXT = 0x81B5;
pub const INDEX_TEST_FUNC_EXT = 0x81B6;
pub const INDEX_TEST_REF_EXT = 0x81B7;
pub const INDEX_MATERIAL_EXT = 0x81B8;
pub const INDEX_MATERIAL_PARAMETER_EXT = 0x81B9;
pub const INDEX_MATERIAL_FACE_EXT = 0x81BA;
pub const YCRCB_422_SGIX = 0x81BB;
pub const YCRCB_444_SGIX = 0x81BC;
pub const WRAP_BORDER_SUN = 0x81D4;
pub const UNPACK_CONSTANT_DATA_SUNX = 0x81D5;
pub const TEXTURE_CONSTANT_DATA_SUNX = 0x81D6;
pub const TRIANGLE_LIST_SUN = 0x81D7;
pub const REPLACEMENT_CODE_SUN = 0x81D8;
pub const GLOBAL_ALPHA_SUN = 0x81D9;
pub const GLOBAL_ALPHA_FACTOR_SUN = 0x81DA;
pub const TEXTURE_COLOR_WRITEMASK_SGIS = 0x81EF;
pub const EYE_DISTANCE_TO_POINT_SGIS = 0x81F0;
pub const OBJECT_DISTANCE_TO_POINT_SGIS = 0x81F1;
pub const EYE_DISTANCE_TO_LINE_SGIS = 0x81F2;
pub const OBJECT_DISTANCE_TO_LINE_SGIS = 0x81F3;
pub const EYE_POINT_SGIS = 0x81F4;
pub const OBJECT_POINT_SGIS = 0x81F5;
pub const EYE_LINE_SGIS = 0x81F6;
pub const OBJECT_LINE_SGIS = 0x81F7;
pub const LIGHT_MODEL_COLOR_CONTROL = 0x81F8;
pub const LIGHT_MODEL_COLOR_CONTROL_EXT = 0x81F8;
pub const SINGLE_COLOR = 0x81F9;
pub const SINGLE_COLOR_EXT = 0x81F9;
pub const SEPARATE_SPECULAR_COLOR = 0x81FA;
pub const SEPARATE_SPECULAR_COLOR_EXT = 0x81FA;
pub const SHARED_TEXTURE_PALETTE_EXT = 0x81FB;
pub const TEXT_FRAGMENT_SHADER_ATI = 0x8200;
pub const FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 0x8210;
pub const FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT = 0x8210;
pub const FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 0x8211;
pub const FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT = 0x8211;
pub const FRAMEBUFFER_ATTACHMENT_RED_SIZE = 0x8212;
pub const FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 0x8213;
pub const FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 0x8214;
pub const FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 0x8215;
pub const FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 0x8216;
pub const FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 0x8217;
pub const FRAMEBUFFER_DEFAULT = 0x8218;
pub const FRAMEBUFFER_UNDEFINED = 0x8219;
pub const FRAMEBUFFER_UNDEFINED_OES = 0x8219;
pub const DEPTH_STENCIL_ATTACHMENT = 0x821A;
pub const MAJOR_VERSION = 0x821B;
pub const MINOR_VERSION = 0x821C;
pub const NUM_EXTENSIONS = 0x821D;
pub const CONTEXT_FLAGS = 0x821E;
pub const BUFFER_IMMUTABLE_STORAGE = 0x821F;
pub const BUFFER_IMMUTABLE_STORAGE_EXT = 0x821F;
pub const BUFFER_STORAGE_FLAGS = 0x8220;
pub const BUFFER_STORAGE_FLAGS_EXT = 0x8220;
pub const PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED = 0x8221;
pub const PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED_OES = 0x8221;
pub const INDEX = 0x8222;
pub const COMPRESSED_RED = 0x8225;
pub const COMPRESSED_RG = 0x8226;
pub const RG = 0x8227;
pub const RG_EXT = 0x8227;
pub const RG_INTEGER = 0x8228;
pub const R8 = 0x8229;
pub const R8_EXT = 0x8229;
pub const R16 = 0x822A;
pub const R16_EXT = 0x822A;
pub const RG8 = 0x822B;
pub const RG8_EXT = 0x822B;
pub const RG16 = 0x822C;
pub const RG16_EXT = 0x822C;
pub const R16F = 0x822D;
pub const R16F_EXT = 0x822D;
pub const R32F = 0x822E;
pub const R32F_EXT = 0x822E;
pub const RG16F = 0x822F;
pub const RG16F_EXT = 0x822F;
pub const RG32F = 0x8230;
pub const RG32F_EXT = 0x8230;
pub const R8I = 0x8231;
pub const R8UI = 0x8232;
pub const R16I = 0x8233;
pub const R16UI = 0x8234;
pub const R32I = 0x8235;
pub const R32UI = 0x8236;
pub const RG8I = 0x8237;
pub const RG8UI = 0x8238;
pub const RG16I = 0x8239;
pub const RG16UI = 0x823A;
pub const RG32I = 0x823B;
pub const RG32UI = 0x823C;
pub const SYNC_CL_EVENT_ARB = 0x8240;
pub const SYNC_CL_EVENT_COMPLETE_ARB = 0x8241;
pub const DEBUG_OUTPUT_SYNCHRONOUS = 0x8242;
pub const DEBUG_OUTPUT_SYNCHRONOUS_ARB = 0x8242;
pub const DEBUG_OUTPUT_SYNCHRONOUS_KHR = 0x8242;
pub const DEBUG_NEXT_LOGGED_MESSAGE_LENGTH = 0x8243;
pub const DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_ARB = 0x8243;
pub const DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_KHR = 0x8243;
pub const DEBUG_CALLBACK_FUNCTION = 0x8244;
pub const DEBUG_CALLBACK_FUNCTION_ARB = 0x8244;
pub const DEBUG_CALLBACK_FUNCTION_KHR = 0x8244;
pub const DEBUG_CALLBACK_USER_PARAM = 0x8245;
pub const DEBUG_CALLBACK_USER_PARAM_ARB = 0x8245;
pub const DEBUG_CALLBACK_USER_PARAM_KHR = 0x8245;
pub const DEBUG_SOURCE_API = 0x8246;
pub const DEBUG_SOURCE_API_ARB = 0x8246;
pub const DEBUG_SOURCE_API_KHR = 0x8246;
pub const DEBUG_SOURCE_WINDOW_SYSTEM = 0x8247;
pub const DEBUG_SOURCE_WINDOW_SYSTEM_ARB = 0x8247;
pub const DEBUG_SOURCE_WINDOW_SYSTEM_KHR = 0x8247;
pub const DEBUG_SOURCE_SHADER_COMPILER = 0x8248;
pub const DEBUG_SOURCE_SHADER_COMPILER_ARB = 0x8248;
pub const DEBUG_SOURCE_SHADER_COMPILER_KHR = 0x8248;
pub const DEBUG_SOURCE_THIRD_PARTY = 0x8249;
pub const DEBUG_SOURCE_THIRD_PARTY_ARB = 0x8249;
pub const DEBUG_SOURCE_THIRD_PARTY_KHR = 0x8249;
pub const DEBUG_SOURCE_APPLICATION = 0x824A;
pub const DEBUG_SOURCE_APPLICATION_ARB = 0x824A;
pub const DEBUG_SOURCE_APPLICATION_KHR = 0x824A;
pub const DEBUG_SOURCE_OTHER = 0x824B;
pub const DEBUG_SOURCE_OTHER_ARB = 0x824B;
pub const DEBUG_SOURCE_OTHER_KHR = 0x824B;
pub const DEBUG_TYPE_ERROR = 0x824C;
pub const DEBUG_TYPE_ERROR_ARB = 0x824C;
pub const DEBUG_TYPE_ERROR_KHR = 0x824C;
pub const DEBUG_TYPE_DEPRECATED_BEHAVIOR = 0x824D;
pub const DEBUG_TYPE_DEPRECATED_BEHAVIOR_ARB = 0x824D;
pub const DEBUG_TYPE_DEPRECATED_BEHAVIOR_KHR = 0x824D;
pub const DEBUG_TYPE_UNDEFINED_BEHAVIOR = 0x824E;
pub const DEBUG_TYPE_UNDEFINED_BEHAVIOR_ARB = 0x824E;
pub const DEBUG_TYPE_UNDEFINED_BEHAVIOR_KHR = 0x824E;
pub const DEBUG_TYPE_PORTABILITY = 0x824F;
pub const DEBUG_TYPE_PORTABILITY_ARB = 0x824F;
pub const DEBUG_TYPE_PORTABILITY_KHR = 0x824F;
pub const DEBUG_TYPE_PERFORMANCE = 0x8250;
pub const DEBUG_TYPE_PERFORMANCE_ARB = 0x8250;
pub const DEBUG_TYPE_PERFORMANCE_KHR = 0x8250;
pub const DEBUG_TYPE_OTHER = 0x8251;
pub const DEBUG_TYPE_OTHER_ARB = 0x8251;
pub const DEBUG_TYPE_OTHER_KHR = 0x8251;
pub const LOSE_CONTEXT_ON_RESET = 0x8252;
pub const LOSE_CONTEXT_ON_RESET_ARB = 0x8252;
pub const LOSE_CONTEXT_ON_RESET_EXT = 0x8252;
pub const LOSE_CONTEXT_ON_RESET_KHR = 0x8252;
pub const GUILTY_CONTEXT_RESET = 0x8253;
pub const GUILTY_CONTEXT_RESET_ARB = 0x8253;
pub const GUILTY_CONTEXT_RESET_EXT = 0x8253;
pub const GUILTY_CONTEXT_RESET_KHR = 0x8253;
pub const INNOCENT_CONTEXT_RESET = 0x8254;
pub const INNOCENT_CONTEXT_RESET_ARB = 0x8254;
pub const INNOCENT_CONTEXT_RESET_EXT = 0x8254;
pub const INNOCENT_CONTEXT_RESET_KHR = 0x8254;
pub const UNKNOWN_CONTEXT_RESET = 0x8255;
pub const UNKNOWN_CONTEXT_RESET_ARB = 0x8255;
pub const UNKNOWN_CONTEXT_RESET_EXT = 0x8255;
pub const UNKNOWN_CONTEXT_RESET_KHR = 0x8255;
pub const RESET_NOTIFICATION_STRATEGY = 0x8256;
pub const RESET_NOTIFICATION_STRATEGY_ARB = 0x8256;
pub const RESET_NOTIFICATION_STRATEGY_EXT = 0x8256;
pub const RESET_NOTIFICATION_STRATEGY_KHR = 0x8256;
pub const PROGRAM_BINARY_RETRIEVABLE_HINT = 0x8257;
pub const PROGRAM_SEPARABLE = 0x8258;
pub const PROGRAM_SEPARABLE_EXT = 0x8258;
pub const ACTIVE_PROGRAM = 0x8259;
// pub const ACTIVE_PROGRAM_EXT = 0x8259;
pub const PROGRAM_PIPELINE_BINDING = 0x825A;
pub const PROGRAM_PIPELINE_BINDING_EXT = 0x825A;
pub const MAX_VIEWPORTS = 0x825B;
pub const MAX_VIEWPORTS_NV = 0x825B;
pub const MAX_VIEWPORTS_OES = 0x825B;
pub const VIEWPORT_SUBPIXEL_BITS = 0x825C;
pub const VIEWPORT_SUBPIXEL_BITS_EXT = 0x825C;
pub const VIEWPORT_SUBPIXEL_BITS_NV = 0x825C;
pub const VIEWPORT_SUBPIXEL_BITS_OES = 0x825C;
pub const VIEWPORT_BOUNDS_RANGE = 0x825D;
pub const VIEWPORT_BOUNDS_RANGE_EXT = 0x825D;
pub const VIEWPORT_BOUNDS_RANGE_NV = 0x825D;
pub const VIEWPORT_BOUNDS_RANGE_OES = 0x825D;
pub const LAYER_PROVOKING_VERTEX = 0x825E;
pub const LAYER_PROVOKING_VERTEX_EXT = 0x825E;
pub const LAYER_PROVOKING_VERTEX_OES = 0x825E;
pub const VIEWPORT_INDEX_PROVOKING_VERTEX = 0x825F;
pub const VIEWPORT_INDEX_PROVOKING_VERTEX_EXT = 0x825F;
pub const VIEWPORT_INDEX_PROVOKING_VERTEX_NV = 0x825F;
pub const VIEWPORT_INDEX_PROVOKING_VERTEX_OES = 0x825F;
pub const UNDEFINED_VERTEX = 0x8260;
pub const UNDEFINED_VERTEX_EXT = 0x8260;
pub const UNDEFINED_VERTEX_OES = 0x8260;
pub const NO_RESET_NOTIFICATION = 0x8261;
pub const NO_RESET_NOTIFICATION_ARB = 0x8261;
pub const NO_RESET_NOTIFICATION_EXT = 0x8261;
pub const NO_RESET_NOTIFICATION_KHR = 0x8261;
pub const MAX_COMPUTE_SHARED_MEMORY_SIZE = 0x8262;
pub const MAX_COMPUTE_UNIFORM_COMPONENTS = 0x8263;
pub const MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS = 0x8264;
pub const MAX_COMPUTE_ATOMIC_COUNTERS = 0x8265;
pub const MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS = 0x8266;
pub const COMPUTE_WORK_GROUP_SIZE = 0x8267;
pub const DEBUG_TYPE_MARKER = 0x8268;
pub const DEBUG_TYPE_MARKER_KHR = 0x8268;
pub const DEBUG_TYPE_PUSH_GROUP = 0x8269;
pub const DEBUG_TYPE_PUSH_GROUP_KHR = 0x8269;
pub const DEBUG_TYPE_POP_GROUP = 0x826A;
pub const DEBUG_TYPE_POP_GROUP_KHR = 0x826A;
pub const DEBUG_SEVERITY_NOTIFICATION = 0x826B;
pub const DEBUG_SEVERITY_NOTIFICATION_KHR = 0x826B;
pub const MAX_DEBUG_GROUP_STACK_DEPTH = 0x826C;
pub const MAX_DEBUG_GROUP_STACK_DEPTH_KHR = 0x826C;
pub const DEBUG_GROUP_STACK_DEPTH = 0x826D;
pub const DEBUG_GROUP_STACK_DEPTH_KHR = 0x826D;
pub const MAX_UNIFORM_LOCATIONS = 0x826E;
pub const INTERNALFORMAT_SUPPORTED = 0x826F;
pub const INTERNALFORMAT_PREFERRED = 0x8270;
pub const INTERNALFORMAT_RED_SIZE = 0x8271;
pub const INTERNALFORMAT_GREEN_SIZE = 0x8272;
pub const INTERNALFORMAT_BLUE_SIZE = 0x8273;
pub const INTERNALFORMAT_ALPHA_SIZE = 0x8274;
pub const INTERNALFORMAT_DEPTH_SIZE = 0x8275;
pub const INTERNALFORMAT_STENCIL_SIZE = 0x8276;
pub const INTERNALFORMAT_SHARED_SIZE = 0x8277;
pub const INTERNALFORMAT_RED_TYPE = 0x8278;
pub const INTERNALFORMAT_GREEN_TYPE = 0x8279;
pub const INTERNALFORMAT_BLUE_TYPE = 0x827A;
pub const INTERNALFORMAT_ALPHA_TYPE = 0x827B;
pub const INTERNALFORMAT_DEPTH_TYPE = 0x827C;
pub const INTERNALFORMAT_STENCIL_TYPE = 0x827D;
pub const MAX_WIDTH = 0x827E;
pub const MAX_HEIGHT = 0x827F;
pub const MAX_DEPTH = 0x8280;
pub const MAX_LAYERS = 0x8281;
pub const MAX_COMBINED_DIMENSIONS = 0x8282;
pub const COLOR_COMPONENTS = 0x8283;
pub const DEPTH_COMPONENTS = 0x8284;
pub const STENCIL_COMPONENTS = 0x8285;
pub const COLOR_RENDERABLE = 0x8286;
pub const DEPTH_RENDERABLE = 0x8287;
pub const STENCIL_RENDERABLE = 0x8288;
pub const FRAMEBUFFER_RENDERABLE = 0x8289;
pub const FRAMEBUFFER_RENDERABLE_LAYERED = 0x828A;
pub const FRAMEBUFFER_BLEND = 0x828B;
pub const READ_PIXELS = 0x828C;
pub const READ_PIXELS_FORMAT = 0x828D;
pub const READ_PIXELS_TYPE = 0x828E;
pub const TEXTURE_IMAGE_FORMAT = 0x828F;
pub const TEXTURE_IMAGE_TYPE = 0x8290;
pub const GET_TEXTURE_IMAGE_FORMAT = 0x8291;
pub const GET_TEXTURE_IMAGE_TYPE = 0x8292;
pub const MIPMAP = 0x8293;
pub const MANUAL_GENERATE_MIPMAP = 0x8294;
pub const AUTO_GENERATE_MIPMAP = 0x8295;
pub const COLOR_ENCODING = 0x8296;
pub const SRGB_READ = 0x8297;
pub const SRGB_WRITE = 0x8298;
pub const SRGB_DECODE_ARB = 0x8299;
pub const FILTER = 0x829A;
pub const VERTEX_TEXTURE = 0x829B;
pub const TESS_CONTROL_TEXTURE = 0x829C;
pub const TESS_EVALUATION_TEXTURE = 0x829D;
pub const GEOMETRY_TEXTURE = 0x829E;
pub const FRAGMENT_TEXTURE = 0x829F;
pub const COMPUTE_TEXTURE = 0x82A0;
pub const TEXTURE_SHADOW = 0x82A1;
pub const TEXTURE_GATHER = 0x82A2;
pub const TEXTURE_GATHER_SHADOW = 0x82A3;
pub const SHADER_IMAGE_LOAD = 0x82A4;
pub const SHADER_IMAGE_STORE = 0x82A5;
pub const SHADER_IMAGE_ATOMIC = 0x82A6;
pub const IMAGE_TEXEL_SIZE = 0x82A7;
pub const IMAGE_COMPATIBILITY_CLASS = 0x82A8;
pub const IMAGE_PIXEL_FORMAT = 0x82A9;
pub const IMAGE_PIXEL_TYPE = 0x82AA;
pub const SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST = 0x82AC;
pub const SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST = 0x82AD;
pub const SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE = 0x82AE;
pub const SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE = 0x82AF;
pub const TEXTURE_COMPRESSED_BLOCK_WIDTH = 0x82B1;
pub const TEXTURE_COMPRESSED_BLOCK_HEIGHT = 0x82B2;
pub const TEXTURE_COMPRESSED_BLOCK_SIZE = 0x82B3;
pub const CLEAR_BUFFER = 0x82B4;
pub const TEXTURE_VIEW = 0x82B5;
pub const VIEW_COMPATIBILITY_CLASS = 0x82B6;
pub const FULL_SUPPORT = 0x82B7;
pub const CAVEAT_SUPPORT = 0x82B8;
pub const IMAGE_CLASS_4_X_32 = 0x82B9;
pub const IMAGE_CLASS_2_X_32 = 0x82BA;
pub const IMAGE_CLASS_1_X_32 = 0x82BB;
pub const IMAGE_CLASS_4_X_16 = 0x82BC;
pub const IMAGE_CLASS_2_X_16 = 0x82BD;
pub const IMAGE_CLASS_1_X_16 = 0x82BE;
pub const IMAGE_CLASS_4_X_8 = 0x82BF;
pub const IMAGE_CLASS_2_X_8 = 0x82C0;
pub const IMAGE_CLASS_1_X_8 = 0x82C1;
pub const IMAGE_CLASS_11_11_10 = 0x82C2;
pub const IMAGE_CLASS_10_10_10_2 = 0x82C3;
pub const VIEW_CLASS_128_BITS = 0x82C4;
pub const VIEW_CLASS_96_BITS = 0x82C5;
pub const VIEW_CLASS_64_BITS = 0x82C6;
pub const VIEW_CLASS_48_BITS = 0x82C7;
pub const VIEW_CLASS_32_BITS = 0x82C8;
pub const VIEW_CLASS_24_BITS = 0x82C9;
pub const VIEW_CLASS_16_BITS = 0x82CA;
pub const VIEW_CLASS_8_BITS = 0x82CB;
pub const VIEW_CLASS_S3TC_DXT1_RGB = 0x82CC;
pub const VIEW_CLASS_S3TC_DXT1_RGBA = 0x82CD;
pub const VIEW_CLASS_S3TC_DXT3_RGBA = 0x82CE;
pub const VIEW_CLASS_S3TC_DXT5_RGBA = 0x82CF;
pub const VIEW_CLASS_RGTC1_RED = 0x82D0;
pub const VIEW_CLASS_RGTC2_RG = 0x82D1;
pub const VIEW_CLASS_BPTC_UNORM = 0x82D2;
pub const VIEW_CLASS_BPTC_FLOAT = 0x82D3;
pub const VERTEX_ATTRIB_BINDING = 0x82D4;
pub const VERTEX_ATTRIB_RELATIVE_OFFSET = 0x82D5;
pub const VERTEX_BINDING_DIVISOR = 0x82D6;
pub const VERTEX_BINDING_OFFSET = 0x82D7;
pub const VERTEX_BINDING_STRIDE = 0x82D8;
pub const MAX_VERTEX_ATTRIB_RELATIVE_OFFSET = 0x82D9;
pub const MAX_VERTEX_ATTRIB_BINDINGS = 0x82DA;
pub const TEXTURE_VIEW_MIN_LEVEL = 0x82DB;
pub const TEXTURE_VIEW_MIN_LEVEL_EXT = 0x82DB;
pub const TEXTURE_VIEW_MIN_LEVEL_OES = 0x82DB;
pub const TEXTURE_VIEW_NUM_LEVELS = 0x82DC;
pub const TEXTURE_VIEW_NUM_LEVELS_EXT = 0x82DC;
pub const TEXTURE_VIEW_NUM_LEVELS_OES = 0x82DC;
pub const TEXTURE_VIEW_MIN_LAYER = 0x82DD;
pub const TEXTURE_VIEW_MIN_LAYER_EXT = 0x82DD;
pub const TEXTURE_VIEW_MIN_LAYER_OES = 0x82DD;
pub const TEXTURE_VIEW_NUM_LAYERS = 0x82DE;
pub const TEXTURE_VIEW_NUM_LAYERS_EXT = 0x82DE;
pub const TEXTURE_VIEW_NUM_LAYERS_OES = 0x82DE;
pub const TEXTURE_IMMUTABLE_LEVELS = 0x82DF;
pub const BUFFER = 0x82E0;
pub const BUFFER_KHR = 0x82E0;
pub const SHADER = 0x82E1;
pub const SHADER_KHR = 0x82E1;
pub const PROGRAM = 0x82E2;
pub const PROGRAM_KHR = 0x82E2;
pub const QUERY = 0x82E3;
pub const QUERY_KHR = 0x82E3;
pub const PROGRAM_PIPELINE = 0x82E4;
pub const PROGRAM_PIPELINE_KHR = 0x82E4;
pub const MAX_VERTEX_ATTRIB_STRIDE = 0x82E5;
pub const SAMPLER = 0x82E6;
pub const SAMPLER_KHR = 0x82E6;
pub const DISPLAY_LIST = 0x82E7;
pub const MAX_LABEL_LENGTH = 0x82E8;
pub const MAX_LABEL_LENGTH_KHR = 0x82E8;
pub const NUM_SHADING_LANGUAGE_VERSIONS = 0x82E9;
pub const QUERY_TARGET = 0x82EA;
pub const TRANSFORM_FEEDBACK_OVERFLOW = 0x82EC;
pub const TRANSFORM_FEEDBACK_OVERFLOW_ARB = 0x82EC;
pub const TRANSFORM_FEEDBACK_STREAM_OVERFLOW = 0x82ED;
pub const TRANSFORM_FEEDBACK_STREAM_OVERFLOW_ARB = 0x82ED;
pub const VERTICES_SUBMITTED = 0x82EE;
pub const VERTICES_SUBMITTED_ARB = 0x82EE;
pub const PRIMITIVES_SUBMITTED = 0x82EF;
pub const PRIMITIVES_SUBMITTED_ARB = 0x82EF;
pub const VERTEX_SHADER_INVOCATIONS = 0x82F0;
pub const VERTEX_SHADER_INVOCATIONS_ARB = 0x82F0;
pub const TESS_CONTROL_SHADER_PATCHES = 0x82F1;
pub const TESS_CONTROL_SHADER_PATCHES_ARB = 0x82F1;
pub const TESS_EVALUATION_SHADER_INVOCATIONS = 0x82F2;
pub const TESS_EVALUATION_SHADER_INVOCATIONS_ARB = 0x82F2;
pub const GEOMETRY_SHADER_PRIMITIVES_EMITTED = 0x82F3;
pub const GEOMETRY_SHADER_PRIMITIVES_EMITTED_ARB = 0x82F3;
pub const FRAGMENT_SHADER_INVOCATIONS = 0x82F4;
pub const FRAGMENT_SHADER_INVOCATIONS_ARB = 0x82F4;
pub const COMPUTE_SHADER_INVOCATIONS = 0x82F5;
pub const COMPUTE_SHADER_INVOCATIONS_ARB = 0x82F5;
pub const CLIPPING_INPUT_PRIMITIVES = 0x82F6;
pub const CLIPPING_INPUT_PRIMITIVES_ARB = 0x82F6;
pub const CLIPPING_OUTPUT_PRIMITIVES = 0x82F7;
pub const CLIPPING_OUTPUT_PRIMITIVES_ARB = 0x82F7;
pub const SPARSE_BUFFER_PAGE_SIZE_ARB = 0x82F8;
pub const MAX_CULL_DISTANCES = 0x82F9;
pub const MAX_CULL_DISTANCES_EXT = 0x82F9;
pub const MAX_COMBINED_CLIP_AND_CULL_DISTANCES = 0x82FA;
pub const MAX_COMBINED_CLIP_AND_CULL_DISTANCES_EXT = 0x82FA;
pub const CONTEXT_RELEASE_BEHAVIOR = 0x82FB;
pub const CONTEXT_RELEASE_BEHAVIOR_KHR = 0x82FB;
pub const CONTEXT_RELEASE_BEHAVIOR_FLUSH = 0x82FC;
pub const CONTEXT_RELEASE_BEHAVIOR_FLUSH_KHR = 0x82FC;
pub const ROBUST_GPU_TIMEOUT_MS_KHR = 0x82FD;
pub const DEPTH_PASS_INSTRUMENT_SGIX = 0x8310;
pub const DEPTH_PASS_INSTRUMENT_COUNTERS_SGIX = 0x8311;
pub const DEPTH_PASS_INSTRUMENT_MAX_SGIX = 0x8312;
pub const FRAGMENTS_INSTRUMENT_SGIX = 0x8313;
pub const FRAGMENTS_INSTRUMENT_COUNTERS_SGIX = 0x8314;
pub const FRAGMENTS_INSTRUMENT_MAX_SGIX = 0x8315;
pub const CONVOLUTION_HINT_SGIX = 0x8316;
pub const YCRCB_SGIX = 0x8318;
pub const YCRCBA_SGIX = 0x8319;
pub const UNPACK_COMPRESSED_SIZE_SGIX = 0x831A;
pub const PACK_MAX_COMPRESSED_SIZE_SGIX = 0x831B;
pub const PACK_COMPRESSED_SIZE_SGIX = 0x831C;
pub const SLIM8U_SGIX = 0x831D;
pub const SLIM10U_SGIX = 0x831E;
pub const SLIM12S_SGIX = 0x831F;
pub const ALPHA_MIN_SGIX = 0x8320;
pub const ALPHA_MAX_SGIX = 0x8321;
pub const SCALEBIAS_HINT_SGIX = 0x8322;
pub const ASYNC_MARKER_SGIX = 0x8329;
pub const PIXEL_TEX_GEN_MODE_SGIX = 0x832B;
pub const ASYNC_HISTOGRAM_SGIX = 0x832C;
pub const MAX_ASYNC_HISTOGRAM_SGIX = 0x832D;
pub const PIXEL_TRANSFORM_2D_EXT = 0x8330;
pub const PIXEL_MAG_FILTER_EXT = 0x8331;
pub const PIXEL_MIN_FILTER_EXT = 0x8332;
pub const PIXEL_CUBIC_WEIGHT_EXT = 0x8333;
pub const CUBIC_EXT = 0x8334;
pub const AVERAGE_EXT = 0x8335;
pub const PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT = 0x8336;
pub const MAX_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT = 0x8337;
pub const PIXEL_TRANSFORM_2D_MATRIX_EXT = 0x8338;
pub const FRAGMENT_MATERIAL_EXT = 0x8349;
pub const FRAGMENT_NORMAL_EXT = 0x834A;
pub const FRAGMENT_COLOR_EXT = 0x834C;
pub const ATTENUATION_EXT = 0x834D;
pub const SHADOW_ATTENUATION_EXT = 0x834E;
pub const TEXTURE_APPLICATION_MODE_EXT = 0x834F;
pub const TEXTURE_LIGHT_EXT = 0x8350;
pub const TEXTURE_MATERIAL_FACE_EXT = 0x8351;
pub const TEXTURE_MATERIAL_PARAMETER_EXT = 0x8352;
pub const PIXEL_TEXTURE_SGIS = 0x8353;
pub const PIXEL_FRAGMENT_RGB_SOURCE_SGIS = 0x8354;
pub const PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS = 0x8355;
pub const PIXEL_GROUP_COLOR_SGIS = 0x8356;
pub const LINE_QUALITY_HINT_SGIX = 0x835B;
pub const ASYNC_TEX_IMAGE_SGIX = 0x835C;
pub const ASYNC_DRAW_PIXELS_SGIX = 0x835D;
pub const ASYNC_READ_PIXELS_SGIX = 0x835E;
pub const MAX_ASYNC_TEX_IMAGE_SGIX = 0x835F;
pub const MAX_ASYNC_DRAW_PIXELS_SGIX = 0x8360;
pub const MAX_ASYNC_READ_PIXELS_SGIX = 0x8361;
pub const UNSIGNED_BYTE_2_3_3_REV = 0x8362;
pub const UNSIGNED_BYTE_2_3_3_REV_EXT = 0x8362;
pub const UNSIGNED_SHORT_5_6_5 = 0x8363;
pub const UNSIGNED_SHORT_5_6_5_EXT = 0x8363;
pub const UNSIGNED_SHORT_5_6_5_REV = 0x8364;
pub const UNSIGNED_SHORT_5_6_5_REV_EXT = 0x8364;
pub const UNSIGNED_SHORT_4_4_4_4_REV = 0x8365;
pub const UNSIGNED_SHORT_4_4_4_4_REV_EXT = 0x8365;
pub const UNSIGNED_SHORT_4_4_4_4_REV_IMG = 0x8365;
pub const UNSIGNED_SHORT_1_5_5_5_REV = 0x8366;
pub const UNSIGNED_SHORT_1_5_5_5_REV_EXT = 0x8366;
pub const UNSIGNED_INT_8_8_8_8_REV = 0x8367;
pub const UNSIGNED_INT_8_8_8_8_REV_EXT = 0x8367;
pub const UNSIGNED_INT_2_10_10_10_REV = 0x8368;
pub const UNSIGNED_INT_2_10_10_10_REV_EXT = 0x8368;
pub const TEXTURE_MAX_CLAMP_S_SGIX = 0x8369;
pub const TEXTURE_MAX_CLAMP_T_SGIX = 0x836A;
pub const TEXTURE_MAX_CLAMP_R_SGIX = 0x836B;
pub const MIRRORED_REPEAT = 0x8370;
pub const MIRRORED_REPEAT_ARB = 0x8370;
pub const MIRRORED_REPEAT_IBM = 0x8370;
pub const MIRRORED_REPEAT_OES = 0x8370;
pub const RGB_S3TC = 0x83A0;
pub const RGB4_S3TC = 0x83A1;
pub const RGBA_S3TC = 0x83A2;
pub const RGBA4_S3TC = 0x83A3;
pub const RGBA_DXT5_S3TC = 0x83A4;
pub const RGBA4_DXT5_S3TC = 0x83A5;
pub const VERTEX_PRECLIP_SGIX = 0x83EE;
pub const VERTEX_PRECLIP_HINT_SGIX = 0x83EF;
pub const COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0;
pub const COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1;
pub const COMPRESSED_RGBA_S3TC_DXT3_ANGLE = 0x83F2;
pub const COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2;
pub const COMPRESSED_RGBA_S3TC_DXT5_ANGLE = 0x83F3;
pub const COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3;
pub const PARALLEL_ARRAYS_INTEL = 0x83F4;
pub const VERTEX_ARRAY_PARALLEL_POINTERS_INTEL = 0x83F5;
pub const NORMAL_ARRAY_PARALLEL_POINTERS_INTEL = 0x83F6;
pub const COLOR_ARRAY_PARALLEL_POINTERS_INTEL = 0x83F7;
pub const TEXTURE_COORD_ARRAY_PARALLEL_POINTERS_INTEL = 0x83F8;
pub const PERFQUERY_DONOT_FLUSH_INTEL = 0x83F9;
pub const PERFQUERY_FLUSH_INTEL = 0x83FA;
pub const PERFQUERY_WAIT_INTEL = 0x83FB;
pub const BLACKHOLE_RENDER_INTEL = 0x83FC;
pub const CONSERVATIVE_RASTERIZATION_INTEL = 0x83FE;
pub const TEXTURE_MEMORY_LAYOUT_INTEL = 0x83FF;
pub const FRAGMENT_LIGHTING_SGIX = 0x8400;
pub const FRAGMENT_COLOR_MATERIAL_SGIX = 0x8401;
pub const FRAGMENT_COLOR_MATERIAL_FACE_SGIX = 0x8402;
pub const FRAGMENT_COLOR_MATERIAL_PARAMETER_SGIX = 0x8403;
pub const MAX_FRAGMENT_LIGHTS_SGIX = 0x8404;
pub const MAX_ACTIVE_LIGHTS_SGIX = 0x8405;
pub const CURRENT_RASTER_NORMAL_SGIX = 0x8406;
pub const LIGHT_ENV_MODE_SGIX = 0x8407;
pub const FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX = 0x8408;
pub const FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX = 0x8409;
pub const FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX = 0x840A;
pub const FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX = 0x840B;
pub const FRAGMENT_LIGHT0_SGIX = 0x840C;
pub const FRAGMENT_LIGHT1_SGIX = 0x840D;
pub const FRAGMENT_LIGHT2_SGIX = 0x840E;
pub const FRAGMENT_LIGHT3_SGIX = 0x840F;
pub const FRAGMENT_LIGHT4_SGIX = 0x8410;
pub const FRAGMENT_LIGHT5_SGIX = 0x8411;
pub const FRAGMENT_LIGHT6_SGIX = 0x8412;
pub const FRAGMENT_LIGHT7_SGIX = 0x8413;
pub const PACK_RESAMPLE_SGIX = 0x842E;
pub const UNPACK_RESAMPLE_SGIX = 0x842F;
pub const RESAMPLE_DECIMATE_SGIX = 0x8430;
pub const RESAMPLE_REPLICATE_SGIX = 0x8433;
pub const RESAMPLE_ZERO_FILL_SGIX = 0x8434;
pub const TANGENT_ARRAY_EXT = 0x8439;
pub const BINORMAL_ARRAY_EXT = 0x843A;
pub const CURRENT_TANGENT_EXT = 0x843B;
pub const CURRENT_BINORMAL_EXT = 0x843C;
pub const TANGENT_ARRAY_TYPE_EXT = 0x843E;
pub const TANGENT_ARRAY_STRIDE_EXT = 0x843F;
pub const BINORMAL_ARRAY_TYPE_EXT = 0x8440;
pub const BINORMAL_ARRAY_STRIDE_EXT = 0x8441;
pub const TANGENT_ARRAY_POINTER_EXT = 0x8442;
pub const BINORMAL_ARRAY_POINTER_EXT = 0x8443;
pub const MAP1_TANGENT_EXT = 0x8444;
pub const MAP2_TANGENT_EXT = 0x8445;
pub const MAP1_BINORMAL_EXT = 0x8446;
pub const MAP2_BINORMAL_EXT = 0x8447;
pub const NEAREST_CLIPMAP_NEAREST_SGIX = 0x844D;
pub const NEAREST_CLIPMAP_LINEAR_SGIX = 0x844E;
pub const LINEAR_CLIPMAP_NEAREST_SGIX = 0x844F;
pub const FOG_COORDINATE_SOURCE = 0x8450;
pub const FOG_COORDINATE_SOURCE_EXT = 0x8450;
pub const FOG_COORD_SRC = 0x8450;
pub const FOG_COORDINATE = 0x8451;
pub const FOG_COORD = 0x8451;
pub const FOG_COORDINATE_EXT = 0x8451;
pub const FRAGMENT_DEPTH = 0x8452;
pub const FRAGMENT_DEPTH_EXT = 0x8452;
pub const CURRENT_FOG_COORDINATE = 0x8453;
pub const CURRENT_FOG_COORD = 0x8453;
pub const CURRENT_FOG_COORDINATE_EXT = 0x8453;
pub const FOG_COORDINATE_ARRAY_TYPE = 0x8454;
pub const FOG_COORDINATE_ARRAY_TYPE_EXT = 0x8454;
pub const FOG_COORD_ARRAY_TYPE = 0x8454;
pub const FOG_COORDINATE_ARRAY_STRIDE = 0x8455;
pub const FOG_COORDINATE_ARRAY_STRIDE_EXT = 0x8455;
pub const FOG_COORD_ARRAY_STRIDE = 0x8455;
pub const FOG_COORDINATE_ARRAY_POINTER = 0x8456;
pub const FOG_COORDINATE_ARRAY_POINTER_EXT = 0x8456;
pub const FOG_COORD_ARRAY_POINTER = 0x8456;
pub const FOG_COORDINATE_ARRAY = 0x8457;
pub const FOG_COORDINATE_ARRAY_EXT = 0x8457;
pub const FOG_COORD_ARRAY = 0x8457;
pub const COLOR_SUM = 0x8458;
pub const COLOR_SUM_ARB = 0x8458;
pub const COLOR_SUM_EXT = 0x8458;
pub const CURRENT_SECONDARY_COLOR = 0x8459;
pub const CURRENT_SECONDARY_COLOR_EXT = 0x8459;
pub const SECONDARY_COLOR_ARRAY_SIZE = 0x845A;
pub const SECONDARY_COLOR_ARRAY_SIZE_EXT = 0x845A;
pub const SECONDARY_COLOR_ARRAY_TYPE = 0x845B;
pub const SECONDARY_COLOR_ARRAY_TYPE_EXT = 0x845B;
pub const SECONDARY_COLOR_ARRAY_STRIDE = 0x845C;
pub const SECONDARY_COLOR_ARRAY_STRIDE_EXT = 0x845C;
pub const SECONDARY_COLOR_ARRAY_POINTER = 0x845D;
pub const SECONDARY_COLOR_ARRAY_POINTER_EXT = 0x845D;
pub const SECONDARY_COLOR_ARRAY = 0x845E;
pub const SECONDARY_COLOR_ARRAY_EXT = 0x845E;
pub const CURRENT_RASTER_SECONDARY_COLOR = 0x845F;
pub const ALIASED_POINT_SIZE_RANGE = 0x846D;
pub const ALIASED_LINE_WIDTH_RANGE = 0x846E;
pub const SCREEN_COORDINATES_REND = 0x8490;
pub const INVERTED_SCREEN_W_REND = 0x8491;
pub const TEXTURE0 = 0x84C0;
pub const TEXTURE0_ARB = 0x84C0;
pub const TEXTURE1 = 0x84C1;
pub const TEXTURE1_ARB = 0x84C1;
pub const TEXTURE2 = 0x84C2;
pub const TEXTURE2_ARB = 0x84C2;
pub const TEXTURE3 = 0x84C3;
pub const TEXTURE3_ARB = 0x84C3;
pub const TEXTURE4 = 0x84C4;
pub const TEXTURE4_ARB = 0x84C4;
pub const TEXTURE5 = 0x84C5;
pub const TEXTURE5_ARB = 0x84C5;
pub const TEXTURE6 = 0x84C6;
pub const TEXTURE6_ARB = 0x84C6;
pub const TEXTURE7 = 0x84C7;
pub const TEXTURE7_ARB = 0x84C7;
pub const TEXTURE8 = 0x84C8;
pub const TEXTURE8_ARB = 0x84C8;
pub const TEXTURE9 = 0x84C9;
pub const TEXTURE9_ARB = 0x84C9;
pub const TEXTURE10 = 0x84CA;
pub const TEXTURE10_ARB = 0x84CA;
pub const TEXTURE11 = 0x84CB;
pub const TEXTURE11_ARB = 0x84CB;
pub const TEXTURE12 = 0x84CC;
pub const TEXTURE12_ARB = 0x84CC;
pub const TEXTURE13 = 0x84CD;
pub const TEXTURE13_ARB = 0x84CD;
pub const TEXTURE14 = 0x84CE;
pub const TEXTURE14_ARB = 0x84CE;
pub const TEXTURE15 = 0x84CF;
pub const TEXTURE15_ARB = 0x84CF;
pub const TEXTURE16 = 0x84D0;
pub const TEXTURE16_ARB = 0x84D0;
pub const TEXTURE17 = 0x84D1;
pub const TEXTURE17_ARB = 0x84D1;
pub const TEXTURE18 = 0x84D2;
pub const TEXTURE18_ARB = 0x84D2;
pub const TEXTURE19 = 0x84D3;
pub const TEXTURE19_ARB = 0x84D3;
pub const TEXTURE20 = 0x84D4;
pub const TEXTURE20_ARB = 0x84D4;
pub const TEXTURE21 = 0x84D5;
pub const TEXTURE21_ARB = 0x84D5;
pub const TEXTURE22 = 0x84D6;
pub const TEXTURE22_ARB = 0x84D6;
pub const TEXTURE23 = 0x84D7;
pub const TEXTURE23_ARB = 0x84D7;
pub const TEXTURE24 = 0x84D8;
pub const TEXTURE24_ARB = 0x84D8;
pub const TEXTURE25 = 0x84D9;
pub const TEXTURE25_ARB = 0x84D9;
pub const TEXTURE26 = 0x84DA;
pub const TEXTURE26_ARB = 0x84DA;
pub const TEXTURE27 = 0x84DB;
pub const TEXTURE27_ARB = 0x84DB;
pub const TEXTURE28 = 0x84DC;
pub const TEXTURE28_ARB = 0x84DC;
pub const TEXTURE29 = 0x84DD;
pub const TEXTURE29_ARB = 0x84DD;
pub const TEXTURE30 = 0x84DE;
pub const TEXTURE30_ARB = 0x84DE;
pub const TEXTURE31 = 0x84DF;
pub const TEXTURE31_ARB = 0x84DF;
pub const ACTIVE_TEXTURE = 0x84E0;
pub const ACTIVE_TEXTURE_ARB = 0x84E0;
pub const CLIENT_ACTIVE_TEXTURE = 0x84E1;
pub const CLIENT_ACTIVE_TEXTURE_ARB = 0x84E1;
pub const MAX_TEXTURE_UNITS = 0x84E2;
pub const MAX_TEXTURE_UNITS_ARB = 0x84E2;
pub const TRANSPOSE_MODELVIEW_MATRIX = 0x84E3;
pub const TRANSPOSE_MODELVIEW_MATRIX_ARB = 0x84E3;
pub const PATH_TRANSPOSE_MODELVIEW_MATRIX_NV = 0x84E3;
pub const TRANSPOSE_PROJECTION_MATRIX = 0x84E4;
pub const TRANSPOSE_PROJECTION_MATRIX_ARB = 0x84E4;
pub const PATH_TRANSPOSE_PROJECTION_MATRIX_NV = 0x84E4;
pub const TRANSPOSE_TEXTURE_MATRIX = 0x84E5;
pub const TRANSPOSE_TEXTURE_MATRIX_ARB = 0x84E5;
pub const TRANSPOSE_COLOR_MATRIX = 0x84E6;
pub const TRANSPOSE_COLOR_MATRIX_ARB = 0x84E6;
pub const SUBTRACT = 0x84E7;
pub const SUBTRACT_ARB = 0x84E7;
pub const MAX_RENDERBUFFER_SIZE = 0x84E8;
pub const MAX_RENDERBUFFER_SIZE_EXT = 0x84E8;
pub const MAX_RENDERBUFFER_SIZE_OES = 0x84E8;
pub const COMPRESSED_ALPHA = 0x84E9;
pub const COMPRESSED_ALPHA_ARB = 0x84E9;
pub const COMPRESSED_LUMINANCE = 0x84EA;
pub const COMPRESSED_LUMINANCE_ARB = 0x84EA;
pub const COMPRESSED_LUMINANCE_ALPHA = 0x84EB;
pub const COMPRESSED_LUMINANCE_ALPHA_ARB = 0x84EB;
pub const COMPRESSED_INTENSITY = 0x84EC;
pub const COMPRESSED_INTENSITY_ARB = 0x84EC;
pub const COMPRESSED_RGB = 0x84ED;
pub const COMPRESSED_RGB_ARB = 0x84ED;
pub const COMPRESSED_RGBA = 0x84EE;
pub const COMPRESSED_RGBA_ARB = 0x84EE;
pub const TEXTURE_COMPRESSION_HINT = 0x84EF;
pub const TEXTURE_COMPRESSION_HINT_ARB = 0x84EF;
pub const UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER = 0x84F0;
pub const UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER = 0x84F1;
pub const ALL_COMPLETED_NV = 0x84F2;
pub const FENCE_STATUS_NV = 0x84F3;
pub const FENCE_CONDITION_NV = 0x84F4;
pub const TEXTURE_RECTANGLE = 0x84F5;
pub const TEXTURE_RECTANGLE_ARB = 0x84F5;
pub const TEXTURE_RECTANGLE_NV = 0x84F5;
pub const TEXTURE_BINDING_RECTANGLE = 0x84F6;
pub const TEXTURE_BINDING_RECTANGLE_ARB = 0x84F6;
pub const TEXTURE_BINDING_RECTANGLE_NV = 0x84F6;
pub const PROXY_TEXTURE_RECTANGLE = 0x84F7;
pub const PROXY_TEXTURE_RECTANGLE_ARB = 0x84F7;
pub const PROXY_TEXTURE_RECTANGLE_NV = 0x84F7;
pub const MAX_RECTANGLE_TEXTURE_SIZE = 0x84F8;
pub const MAX_RECTANGLE_TEXTURE_SIZE_ARB = 0x84F8;
pub const MAX_RECTANGLE_TEXTURE_SIZE_NV = 0x84F8;
pub const DEPTH_STENCIL = 0x84F9;
pub const DEPTH_STENCIL_EXT = 0x84F9;
pub const DEPTH_STENCIL_NV = 0x84F9;
pub const DEPTH_STENCIL_OES = 0x84F9;
pub const UNSIGNED_INT_24_8 = 0x84FA;
pub const UNSIGNED_INT_24_8_EXT = 0x84FA;
pub const UNSIGNED_INT_24_8_NV = 0x84FA;
pub const UNSIGNED_INT_24_8_OES = 0x84FA;
pub const MAX_TEXTURE_LOD_BIAS = 0x84FD;
pub const MAX_TEXTURE_LOD_BIAS_EXT = 0x84FD;
pub const TEXTURE_MAX_ANISOTROPY = 0x84FE;
pub const TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE;
pub const MAX_TEXTURE_MAX_ANISOTROPY = 0x84FF;
pub const MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF;
pub const TEXTURE_FILTER_CONTROL = 0x8500;
pub const TEXTURE_FILTER_CONTROL_EXT = 0x8500;
pub const TEXTURE_LOD_BIAS = 0x8501;
pub const TEXTURE_LOD_BIAS_EXT = 0x8501;
pub const MODELVIEW1_STACK_DEPTH_EXT = 0x8502;
pub const COMBINE4_NV = 0x8503;
pub const MAX_SHININESS_NV = 0x8504;
pub const MAX_SPOT_EXPONENT_NV = 0x8505;
pub const MODELVIEW1_MATRIX_EXT = 0x8506;
pub const INCR_WRAP = 0x8507;
pub const INCR_WRAP_EXT = 0x8507;
pub const INCR_WRAP_OES = 0x8507;
pub const DECR_WRAP = 0x8508;
pub const DECR_WRAP_EXT = 0x8508;
pub const DECR_WRAP_OES = 0x8508;
pub const VERTEX_WEIGHTING_EXT = 0x8509;
pub const MODELVIEW1_ARB = 0x850A;
pub const MODELVIEW1_EXT = 0x850A;
pub const CURRENT_VERTEX_WEIGHT_EXT = 0x850B;
pub const VERTEX_WEIGHT_ARRAY_EXT = 0x850C;
pub const VERTEX_WEIGHT_ARRAY_SIZE_EXT = 0x850D;
pub const VERTEX_WEIGHT_ARRAY_TYPE_EXT = 0x850E;
pub const VERTEX_WEIGHT_ARRAY_STRIDE_EXT = 0x850F;
pub const VERTEX_WEIGHT_ARRAY_POINTER_EXT = 0x8510;
pub const NORMAL_MAP = 0x8511;
pub const NORMAL_MAP_ARB = 0x8511;
pub const NORMAL_MAP_EXT = 0x8511;
pub const NORMAL_MAP_NV = 0x8511;
pub const NORMAL_MAP_OES = 0x8511;
pub const REFLECTION_MAP = 0x8512;
pub const REFLECTION_MAP_ARB = 0x8512;
pub const REFLECTION_MAP_EXT = 0x8512;
pub const REFLECTION_MAP_NV = 0x8512;
pub const REFLECTION_MAP_OES = 0x8512;
pub const TEXTURE_CUBE_MAP = 0x8513;
pub const TEXTURE_CUBE_MAP_ARB = 0x8513;
pub const TEXTURE_CUBE_MAP_EXT = 0x8513;
pub const TEXTURE_CUBE_MAP_OES = 0x8513;
pub const TEXTURE_BINDING_CUBE_MAP = 0x8514;
pub const TEXTURE_BINDING_CUBE_MAP_ARB = 0x8514;
pub const TEXTURE_BINDING_CUBE_MAP_EXT = 0x8514;
pub const TEXTURE_BINDING_CUBE_MAP_OES = 0x8514;
pub const TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;
pub const TEXTURE_CUBE_MAP_POSITIVE_X_ARB = 0x8515;
pub const TEXTURE_CUBE_MAP_POSITIVE_X_EXT = 0x8515;
pub const TEXTURE_CUBE_MAP_POSITIVE_X_OES = 0x8515;
pub const TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;
pub const TEXTURE_CUBE_MAP_NEGATIVE_X_ARB = 0x8516;
pub const TEXTURE_CUBE_MAP_NEGATIVE_X_EXT = 0x8516;
pub const TEXTURE_CUBE_MAP_NEGATIVE_X_OES = 0x8516;
pub const TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;
pub const TEXTURE_CUBE_MAP_POSITIVE_Y_ARB = 0x8517;
pub const TEXTURE_CUBE_MAP_POSITIVE_Y_EXT = 0x8517;
pub const TEXTURE_CUBE_MAP_POSITIVE_Y_OES = 0x8517;
pub const TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;
pub const TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB = 0x8518;
pub const TEXTURE_CUBE_MAP_NEGATIVE_Y_EXT = 0x8518;
pub const TEXTURE_CUBE_MAP_NEGATIVE_Y_OES = 0x8518;
pub const TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;
pub const TEXTURE_CUBE_MAP_POSITIVE_Z_ARB = 0x8519;
pub const TEXTURE_CUBE_MAP_POSITIVE_Z_EXT = 0x8519;
pub const TEXTURE_CUBE_MAP_POSITIVE_Z_OES = 0x8519;
pub const TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A;
pub const TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB = 0x851A;
pub const TEXTURE_CUBE_MAP_NEGATIVE_Z_EXT = 0x851A;
pub const TEXTURE_CUBE_MAP_NEGATIVE_Z_OES = 0x851A;
pub const PROXY_TEXTURE_CUBE_MAP = 0x851B;
pub const PROXY_TEXTURE_CUBE_MAP_ARB = 0x851B;
pub const PROXY_TEXTURE_CUBE_MAP_EXT = 0x851B;
pub const MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;
pub const MAX_CUBE_MAP_TEXTURE_SIZE_ARB = 0x851C;
pub const MAX_CUBE_MAP_TEXTURE_SIZE_EXT = 0x851C;
pub const MAX_CUBE_MAP_TEXTURE_SIZE_OES = 0x851C;
pub const VERTEX_ARRAY_RANGE_APPLE = 0x851D;
pub const VERTEX_ARRAY_RANGE_NV = 0x851D;
pub const VERTEX_ARRAY_RANGE_LENGTH_APPLE = 0x851E;
pub const VERTEX_ARRAY_RANGE_LENGTH_NV = 0x851E;
pub const VERTEX_ARRAY_RANGE_VALID_NV = 0x851F;
pub const VERTEX_ARRAY_STORAGE_HINT_APPLE = 0x851F;
pub const MAX_VERTEX_ARRAY_RANGE_ELEMENT_NV = 0x8520;
pub const VERTEX_ARRAY_RANGE_POINTER_APPLE = 0x8521;
pub const VERTEX_ARRAY_RANGE_POINTER_NV = 0x8521;
pub const REGISTER_COMBINERS_NV = 0x8522;
pub const VARIABLE_A_NV = 0x8523;
pub const VARIABLE_B_NV = 0x8524;
pub const VARIABLE_C_NV = 0x8525;
pub const VARIABLE_D_NV = 0x8526;
pub const VARIABLE_E_NV = 0x8527;
pub const VARIABLE_F_NV = 0x8528;
pub const VARIABLE_G_NV = 0x8529;
pub const CONSTANT_COLOR0_NV = 0x852A;
pub const CONSTANT_COLOR1_NV = 0x852B;
pub const PRIMARY_COLOR_NV = 0x852C;
pub const SECONDARY_COLOR_NV = 0x852D;
pub const SPARE0_NV = 0x852E;
pub const SPARE1_NV = 0x852F;
pub const DISCARD_NV = 0x8530;
pub const E_TIMES_F_NV = 0x8531;
pub const SPARE0_PLUS_SECONDARY_COLOR_NV = 0x8532;
pub const VERTEX_ARRAY_RANGE_WITHOUT_FLUSH_NV = 0x8533;
pub const MULTISAMPLE_FILTER_HINT_NV = 0x8534;
pub const PER_STAGE_CONSTANTS_NV = 0x8535;
pub const UNSIGNED_IDENTITY_NV = 0x8536;
pub const UNSIGNED_INVERT_NV = 0x8537;
pub const EXPAND_NORMAL_NV = 0x8538;
pub const EXPAND_NEGATE_NV = 0x8539;
pub const HALF_BIAS_NORMAL_NV = 0x853A;
pub const HALF_BIAS_NEGATE_NV = 0x853B;
pub const SIGNED_IDENTITY_NV = 0x853C;
pub const SIGNED_NEGATE_NV = 0x853D;
pub const SCALE_BY_TWO_NV = 0x853E;
pub const SCALE_BY_FOUR_NV = 0x853F;
pub const SCALE_BY_ONE_HALF_NV = 0x8540;
pub const BIAS_BY_NEGATIVE_ONE_HALF_NV = 0x8541;
pub const COMBINER_INPUT_NV = 0x8542;
pub const COMBINER_MAPPING_NV = 0x8543;
pub const COMBINER_COMPONENT_USAGE_NV = 0x8544;
pub const COMBINER_AB_DOT_PRODUCT_NV = 0x8545;
pub const COMBINER_CD_DOT_PRODUCT_NV = 0x8546;
pub const COMBINER_MUX_SUM_NV = 0x8547;
pub const COMBINER_SCALE_NV = 0x8548;
pub const COMBINER_BIAS_NV = 0x8549;
pub const COMBINER_AB_OUTPUT_NV = 0x854A;
pub const COMBINER_CD_OUTPUT_NV = 0x854B;
pub const COMBINER_SUM_OUTPUT_NV = 0x854C;
pub const MAX_GENERAL_COMBINERS_NV = 0x854D;
pub const NUM_GENERAL_COMBINERS_NV = 0x854E;
pub const COLOR_SUM_CLAMP_NV = 0x854F;
pub const COMBINER0_NV = 0x8550;
pub const COMBINER1_NV = 0x8551;
pub const COMBINER2_NV = 0x8552;
pub const COMBINER3_NV = 0x8553;
pub const COMBINER4_NV = 0x8554;
pub const COMBINER5_NV = 0x8555;
pub const COMBINER6_NV = 0x8556;
pub const COMBINER7_NV = 0x8557;
pub const PRIMITIVE_RESTART_NV = 0x8558;
pub const PRIMITIVE_RESTART_INDEX_NV = 0x8559;
pub const FOG_DISTANCE_MODE_NV = 0x855A;
pub const EYE_RADIAL_NV = 0x855B;
pub const EYE_PLANE_ABSOLUTE_NV = 0x855C;
pub const EMBOSS_LIGHT_NV = 0x855D;
pub const EMBOSS_CONSTANT_NV = 0x855E;
pub const EMBOSS_MAP_NV = 0x855F;
pub const RED_MIN_CLAMP_INGR = 0x8560;
pub const GREEN_MIN_CLAMP_INGR = 0x8561;
pub const BLUE_MIN_CLAMP_INGR = 0x8562;
pub const ALPHA_MIN_CLAMP_INGR = 0x8563;
pub const RED_MAX_CLAMP_INGR = 0x8564;
pub const GREEN_MAX_CLAMP_INGR = 0x8565;
pub const BLUE_MAX_CLAMP_INGR = 0x8566;
pub const ALPHA_MAX_CLAMP_INGR = 0x8567;
pub const INTERLACE_READ_INGR = 0x8568;
pub const COMBINE = 0x8570;
pub const COMBINE_ARB = 0x8570;
pub const COMBINE_EXT = 0x8570;
pub const COMBINE_RGB = 0x8571;
pub const COMBINE_RGB_ARB = 0x8571;
pub const COMBINE_RGB_EXT = 0x8571;
pub const COMBINE_ALPHA = 0x8572;
pub const COMBINE_ALPHA_ARB = 0x8572;
pub const COMBINE_ALPHA_EXT = 0x8572;
pub const RGB_SCALE = 0x8573;
pub const RGB_SCALE_ARB = 0x8573;
pub const RGB_SCALE_EXT = 0x8573;
pub const ADD_SIGNED = 0x8574;
pub const ADD_SIGNED_ARB = 0x8574;
pub const ADD_SIGNED_EXT = 0x8574;
pub const INTERPOLATE = 0x8575;
pub const INTERPOLATE_ARB = 0x8575;
pub const INTERPOLATE_EXT = 0x8575;
pub const CONSTANT = 0x8576;
pub const CONSTANT_ARB = 0x8576;
pub const CONSTANT_EXT = 0x8576;
pub const CONSTANT_NV = 0x8576;
pub const PRIMARY_COLOR = 0x8577;
pub const PRIMARY_COLOR_ARB = 0x8577;
pub const PRIMARY_COLOR_EXT = 0x8577;
pub const PREVIOUS = 0x8578;
pub const PREVIOUS_ARB = 0x8578;
pub const PREVIOUS_EXT = 0x8578;
pub const SOURCE0_RGB = 0x8580;
pub const SOURCE0_RGB_ARB = 0x8580;
pub const SOURCE0_RGB_EXT = 0x8580;
pub const SRC0_RGB = 0x8580;
pub const SOURCE1_RGB = 0x8581;
pub const SOURCE1_RGB_ARB = 0x8581;
pub const SOURCE1_RGB_EXT = 0x8581;
pub const SRC1_RGB = 0x8581;
pub const SOURCE2_RGB = 0x8582;
pub const SOURCE2_RGB_ARB = 0x8582;
pub const SOURCE2_RGB_EXT = 0x8582;
pub const SRC2_RGB = 0x8582;
pub const SOURCE3_RGB_NV = 0x8583;
pub const SOURCE0_ALPHA = 0x8588;
pub const SOURCE0_ALPHA_ARB = 0x8588;
pub const SOURCE0_ALPHA_EXT = 0x8588;
pub const SRC0_ALPHA = 0x8588;
pub const SOURCE1_ALPHA = 0x8589;
pub const SOURCE1_ALPHA_ARB = 0x8589;
pub const SOURCE1_ALPHA_EXT = 0x8589;
pub const SRC1_ALPHA = 0x8589;
pub const SRC1_ALPHA_EXT = 0x8589;
pub const SOURCE2_ALPHA = 0x858A;
pub const SOURCE2_ALPHA_ARB = 0x858A;
pub const SOURCE2_ALPHA_EXT = 0x858A;
pub const SRC2_ALPHA = 0x858A;
pub const SOURCE3_ALPHA_NV = 0x858B;
pub const OPERAND0_RGB = 0x8590;
pub const OPERAND0_RGB_ARB = 0x8590;
pub const OPERAND0_RGB_EXT = 0x8590;
pub const OPERAND1_RGB = 0x8591;
pub const OPERAND1_RGB_ARB = 0x8591;
pub const OPERAND1_RGB_EXT = 0x8591;
pub const OPERAND2_RGB = 0x8592;
pub const OPERAND2_RGB_ARB = 0x8592;
pub const OPERAND2_RGB_EXT = 0x8592;
pub const OPERAND3_RGB_NV = 0x8593;
pub const OPERAND0_ALPHA = 0x8598;
pub const OPERAND0_ALPHA_ARB = 0x8598;
pub const OPERAND0_ALPHA_EXT = 0x8598;
pub const OPERAND1_ALPHA = 0x8599;
pub const OPERAND1_ALPHA_ARB = 0x8599;
pub const OPERAND1_ALPHA_EXT = 0x8599;
pub const OPERAND2_ALPHA = 0x859A;
pub const OPERAND2_ALPHA_ARB = 0x859A;
pub const OPERAND2_ALPHA_EXT = 0x859A;
pub const OPERAND3_ALPHA_NV = 0x859B;
pub const PACK_SUBSAMPLE_RATE_SGIX = 0x85A0;
pub const UNPACK_SUBSAMPLE_RATE_SGIX = 0x85A1;
pub const PIXEL_SUBSAMPLE_4444_SGIX = 0x85A2;
pub const PIXEL_SUBSAMPLE_2424_SGIX = 0x85A3;
pub const PIXEL_SUBSAMPLE_4242_SGIX = 0x85A4;
pub const PERTURB_EXT = 0x85AE;
pub const TEXTURE_NORMAL_EXT = 0x85AF;
pub const LIGHT_MODEL_SPECULAR_VECTOR_APPLE = 0x85B0;
pub const TRANSFORM_HINT_APPLE = 0x85B1;
pub const UNPACK_CLIENT_STORAGE_APPLE = 0x85B2;
pub const BUFFER_OBJECT_APPLE = 0x85B3;
pub const STORAGE_CLIENT_APPLE = 0x85B4;
pub const VERTEX_ARRAY_BINDING = 0x85B5;
pub const VERTEX_ARRAY_BINDING_APPLE = 0x85B5;
pub const VERTEX_ARRAY_BINDING_OES = 0x85B5;
pub const TEXTURE_RANGE_LENGTH_APPLE = 0x85B7;
pub const TEXTURE_RANGE_POINTER_APPLE = 0x85B8;
pub const YCBCR_422_APPLE = 0x85B9;
pub const UNSIGNED_SHORT_8_8_APPLE = 0x85BA;
pub const UNSIGNED_SHORT_8_8_MESA = 0x85BA;
pub const UNSIGNED_SHORT_8_8_REV_APPLE = 0x85BB;
pub const UNSIGNED_SHORT_8_8_REV_MESA = 0x85BB;
pub const TEXTURE_STORAGE_HINT_APPLE = 0x85BC;
pub const STORAGE_PRIVATE_APPLE = 0x85BD;
pub const STORAGE_CACHED_APPLE = 0x85BE;
pub const STORAGE_SHARED_APPLE = 0x85BF;
pub const REPLACEMENT_CODE_ARRAY_SUN = 0x85C0;
pub const REPLACEMENT_CODE_ARRAY_TYPE_SUN = 0x85C1;
pub const REPLACEMENT_CODE_ARRAY_STRIDE_SUN = 0x85C2;
pub const REPLACEMENT_CODE_ARRAY_POINTER_SUN = 0x85C3;
pub const R1UI_V3F_SUN = 0x85C4;
pub const R1UI_C4UB_V3F_SUN = 0x85C5;
pub const R1UI_C3F_V3F_SUN = 0x85C6;
pub const R1UI_N3F_V3F_SUN = 0x85C7;
pub const R1UI_C4F_N3F_V3F_SUN = 0x85C8;
pub const R1UI_T2F_V3F_SUN = 0x85C9;
pub const R1UI_T2F_N3F_V3F_SUN = 0x85CA;
pub const R1UI_T2F_C4F_N3F_V3F_SUN = 0x85CB;
pub const SLICE_ACCUM_SUN = 0x85CC;
pub const QUAD_MESH_SUN = 0x8614;
pub const TRIANGLE_MESH_SUN = 0x8615;
pub const VERTEX_PROGRAM_ARB = 0x8620;
pub const VERTEX_PROGRAM_NV = 0x8620;
pub const VERTEX_STATE_PROGRAM_NV = 0x8621;
pub const VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622;
pub const VERTEX_ATTRIB_ARRAY_ENABLED_ARB = 0x8622;
pub const ATTRIB_ARRAY_SIZE_NV = 0x8623;
pub const VERTEX_ATTRIB_ARRAY_SIZE = 0x8623;
pub const VERTEX_ATTRIB_ARRAY_SIZE_ARB = 0x8623;
pub const ATTRIB_ARRAY_STRIDE_NV = 0x8624;
pub const VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624;
pub const VERTEX_ATTRIB_ARRAY_STRIDE_ARB = 0x8624;
pub const ATTRIB_ARRAY_TYPE_NV = 0x8625;
pub const VERTEX_ATTRIB_ARRAY_TYPE = 0x8625;
pub const VERTEX_ATTRIB_ARRAY_TYPE_ARB = 0x8625;
pub const CURRENT_ATTRIB_NV = 0x8626;
pub const CURRENT_VERTEX_ATTRIB = 0x8626;
pub const CURRENT_VERTEX_ATTRIB_ARB = 0x8626;
pub const PROGRAM_LENGTH_ARB = 0x8627;
pub const PROGRAM_LENGTH_NV = 0x8627;
pub const PROGRAM_STRING_ARB = 0x8628;
pub const PROGRAM_STRING_NV = 0x8628;
pub const MODELVIEW_PROJECTION_NV = 0x8629;
pub const IDENTITY_NV = 0x862A;
pub const INVERSE_NV = 0x862B;
pub const TRANSPOSE_NV = 0x862C;
pub const INVERSE_TRANSPOSE_NV = 0x862D;
pub const MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB = 0x862E;
pub const MAX_TRACK_MATRIX_STACK_DEPTH_NV = 0x862E;
pub const MAX_PROGRAM_MATRICES_ARB = 0x862F;
pub const MAX_TRACK_MATRICES_NV = 0x862F;
pub const MATRIX0_NV = 0x8630;
pub const MATRIX1_NV = 0x8631;
pub const MATRIX2_NV = 0x8632;
pub const MATRIX3_NV = 0x8633;
pub const MATRIX4_NV = 0x8634;
pub const MATRIX5_NV = 0x8635;
pub const MATRIX6_NV = 0x8636;
pub const MATRIX7_NV = 0x8637;
pub const CURRENT_MATRIX_STACK_DEPTH_ARB = 0x8640;
pub const CURRENT_MATRIX_STACK_DEPTH_NV = 0x8640;
pub const CURRENT_MATRIX_ARB = 0x8641;
pub const CURRENT_MATRIX_NV = 0x8641;
pub const VERTEX_PROGRAM_POINT_SIZE = 0x8642;
pub const VERTEX_PROGRAM_POINT_SIZE_ARB = 0x8642;
pub const VERTEX_PROGRAM_POINT_SIZE_NV = 0x8642;
pub const PROGRAM_POINT_SIZE = 0x8642;
pub const PROGRAM_POINT_SIZE_ARB = 0x8642;
pub const PROGRAM_POINT_SIZE_EXT = 0x8642;
pub const VERTEX_PROGRAM_TWO_SIDE = 0x8643;
pub const VERTEX_PROGRAM_TWO_SIDE_ARB = 0x8643;
pub const VERTEX_PROGRAM_TWO_SIDE_NV = 0x8643;
pub const PROGRAM_PARAMETER_NV = 0x8644;
pub const ATTRIB_ARRAY_POINTER_NV = 0x8645;
pub const VERTEX_ATTRIB_ARRAY_POINTER = 0x8645;
pub const VERTEX_ATTRIB_ARRAY_POINTER_ARB = 0x8645;
pub const PROGRAM_TARGET_NV = 0x8646;
pub const PROGRAM_RESIDENT_NV = 0x8647;
pub const TRACK_MATRIX_NV = 0x8648;
pub const TRACK_MATRIX_TRANSFORM_NV = 0x8649;
pub const VERTEX_PROGRAM_BINDING_NV = 0x864A;
pub const PROGRAM_ERROR_POSITION_ARB = 0x864B;
pub const PROGRAM_ERROR_POSITION_NV = 0x864B;
pub const OFFSET_TEXTURE_RECTANGLE_NV = 0x864C;
pub const OFFSET_TEXTURE_RECTANGLE_SCALE_NV = 0x864D;
pub const DOT_PRODUCT_TEXTURE_RECTANGLE_NV = 0x864E;
pub const DEPTH_CLAMP = 0x864F;
pub const DEPTH_CLAMP_NV = 0x864F;
pub const DEPTH_CLAMP_EXT = 0x864F;
pub const VERTEX_ATTRIB_ARRAY0_NV = 0x8650;
pub const VERTEX_ATTRIB_ARRAY1_NV = 0x8651;
pub const VERTEX_ATTRIB_ARRAY2_NV = 0x8652;
pub const VERTEX_ATTRIB_ARRAY3_NV = 0x8653;
pub const VERTEX_ATTRIB_ARRAY4_NV = 0x8654;
pub const VERTEX_ATTRIB_ARRAY5_NV = 0x8655;
pub const VERTEX_ATTRIB_ARRAY6_NV = 0x8656;
pub const VERTEX_ATTRIB_ARRAY7_NV = 0x8657;
pub const VERTEX_ATTRIB_ARRAY8_NV = 0x8658;
pub const VERTEX_ATTRIB_ARRAY9_NV = 0x8659;
pub const VERTEX_ATTRIB_ARRAY10_NV = 0x865A;
pub const VERTEX_ATTRIB_ARRAY11_NV = 0x865B;
pub const VERTEX_ATTRIB_ARRAY12_NV = 0x865C;
pub const VERTEX_ATTRIB_ARRAY13_NV = 0x865D;
pub const VERTEX_ATTRIB_ARRAY14_NV = 0x865E;
pub const VERTEX_ATTRIB_ARRAY15_NV = 0x865F;
pub const MAP1_VERTEX_ATTRIB0_4_NV = 0x8660;
pub const MAP1_VERTEX_ATTRIB1_4_NV = 0x8661;
pub const MAP1_VERTEX_ATTRIB2_4_NV = 0x8662;
pub const MAP1_VERTEX_ATTRIB3_4_NV = 0x8663;
pub const MAP1_VERTEX_ATTRIB4_4_NV = 0x8664;
pub const MAP1_VERTEX_ATTRIB5_4_NV = 0x8665;
pub const MAP1_VERTEX_ATTRIB6_4_NV = 0x8666;
pub const MAP1_VERTEX_ATTRIB7_4_NV = 0x8667;
pub const MAP1_VERTEX_ATTRIB8_4_NV = 0x8668;
pub const MAP1_VERTEX_ATTRIB9_4_NV = 0x8669;
pub const MAP1_VERTEX_ATTRIB10_4_NV = 0x866A;
pub const MAP1_VERTEX_ATTRIB11_4_NV = 0x866B;
pub const MAP1_VERTEX_ATTRIB12_4_NV = 0x866C;
pub const MAP1_VERTEX_ATTRIB13_4_NV = 0x866D;
pub const MAP1_VERTEX_ATTRIB14_4_NV = 0x866E;
pub const MAP1_VERTEX_ATTRIB15_4_NV = 0x866F;
pub const MAP2_VERTEX_ATTRIB0_4_NV = 0x8670;
pub const MAP2_VERTEX_ATTRIB1_4_NV = 0x8671;
pub const MAP2_VERTEX_ATTRIB2_4_NV = 0x8672;
pub const MAP2_VERTEX_ATTRIB3_4_NV = 0x8673;
pub const MAP2_VERTEX_ATTRIB4_4_NV = 0x8674;
pub const MAP2_VERTEX_ATTRIB5_4_NV = 0x8675;
pub const MAP2_VERTEX_ATTRIB6_4_NV = 0x8676;
pub const MAP2_VERTEX_ATTRIB7_4_NV = 0x8677;
pub const PROGRAM_BINDING_ARB = 0x8677;
pub const MAP2_VERTEX_ATTRIB8_4_NV = 0x8678;
pub const MAP2_VERTEX_ATTRIB9_4_NV = 0x8679;
pub const MAP2_VERTEX_ATTRIB10_4_NV = 0x867A;
pub const MAP2_VERTEX_ATTRIB11_4_NV = 0x867B;
pub const MAP2_VERTEX_ATTRIB12_4_NV = 0x867C;
pub const MAP2_VERTEX_ATTRIB13_4_NV = 0x867D;
pub const MAP2_VERTEX_ATTRIB14_4_NV = 0x867E;
pub const MAP2_VERTEX_ATTRIB15_4_NV = 0x867F;
pub const TEXTURE_COMPRESSED_IMAGE_SIZE = 0x86A0;
pub const TEXTURE_COMPRESSED_IMAGE_SIZE_ARB = 0x86A0;
pub const TEXTURE_COMPRESSED = 0x86A1;
pub const TEXTURE_COMPRESSED_ARB = 0x86A1;
pub const NUM_COMPRESSED_TEXTURE_FORMATS = 0x86A2;
pub const NUM_COMPRESSED_TEXTURE_FORMATS_ARB = 0x86A2;
pub const COMPRESSED_TEXTURE_FORMATS = 0x86A3;
pub const COMPRESSED_TEXTURE_FORMATS_ARB = 0x86A3;
pub const MAX_VERTEX_UNITS_ARB = 0x86A4;
pub const MAX_VERTEX_UNITS_OES = 0x86A4;
pub const ACTIVE_VERTEX_UNITS_ARB = 0x86A5;
pub const WEIGHT_SUM_UNITY_ARB = 0x86A6;
pub const VERTEX_BLEND_ARB = 0x86A7;
pub const CURRENT_WEIGHT_ARB = 0x86A8;
pub const WEIGHT_ARRAY_TYPE_ARB = 0x86A9;
pub const WEIGHT_ARRAY_TYPE_OES = 0x86A9;
pub const WEIGHT_ARRAY_STRIDE_ARB = 0x86AA;
pub const WEIGHT_ARRAY_STRIDE_OES = 0x86AA;
pub const WEIGHT_ARRAY_SIZE_ARB = 0x86AB;
pub const WEIGHT_ARRAY_SIZE_OES = 0x86AB;
pub const WEIGHT_ARRAY_POINTER_ARB = 0x86AC;
pub const WEIGHT_ARRAY_POINTER_OES = 0x86AC;
pub const WEIGHT_ARRAY_ARB = 0x86AD;
pub const WEIGHT_ARRAY_OES = 0x86AD;
pub const DOT3_RGB = 0x86AE;
pub const DOT3_RGB_ARB = 0x86AE;
pub const DOT3_RGBA = 0x86AF;
pub const DOT3_RGBA_ARB = 0x86AF;
pub const DOT3_RGBA_IMG = 0x86AF;
pub const COMPRESSED_RGB_FXT1_3DFX = 0x86B0;
pub const COMPRESSED_RGBA_FXT1_3DFX = 0x86B1;
pub const MULTISAMPLE_3DFX = 0x86B2;
pub const SAMPLE_BUFFERS_3DFX = 0x86B3;
pub const SAMPLES_3DFX = 0x86B4;
pub const EVAL_2D_NV = 0x86C0;
pub const EVAL_TRIANGULAR_2D_NV = 0x86C1;
pub const MAP_TESSELLATION_NV = 0x86C2;
pub const MAP_ATTRIB_U_ORDER_NV = 0x86C3;
pub const MAP_ATTRIB_V_ORDER_NV = 0x86C4;
pub const EVAL_FRACTIONAL_TESSELLATION_NV = 0x86C5;
pub const EVAL_VERTEX_ATTRIB0_NV = 0x86C6;
pub const EVAL_VERTEX_ATTRIB1_NV = 0x86C7;
pub const EVAL_VERTEX_ATTRIB2_NV = 0x86C8;
pub const EVAL_VERTEX_ATTRIB3_NV = 0x86C9;
pub const EVAL_VERTEX_ATTRIB4_NV = 0x86CA;
pub const EVAL_VERTEX_ATTRIB5_NV = 0x86CB;
pub const EVAL_VERTEX_ATTRIB6_NV = 0x86CC;
pub const EVAL_VERTEX_ATTRIB7_NV = 0x86CD;
pub const EVAL_VERTEX_ATTRIB8_NV = 0x86CE;
pub const EVAL_VERTEX_ATTRIB9_NV = 0x86CF;
pub const EVAL_VERTEX_ATTRIB10_NV = 0x86D0;
pub const EVAL_VERTEX_ATTRIB11_NV = 0x86D1;
pub const EVAL_VERTEX_ATTRIB12_NV = 0x86D2;
pub const EVAL_VERTEX_ATTRIB13_NV = 0x86D3;
pub const EVAL_VERTEX_ATTRIB14_NV = 0x86D4;
pub const EVAL_VERTEX_ATTRIB15_NV = 0x86D5;
pub const MAX_MAP_TESSELLATION_NV = 0x86D6;
pub const MAX_RATIONAL_EVAL_ORDER_NV = 0x86D7;
pub const MAX_PROGRAM_PATCH_ATTRIBS_NV = 0x86D8;
pub const RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV = 0x86D9;
pub const UNSIGNED_INT_S8_S8_8_8_NV = 0x86DA;
pub const UNSIGNED_INT_8_8_S8_S8_REV_NV = 0x86DB;
pub const DSDT_MAG_INTENSITY_NV = 0x86DC;
pub const SHADER_CONSISTENT_NV = 0x86DD;
pub const TEXTURE_SHADER_NV = 0x86DE;
pub const SHADER_OPERATION_NV = 0x86DF;
pub const CULL_MODES_NV = 0x86E0;
pub const OFFSET_TEXTURE_MATRIX_NV = 0x86E1;
pub const OFFSET_TEXTURE_2D_MATRIX_NV = 0x86E1;
pub const OFFSET_TEXTURE_SCALE_NV = 0x86E2;
pub const OFFSET_TEXTURE_2D_SCALE_NV = 0x86E2;
pub const OFFSET_TEXTURE_BIAS_NV = 0x86E3;
pub const OFFSET_TEXTURE_2D_BIAS_NV = 0x86E3;
pub const PREVIOUS_TEXTURE_INPUT_NV = 0x86E4;
pub const CONST_EYE_NV = 0x86E5;
pub const PASS_THROUGH_NV = 0x86E6;
pub const CULL_FRAGMENT_NV = 0x86E7;
pub const OFFSET_TEXTURE_2D_NV = 0x86E8;
pub const DEPENDENT_AR_TEXTURE_2D_NV = 0x86E9;
pub const DEPENDENT_GB_TEXTURE_2D_NV = 0x86EA;
pub const SURFACE_STATE_NV = 0x86EB;
pub const DOT_PRODUCT_NV = 0x86EC;
pub const DOT_PRODUCT_DEPTH_REPLACE_NV = 0x86ED;
pub const DOT_PRODUCT_TEXTURE_2D_NV = 0x86EE;
pub const DOT_PRODUCT_TEXTURE_3D_NV = 0x86EF;
pub const DOT_PRODUCT_TEXTURE_CUBE_MAP_NV = 0x86F0;
pub const DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV = 0x86F1;
pub const DOT_PRODUCT_REFLECT_CUBE_MAP_NV = 0x86F2;
pub const DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV = 0x86F3;
pub const HILO_NV = 0x86F4;
pub const DSDT_NV = 0x86F5;
pub const DSDT_MAG_NV = 0x86F6;
pub const DSDT_MAG_VIB_NV = 0x86F7;
pub const HILO16_NV = 0x86F8;
pub const SIGNED_HILO_NV = 0x86F9;
pub const SIGNED_HILO16_NV = 0x86FA;
pub const SIGNED_RGBA_NV = 0x86FB;
pub const SIGNED_RGBA8_NV = 0x86FC;
pub const SURFACE_REGISTERED_NV = 0x86FD;
pub const SIGNED_RGB_NV = 0x86FE;
pub const SIGNED_RGB8_NV = 0x86FF;
pub const SURFACE_MAPPED_NV = 0x8700;
pub const SIGNED_LUMINANCE_NV = 0x8701;
pub const SIGNED_LUMINANCE8_NV = 0x8702;
pub const SIGNED_LUMINANCE_ALPHA_NV = 0x8703;
pub const SIGNED_LUMINANCE8_ALPHA8_NV = 0x8704;
pub const SIGNED_ALPHA_NV = 0x8705;
pub const SIGNED_ALPHA8_NV = 0x8706;
pub const SIGNED_INTENSITY_NV = 0x8707;
pub const SIGNED_INTENSITY8_NV = 0x8708;
pub const DSDT8_NV = 0x8709;
pub const DSDT8_MAG8_NV = 0x870A;
pub const DSDT8_MAG8_INTENSITY8_NV = 0x870B;
pub const SIGNED_RGB_UNSIGNED_ALPHA_NV = 0x870C;
pub const SIGNED_RGB8_UNSIGNED_ALPHA8_NV = 0x870D;
pub const HI_SCALE_NV = 0x870E;
pub const LO_SCALE_NV = 0x870F;
pub const DS_SCALE_NV = 0x8710;
pub const DT_SCALE_NV = 0x8711;
pub const MAGNITUDE_SCALE_NV = 0x8712;
pub const VIBRANCE_SCALE_NV = 0x8713;
pub const HI_BIAS_NV = 0x8714;
pub const LO_BIAS_NV = 0x8715;
pub const DS_BIAS_NV = 0x8716;
pub const DT_BIAS_NV = 0x8717;
pub const MAGNITUDE_BIAS_NV = 0x8718;
pub const VIBRANCE_BIAS_NV = 0x8719;
pub const TEXTURE_BORDER_VALUES_NV = 0x871A;
pub const TEXTURE_HI_SIZE_NV = 0x871B;
pub const TEXTURE_LO_SIZE_NV = 0x871C;
pub const TEXTURE_DS_SIZE_NV = 0x871D;
pub const TEXTURE_DT_SIZE_NV = 0x871E;
pub const TEXTURE_MAG_SIZE_NV = 0x871F;
pub const MODELVIEW2_ARB = 0x8722;
pub const MODELVIEW3_ARB = 0x8723;
pub const MODELVIEW4_ARB = 0x8724;
pub const MODELVIEW5_ARB = 0x8725;
pub const MODELVIEW6_ARB = 0x8726;
pub const MODELVIEW7_ARB = 0x8727;
pub const MODELVIEW8_ARB = 0x8728;
pub const MODELVIEW9_ARB = 0x8729;
pub const MODELVIEW10_ARB = 0x872A;
pub const MODELVIEW11_ARB = 0x872B;
pub const MODELVIEW12_ARB = 0x872C;
pub const MODELVIEW13_ARB = 0x872D;
pub const MODELVIEW14_ARB = 0x872E;
pub const MODELVIEW15_ARB = 0x872F;
pub const MODELVIEW16_ARB = 0x8730;
pub const MODELVIEW17_ARB = 0x8731;
pub const MODELVIEW18_ARB = 0x8732;
pub const MODELVIEW19_ARB = 0x8733;
pub const MODELVIEW20_ARB = 0x8734;
pub const MODELVIEW21_ARB = 0x8735;
pub const MODELVIEW22_ARB = 0x8736;
pub const MODELVIEW23_ARB = 0x8737;
pub const MODELVIEW24_ARB = 0x8738;
pub const MODELVIEW25_ARB = 0x8739;
pub const MODELVIEW26_ARB = 0x873A;
pub const MODELVIEW27_ARB = 0x873B;
pub const MODELVIEW28_ARB = 0x873C;
pub const MODELVIEW29_ARB = 0x873D;
pub const MODELVIEW30_ARB = 0x873E;
pub const MODELVIEW31_ARB = 0x873F;
pub const DOT3_RGB_EXT = 0x8740;
pub const Z400_BINARY_AMD = 0x8740;
pub const DOT3_RGBA_EXT = 0x8741;
pub const PROGRAM_BINARY_LENGTH_OES = 0x8741;
pub const PROGRAM_BINARY_LENGTH = 0x8741;
pub const MIRROR_CLAMP_ATI = 0x8742;
pub const MIRROR_CLAMP_EXT = 0x8742;
pub const MIRROR_CLAMP_TO_EDGE = 0x8743;
pub const MIRROR_CLAMP_TO_EDGE_ATI = 0x8743;
pub const MIRROR_CLAMP_TO_EDGE_EXT = 0x8743;
pub const MODULATE_ADD_ATI = 0x8744;
pub const MODULATE_SIGNED_ADD_ATI = 0x8745;
pub const MODULATE_SUBTRACT_ATI = 0x8746;
pub const SET_AMD = 0x874A;
pub const REPLACE_VALUE_AMD = 0x874B;
pub const STENCIL_OP_VALUE_AMD = 0x874C;
pub const STENCIL_BACK_OP_VALUE_AMD = 0x874D;
pub const VERTEX_ATTRIB_ARRAY_LONG = 0x874E;
pub const OCCLUSION_QUERY_EVENT_MASK_AMD = 0x874F;
pub const DEPTH_STENCIL_MESA = 0x8750;
pub const UNSIGNED_INT_24_8_MESA = 0x8751;
pub const UNSIGNED_INT_8_24_REV_MESA = 0x8752;
pub const UNSIGNED_SHORT_15_1_MESA = 0x8753;
pub const UNSIGNED_SHORT_1_15_REV_MESA = 0x8754;
pub const TRACE_MASK_MESA = 0x8755;
pub const TRACE_NAME_MESA = 0x8756;
pub const YCBCR_MESA = 0x8757;
pub const PACK_INVERT_MESA = 0x8758;
pub const DEBUG_OBJECT_MESA = 0x8759;
pub const TEXTURE_1D_STACK_MESAX = 0x8759;
pub const DEBUG_PRINT_MESA = 0x875A;
pub const TEXTURE_2D_STACK_MESAX = 0x875A;
pub const DEBUG_ASSERT_MESA = 0x875B;
pub const PROXY_TEXTURE_1D_STACK_MESAX = 0x875B;
pub const PROXY_TEXTURE_2D_STACK_MESAX = 0x875C;
pub const TEXTURE_1D_STACK_BINDING_MESAX = 0x875D;
pub const TEXTURE_2D_STACK_BINDING_MESAX = 0x875E;
pub const PROGRAM_BINARY_FORMAT_MESA = 0x875F;
pub const STATIC_ATI = 0x8760;
pub const DYNAMIC_ATI = 0x8761;
pub const PRESERVE_ATI = 0x8762;
pub const DISCARD_ATI = 0x8763;
pub const BUFFER_SIZE = 0x8764;
pub const BUFFER_SIZE_ARB = 0x8764;
pub const OBJECT_BUFFER_SIZE_ATI = 0x8764;
pub const BUFFER_USAGE = 0x8765;
pub const BUFFER_USAGE_ARB = 0x8765;
pub const OBJECT_BUFFER_USAGE_ATI = 0x8765;
pub const ARRAY_OBJECT_BUFFER_ATI = 0x8766;
pub const ARRAY_OBJECT_OFFSET_ATI = 0x8767;
pub const ELEMENT_ARRAY_ATI = 0x8768;
pub const ELEMENT_ARRAY_TYPE_ATI = 0x8769;
pub const ELEMENT_ARRAY_POINTER_ATI = 0x876A;
pub const MAX_VERTEX_STREAMS_ATI = 0x876B;
pub const VERTEX_STREAM0_ATI = 0x876C;
pub const VERTEX_STREAM1_ATI = 0x876D;
pub const VERTEX_STREAM2_ATI = 0x876E;
pub const VERTEX_STREAM3_ATI = 0x876F;
pub const VERTEX_STREAM4_ATI = 0x8770;
pub const VERTEX_STREAM5_ATI = 0x8771;
pub const VERTEX_STREAM6_ATI = 0x8772;
pub const VERTEX_STREAM7_ATI = 0x8773;
pub const VERTEX_SOURCE_ATI = 0x8774;
pub const BUMP_ROT_MATRIX_ATI = 0x8775;
pub const BUMP_ROT_MATRIX_SIZE_ATI = 0x8776;
pub const BUMP_NUM_TEX_UNITS_ATI = 0x8777;
pub const BUMP_TEX_UNITS_ATI = 0x8778;
pub const DUDV_ATI = 0x8779;
pub const DU8DV8_ATI = 0x877A;
pub const BUMP_ENVMAP_ATI = 0x877B;
pub const BUMP_TARGET_ATI = 0x877C;
pub const VERTEX_SHADER_EXT = 0x8780;
pub const VERTEX_SHADER_BINDING_EXT = 0x8781;
pub const OP_INDEX_EXT = 0x8782;
pub const OP_NEGATE_EXT = 0x8783;
pub const OP_DOT3_EXT = 0x8784;
pub const OP_DOT4_EXT = 0x8785;
pub const OP_MUL_EXT = 0x8786;
pub const OP_ADD_EXT = 0x8787;
pub const OP_MADD_EXT = 0x8788;
pub const OP_FRAC_EXT = 0x8789;
pub const OP_MAX_EXT = 0x878A;
pub const OP_MIN_EXT = 0x878B;
pub const OP_SET_GE_EXT = 0x878C;
pub const OP_SET_LT_EXT = 0x878D;
pub const OP_CLAMP_EXT = 0x878E;
pub const OP_FLOOR_EXT = 0x878F;
pub const OP_ROUND_EXT = 0x8790;
pub const OP_EXP_BASE_2_EXT = 0x8791;
pub const OP_LOG_BASE_2_EXT = 0x8792;
pub const OP_POWER_EXT = 0x8793;
pub const OP_RECIP_EXT = 0x8794;
pub const OP_RECIP_SQRT_EXT = 0x8795;
pub const OP_SUB_EXT = 0x8796;
pub const OP_CROSS_PRODUCT_EXT = 0x8797;
pub const OP_MULTIPLY_MATRIX_EXT = 0x8798;
pub const OP_MOV_EXT = 0x8799;
pub const OUTPUT_VERTEX_EXT = 0x879A;
pub const OUTPUT_COLOR0_EXT = 0x879B;
pub const OUTPUT_COLOR1_EXT = 0x879C;
pub const OUTPUT_TEXTURE_COORD0_EXT = 0x879D;
pub const OUTPUT_TEXTURE_COORD1_EXT = 0x879E;
pub const OUTPUT_TEXTURE_COORD2_EXT = 0x879F;
pub const OUTPUT_TEXTURE_COORD3_EXT = 0x87A0;
pub const OUTPUT_TEXTURE_COORD4_EXT = 0x87A1;
pub const OUTPUT_TEXTURE_COORD5_EXT = 0x87A2;
pub const OUTPUT_TEXTURE_COORD6_EXT = 0x87A3;
pub const OUTPUT_TEXTURE_COORD7_EXT = 0x87A4;
pub const OUTPUT_TEXTURE_COORD8_EXT = 0x87A5;
pub const OUTPUT_TEXTURE_COORD9_EXT = 0x87A6;
pub const OUTPUT_TEXTURE_COORD10_EXT = 0x87A7;
pub const OUTPUT_TEXTURE_COORD11_EXT = 0x87A8;
pub const OUTPUT_TEXTURE_COORD12_EXT = 0x87A9;
pub const OUTPUT_TEXTURE_COORD13_EXT = 0x87AA;
pub const OUTPUT_TEXTURE_COORD14_EXT = 0x87AB;
pub const OUTPUT_TEXTURE_COORD15_EXT = 0x87AC;
pub const OUTPUT_TEXTURE_COORD16_EXT = 0x87AD;
pub const OUTPUT_TEXTURE_COORD17_EXT = 0x87AE;
pub const OUTPUT_TEXTURE_COORD18_EXT = 0x87AF;
pub const OUTPUT_TEXTURE_COORD19_EXT = 0x87B0;
pub const OUTPUT_TEXTURE_COORD20_EXT = 0x87B1;
pub const OUTPUT_TEXTURE_COORD21_EXT = 0x87B2;
pub const OUTPUT_TEXTURE_COORD22_EXT = 0x87B3;
pub const OUTPUT_TEXTURE_COORD23_EXT = 0x87B4;
pub const OUTPUT_TEXTURE_COORD24_EXT = 0x87B5;
pub const OUTPUT_TEXTURE_COORD25_EXT = 0x87B6;
pub const OUTPUT_TEXTURE_COORD26_EXT = 0x87B7;
pub const OUTPUT_TEXTURE_COORD27_EXT = 0x87B8;
pub const OUTPUT_TEXTURE_COORD28_EXT = 0x87B9;
pub const OUTPUT_TEXTURE_COORD29_EXT = 0x87BA;
pub const OUTPUT_TEXTURE_COORD30_EXT = 0x87BB;
pub const OUTPUT_TEXTURE_COORD31_EXT = 0x87BC;
pub const OUTPUT_FOG_EXT = 0x87BD;
pub const SCALAR_EXT = 0x87BE;
pub const VECTOR_EXT = 0x87BF;
pub const MATRIX_EXT = 0x87C0;
pub const VARIANT_EXT = 0x87C1;
pub const INVARIANT_EXT = 0x87C2;
pub const LOCAL_CONSTANT_EXT = 0x87C3;
pub const LOCAL_EXT = 0x87C4;
pub const MAX_VERTEX_SHADER_INSTRUCTIONS_EXT = 0x87C5;
pub const MAX_VERTEX_SHADER_VARIANTS_EXT = 0x87C6;
pub const MAX_VERTEX_SHADER_INVARIANTS_EXT = 0x87C7;
pub const MAX_VERTEX_SHADER_LOCAL_CONSTANTS_EXT = 0x87C8;
pub const MAX_VERTEX_SHADER_LOCALS_EXT = 0x87C9;
pub const MAX_OPTIMIZED_VERTEX_SHADER_INSTRUCTIONS_EXT = 0x87CA;
pub const MAX_OPTIMIZED_VERTEX_SHADER_VARIANTS_EXT = 0x87CB;
pub const MAX_OPTIMIZED_VERTEX_SHADER_LOCAL_CONSTANTS_EXT = 0x87CC;
pub const MAX_OPTIMIZED_VERTEX_SHADER_INVARIANTS_EXT = 0x87CD;
pub const MAX_OPTIMIZED_VERTEX_SHADER_LOCALS_EXT = 0x87CE;
pub const VERTEX_SHADER_INSTRUCTIONS_EXT = 0x87CF;
pub const VERTEX_SHADER_VARIANTS_EXT = 0x87D0;
pub const VERTEX_SHADER_INVARIANTS_EXT = 0x87D1;
pub const VERTEX_SHADER_LOCAL_CONSTANTS_EXT = 0x87D2;
pub const VERTEX_SHADER_LOCALS_EXT = 0x87D3;
pub const VERTEX_SHADER_OPTIMIZED_EXT = 0x87D4;
pub const X_EXT = 0x87D5;
pub const Y_EXT = 0x87D6;
pub const Z_EXT = 0x87D7;
pub const W_EXT = 0x87D8;
pub const NEGATIVE_X_EXT = 0x87D9;
pub const NEGATIVE_Y_EXT = 0x87DA;
pub const NEGATIVE_Z_EXT = 0x87DB;
pub const NEGATIVE_W_EXT = 0x87DC;
pub const ZERO_EXT = 0x87DD;
pub const ONE_EXT = 0x87DE;
pub const NEGATIVE_ONE_EXT = 0x87DF;
pub const NORMALIZED_RANGE_EXT = 0x87E0;
pub const FULL_RANGE_EXT = 0x87E1;
pub const CURRENT_VERTEX_EXT = 0x87E2;
pub const MVP_MATRIX_EXT = 0x87E3;
pub const VARIANT_VALUE_EXT = 0x87E4;
pub const VARIANT_DATATYPE_EXT = 0x87E5;
pub const VARIANT_ARRAY_STRIDE_EXT = 0x87E6;
pub const VARIANT_ARRAY_TYPE_EXT = 0x87E7;
pub const VARIANT_ARRAY_EXT = 0x87E8;
pub const VARIANT_ARRAY_POINTER_EXT = 0x87E9;
pub const INVARIANT_VALUE_EXT = 0x87EA;
pub const INVARIANT_DATATYPE_EXT = 0x87EB;
pub const LOCAL_CONSTANT_VALUE_EXT = 0x87EC;
pub const LOCAL_CONSTANT_DATATYPE_EXT = 0x87ED;
pub const ATC_RGBA_INTERPOLATED_ALPHA_AMD = 0x87EE;
pub const PN_TRIANGLES_ATI = 0x87F0;
pub const MAX_PN_TRIANGLES_TESSELATION_LEVEL_ATI = 0x87F1;
pub const PN_TRIANGLES_POINT_MODE_ATI = 0x87F2;
pub const PN_TRIANGLES_NORMAL_MODE_ATI = 0x87F3;
pub const PN_TRIANGLES_TESSELATION_LEVEL_ATI = 0x87F4;
pub const PN_TRIANGLES_POINT_MODE_LINEAR_ATI = 0x87F5;
pub const PN_TRIANGLES_POINT_MODE_CUBIC_ATI = 0x87F6;
pub const PN_TRIANGLES_NORMAL_MODE_LINEAR_ATI = 0x87F7;
pub const PN_TRIANGLES_NORMAL_MODE_QUADRATIC_ATI = 0x87F8;
pub const @"3DC_X_AMD" = 0x87F9;
pub const @"3DC_XY_AMD" = 0x87FA;
pub const VBO_FREE_MEMORY_ATI = 0x87FB;
pub const TEXTURE_FREE_MEMORY_ATI = 0x87FC;
pub const RENDERBUFFER_FREE_MEMORY_ATI = 0x87FD;
pub const NUM_PROGRAM_BINARY_FORMATS = 0x87FE;
pub const NUM_PROGRAM_BINARY_FORMATS_OES = 0x87FE;
pub const PROGRAM_BINARY_FORMATS = 0x87FF;
pub const PROGRAM_BINARY_FORMATS_OES = 0x87FF;
pub const STENCIL_BACK_FUNC = 0x8800;
pub const STENCIL_BACK_FUNC_ATI = 0x8800;
pub const STENCIL_BACK_FAIL = 0x8801;
pub const STENCIL_BACK_FAIL_ATI = 0x8801;
pub const STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802;
pub const STENCIL_BACK_PASS_DEPTH_FAIL_ATI = 0x8802;
pub const STENCIL_BACK_PASS_DEPTH_PASS = 0x8803;
pub const STENCIL_BACK_PASS_DEPTH_PASS_ATI = 0x8803;
pub const FRAGMENT_PROGRAM_ARB = 0x8804;
pub const PROGRAM_ALU_INSTRUCTIONS_ARB = 0x8805;
pub const PROGRAM_TEX_INSTRUCTIONS_ARB = 0x8806;
pub const PROGRAM_TEX_INDIRECTIONS_ARB = 0x8807;
pub const PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB = 0x8808;
pub const PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB = 0x8809;
pub const PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB = 0x880A;
pub const MAX_PROGRAM_ALU_INSTRUCTIONS_ARB = 0x880B;
pub const MAX_PROGRAM_TEX_INSTRUCTIONS_ARB = 0x880C;
pub const MAX_PROGRAM_TEX_INDIRECTIONS_ARB = 0x880D;
pub const MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB = 0x880E;
pub const MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB = 0x880F;
pub const MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB = 0x8810;
pub const RGBA32F = 0x8814;
pub const RGBA32F_ARB = 0x8814;
pub const RGBA32F_EXT = 0x8814;
pub const RGBA_FLOAT32_APPLE = 0x8814;
pub const RGBA_FLOAT32_ATI = 0x8814;
pub const RGB32F = 0x8815;
pub const RGB32F_ARB = 0x8815;
pub const RGB32F_EXT = 0x8815;
pub const RGB_FLOAT32_APPLE = 0x8815;
pub const RGB_FLOAT32_ATI = 0x8815;
pub const ALPHA32F_ARB = 0x8816;
pub const ALPHA32F_EXT = 0x8816;
pub const ALPHA_FLOAT32_APPLE = 0x8816;
pub const ALPHA_FLOAT32_ATI = 0x8816;
pub const INTENSITY32F_ARB = 0x8817;
pub const INTENSITY_FLOAT32_APPLE = 0x8817;
pub const INTENSITY_FLOAT32_ATI = 0x8817;
pub const LUMINANCE32F_ARB = 0x8818;
pub const LUMINANCE32F_EXT = 0x8818;
pub const LUMINANCE_FLOAT32_APPLE = 0x8818;
pub const LUMINANCE_FLOAT32_ATI = 0x8818;
pub const LUMINANCE_ALPHA32F_ARB = 0x8819;
pub const LUMINANCE_ALPHA32F_EXT = 0x8819;
pub const LUMINANCE_ALPHA_FLOAT32_APPLE = 0x8819;
pub const LUMINANCE_ALPHA_FLOAT32_ATI = 0x8819;
pub const RGBA16F = 0x881A;
pub const RGBA16F_ARB = 0x881A;
pub const RGBA16F_EXT = 0x881A;
pub const RGBA_FLOAT16_APPLE = 0x881A;
pub const RGBA_FLOAT16_ATI = 0x881A;
pub const RGB16F = 0x881B;
pub const RGB16F_ARB = 0x881B;
pub const RGB16F_EXT = 0x881B;
pub const RGB_FLOAT16_APPLE = 0x881B;
pub const RGB_FLOAT16_ATI = 0x881B;
pub const ALPHA16F_ARB = 0x881C;
pub const ALPHA16F_EXT = 0x881C;
pub const ALPHA_FLOAT16_APPLE = 0x881C;
pub const ALPHA_FLOAT16_ATI = 0x881C;
pub const INTENSITY16F_ARB = 0x881D;
pub const INTENSITY_FLOAT16_APPLE = 0x881D;
pub const INTENSITY_FLOAT16_ATI = 0x881D;
pub const LUMINANCE16F_ARB = 0x881E;
pub const LUMINANCE16F_EXT = 0x881E;
pub const LUMINANCE_FLOAT16_APPLE = 0x881E;
pub const LUMINANCE_FLOAT16_ATI = 0x881E;
pub const LUMINANCE_ALPHA16F_ARB = 0x881F;
pub const LUMINANCE_ALPHA16F_EXT = 0x881F;
pub const LUMINANCE_ALPHA_FLOAT16_APPLE = 0x881F;
pub const LUMINANCE_ALPHA_FLOAT16_ATI = 0x881F;
pub const RGBA_FLOAT_MODE_ARB = 0x8820;
pub const RGBA_FLOAT_MODE_ATI = 0x8820;
pub const WRITEONLY_RENDERING_QCOM = 0x8823;
pub const MAX_DRAW_BUFFERS = 0x8824;
pub const MAX_DRAW_BUFFERS_ARB = 0x8824;
pub const MAX_DRAW_BUFFERS_ATI = 0x8824;
pub const MAX_DRAW_BUFFERS_EXT = 0x8824;
pub const MAX_DRAW_BUFFERS_NV = 0x8824;
pub const DRAW_BUFFER0 = 0x8825;
pub const DRAW_BUFFER0_ARB = 0x8825;
pub const DRAW_BUFFER0_ATI = 0x8825;
pub const DRAW_BUFFER0_EXT = 0x8825;
pub const DRAW_BUFFER0_NV = 0x8825;
pub const DRAW_BUFFER1 = 0x8826;
pub const DRAW_BUFFER1_ARB = 0x8826;
pub const DRAW_BUFFER1_ATI = 0x8826;
pub const DRAW_BUFFER1_EXT = 0x8826;
pub const DRAW_BUFFER1_NV = 0x8826;
pub const DRAW_BUFFER2 = 0x8827;
pub const DRAW_BUFFER2_ARB = 0x8827;
pub const DRAW_BUFFER2_ATI = 0x8827;
pub const DRAW_BUFFER2_EXT = 0x8827;
pub const DRAW_BUFFER2_NV = 0x8827;
pub const DRAW_BUFFER3 = 0x8828;
pub const DRAW_BUFFER3_ARB = 0x8828;
pub const DRAW_BUFFER3_ATI = 0x8828;
pub const DRAW_BUFFER3_EXT = 0x8828;
pub const DRAW_BUFFER3_NV = 0x8828;
pub const DRAW_BUFFER4 = 0x8829;
pub const DRAW_BUFFER4_ARB = 0x8829;
pub const DRAW_BUFFER4_ATI = 0x8829;
pub const DRAW_BUFFER4_EXT = 0x8829;
pub const DRAW_BUFFER4_NV = 0x8829;
pub const DRAW_BUFFER5 = 0x882A;
pub const DRAW_BUFFER5_ARB = 0x882A;
pub const DRAW_BUFFER5_ATI = 0x882A;
pub const DRAW_BUFFER5_EXT = 0x882A;
pub const DRAW_BUFFER5_NV = 0x882A;
pub const DRAW_BUFFER6 = 0x882B;
pub const DRAW_BUFFER6_ARB = 0x882B;
pub const DRAW_BUFFER6_ATI = 0x882B;
pub const DRAW_BUFFER6_EXT = 0x882B;
pub const DRAW_BUFFER6_NV = 0x882B;
pub const DRAW_BUFFER7 = 0x882C;
pub const DRAW_BUFFER7_ARB = 0x882C;
pub const DRAW_BUFFER7_ATI = 0x882C;
pub const DRAW_BUFFER7_EXT = 0x882C;
pub const DRAW_BUFFER7_NV = 0x882C;
pub const DRAW_BUFFER8 = 0x882D;
pub const DRAW_BUFFER8_ARB = 0x882D;
pub const DRAW_BUFFER8_ATI = 0x882D;
pub const DRAW_BUFFER8_EXT = 0x882D;
pub const DRAW_BUFFER8_NV = 0x882D;
pub const DRAW_BUFFER9 = 0x882E;
pub const DRAW_BUFFER9_ARB = 0x882E;
pub const DRAW_BUFFER9_ATI = 0x882E;
pub const DRAW_BUFFER9_EXT = 0x882E;
pub const DRAW_BUFFER9_NV = 0x882E;
pub const DRAW_BUFFER10 = 0x882F;
pub const DRAW_BUFFER10_ARB = 0x882F;
pub const DRAW_BUFFER10_ATI = 0x882F;
pub const DRAW_BUFFER10_EXT = 0x882F;
pub const DRAW_BUFFER10_NV = 0x882F;
pub const DRAW_BUFFER11 = 0x8830;
pub const DRAW_BUFFER11_ARB = 0x8830;
pub const DRAW_BUFFER11_ATI = 0x8830;
pub const DRAW_BUFFER11_EXT = 0x8830;
pub const DRAW_BUFFER11_NV = 0x8830;
pub const DRAW_BUFFER12 = 0x8831;
pub const DRAW_BUFFER12_ARB = 0x8831;
pub const DRAW_BUFFER12_ATI = 0x8831;
pub const DRAW_BUFFER12_EXT = 0x8831;
pub const DRAW_BUFFER12_NV = 0x8831;
pub const DRAW_BUFFER13 = 0x8832;
pub const DRAW_BUFFER13_ARB = 0x8832;
pub const DRAW_BUFFER13_ATI = 0x8832;
pub const DRAW_BUFFER13_EXT = 0x8832;
pub const DRAW_BUFFER13_NV = 0x8832;
pub const DRAW_BUFFER14 = 0x8833;
pub const DRAW_BUFFER14_ARB = 0x8833;
pub const DRAW_BUFFER14_ATI = 0x8833;
pub const DRAW_BUFFER14_EXT = 0x8833;
pub const DRAW_BUFFER14_NV = 0x8833;
pub const DRAW_BUFFER15 = 0x8834;
pub const DRAW_BUFFER15_ARB = 0x8834;
pub const DRAW_BUFFER15_ATI = 0x8834;
pub const DRAW_BUFFER15_EXT = 0x8834;
pub const DRAW_BUFFER15_NV = 0x8834;
pub const COLOR_CLEAR_UNCLAMPED_VALUE_ATI = 0x8835;
pub const COMPRESSED_LUMINANCE_ALPHA_3DC_ATI = 0x8837;
pub const BLEND_EQUATION_ALPHA = 0x883D;
pub const BLEND_EQUATION_ALPHA_EXT = 0x883D;
pub const BLEND_EQUATION_ALPHA_OES = 0x883D;
pub const SUBSAMPLE_DISTANCE_AMD = 0x883F;
pub const MATRIX_PALETTE_ARB = 0x8840;
pub const MATRIX_PALETTE_OES = 0x8840;
pub const MAX_MATRIX_PALETTE_STACK_DEPTH_ARB = 0x8841;
pub const MAX_PALETTE_MATRICES_ARB = 0x8842;
pub const MAX_PALETTE_MATRICES_OES = 0x8842;
pub const CURRENT_PALETTE_MATRIX_ARB = 0x8843;
pub const CURRENT_PALETTE_MATRIX_OES = 0x8843;
pub const MATRIX_INDEX_ARRAY_ARB = 0x8844;
pub const MATRIX_INDEX_ARRAY_OES = 0x8844;
pub const CURRENT_MATRIX_INDEX_ARB = 0x8845;
pub const MATRIX_INDEX_ARRAY_SIZE_ARB = 0x8846;
pub const MATRIX_INDEX_ARRAY_SIZE_OES = 0x8846;
pub const MATRIX_INDEX_ARRAY_TYPE_ARB = 0x8847;
pub const MATRIX_INDEX_ARRAY_TYPE_OES = 0x8847;
pub const MATRIX_INDEX_ARRAY_STRIDE_ARB = 0x8848;
pub const MATRIX_INDEX_ARRAY_STRIDE_OES = 0x8848;
pub const MATRIX_INDEX_ARRAY_POINTER_ARB = 0x8849;
pub const MATRIX_INDEX_ARRAY_POINTER_OES = 0x8849;
pub const TEXTURE_DEPTH_SIZE = 0x884A;
pub const TEXTURE_DEPTH_SIZE_ARB = 0x884A;
pub const DEPTH_TEXTURE_MODE = 0x884B;
pub const DEPTH_TEXTURE_MODE_ARB = 0x884B;
pub const TEXTURE_COMPARE_MODE = 0x884C;
pub const TEXTURE_COMPARE_MODE_ARB = 0x884C;
pub const TEXTURE_COMPARE_MODE_EXT = 0x884C;
pub const TEXTURE_COMPARE_FUNC = 0x884D;
pub const TEXTURE_COMPARE_FUNC_ARB = 0x884D;
pub const TEXTURE_COMPARE_FUNC_EXT = 0x884D;
pub const COMPARE_R_TO_TEXTURE = 0x884E;
pub const COMPARE_R_TO_TEXTURE_ARB = 0x884E;
pub const COMPARE_REF_DEPTH_TO_TEXTURE_EXT = 0x884E;
pub const COMPARE_REF_TO_TEXTURE = 0x884E;
pub const COMPARE_REF_TO_TEXTURE_EXT = 0x884E;
pub const TEXTURE_CUBE_MAP_SEAMLESS = 0x884F;
pub const OFFSET_PROJECTIVE_TEXTURE_2D_NV = 0x8850;
pub const OFFSET_PROJECTIVE_TEXTURE_2D_SCALE_NV = 0x8851;
pub const OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_NV = 0x8852;
pub const OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_SCALE_NV = 0x8853;
pub const OFFSET_HILO_TEXTURE_2D_NV = 0x8854;
pub const OFFSET_HILO_TEXTURE_RECTANGLE_NV = 0x8855;
pub const OFFSET_HILO_PROJECTIVE_TEXTURE_2D_NV = 0x8856;
pub const OFFSET_HILO_PROJECTIVE_TEXTURE_RECTANGLE_NV = 0x8857;
pub const DEPENDENT_HILO_TEXTURE_2D_NV = 0x8858;
pub const DEPENDENT_RGB_TEXTURE_3D_NV = 0x8859;
pub const DEPENDENT_RGB_TEXTURE_CUBE_MAP_NV = 0x885A;
pub const DOT_PRODUCT_PASS_THROUGH_NV = 0x885B;
pub const DOT_PRODUCT_TEXTURE_1D_NV = 0x885C;
pub const DOT_PRODUCT_AFFINE_DEPTH_REPLACE_NV = 0x885D;
pub const HILO8_NV = 0x885E;
pub const SIGNED_HILO8_NV = 0x885F;
pub const FORCE_BLUE_TO_ONE_NV = 0x8860;
pub const POINT_SPRITE = 0x8861;
pub const POINT_SPRITE_ARB = 0x8861;
pub const POINT_SPRITE_NV = 0x8861;
pub const POINT_SPRITE_OES = 0x8861;
pub const COORD_REPLACE = 0x8862;
pub const COORD_REPLACE_ARB = 0x8862;
pub const COORD_REPLACE_NV = 0x8862;
pub const COORD_REPLACE_OES = 0x8862;
pub const POINT_SPRITE_R_MODE_NV = 0x8863;
pub const PIXEL_COUNTER_BITS_NV = 0x8864;
pub const QUERY_COUNTER_BITS = 0x8864;
pub const QUERY_COUNTER_BITS_ARB = 0x8864;
pub const QUERY_COUNTER_BITS_EXT = 0x8864;
pub const CURRENT_OCCLUSION_QUERY_ID_NV = 0x8865;
pub const CURRENT_QUERY = 0x8865;
pub const CURRENT_QUERY_ARB = 0x8865;
pub const CURRENT_QUERY_EXT = 0x8865;
pub const PIXEL_COUNT_NV = 0x8866;
pub const QUERY_RESULT = 0x8866;
pub const QUERY_RESULT_ARB = 0x8866;
pub const QUERY_RESULT_EXT = 0x8866;
pub const PIXEL_COUNT_AVAILABLE_NV = 0x8867;
pub const QUERY_RESULT_AVAILABLE = 0x8867;
pub const QUERY_RESULT_AVAILABLE_ARB = 0x8867;
pub const QUERY_RESULT_AVAILABLE_EXT = 0x8867;
pub const MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV = 0x8868;
pub const MAX_VERTEX_ATTRIBS = 0x8869;
pub const MAX_VERTEX_ATTRIBS_ARB = 0x8869;
pub const VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A;
pub const VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB = 0x886A;
pub const MAX_TESS_CONTROL_INPUT_COMPONENTS = 0x886C;
pub const MAX_TESS_CONTROL_INPUT_COMPONENTS_EXT = 0x886C;
pub const MAX_TESS_CONTROL_INPUT_COMPONENTS_OES = 0x886C;
pub const MAX_TESS_EVALUATION_INPUT_COMPONENTS = 0x886D;
pub const MAX_TESS_EVALUATION_INPUT_COMPONENTS_EXT = 0x886D;
pub const MAX_TESS_EVALUATION_INPUT_COMPONENTS_OES = 0x886D;
pub const DEPTH_STENCIL_TO_RGBA_NV = 0x886E;
pub const DEPTH_STENCIL_TO_BGRA_NV = 0x886F;
pub const FRAGMENT_PROGRAM_NV = 0x8870;
pub const MAX_TEXTURE_COORDS = 0x8871;
pub const MAX_TEXTURE_COORDS_ARB = 0x8871;
pub const MAX_TEXTURE_COORDS_NV = 0x8871;
pub const MAX_TEXTURE_IMAGE_UNITS = 0x8872;
pub const MAX_TEXTURE_IMAGE_UNITS_ARB = 0x8872;
pub const MAX_TEXTURE_IMAGE_UNITS_NV = 0x8872;
pub const FRAGMENT_PROGRAM_BINDING_NV = 0x8873;
pub const PROGRAM_ERROR_STRING_ARB = 0x8874;
pub const PROGRAM_ERROR_STRING_NV = 0x8874;
pub const PROGRAM_FORMAT_ASCII_ARB = 0x8875;
pub const PROGRAM_FORMAT_ARB = 0x8876;
pub const WRITE_PIXEL_DATA_RANGE_NV = 0x8878;
pub const READ_PIXEL_DATA_RANGE_NV = 0x8879;
pub const WRITE_PIXEL_DATA_RANGE_LENGTH_NV = 0x887A;
pub const READ_PIXEL_DATA_RANGE_LENGTH_NV = 0x887B;
pub const WRITE_PIXEL_DATA_RANGE_POINTER_NV = 0x887C;
pub const READ_PIXEL_DATA_RANGE_POINTER_NV = 0x887D;
pub const GEOMETRY_SHADER_INVOCATIONS = 0x887F;
pub const GEOMETRY_SHADER_INVOCATIONS_EXT = 0x887F;
pub const GEOMETRY_SHADER_INVOCATIONS_OES = 0x887F;
pub const FLOAT_R_NV = 0x8880;
pub const FLOAT_RG_NV = 0x8881;
pub const FLOAT_RGB_NV = 0x8882;
pub const FLOAT_RGBA_NV = 0x8883;
pub const FLOAT_R16_NV = 0x8884;
pub const FLOAT_R32_NV = 0x8885;
pub const FLOAT_RG16_NV = 0x8886;
pub const FLOAT_RG32_NV = 0x8887;
pub const FLOAT_RGB16_NV = 0x8888;
pub const FLOAT_RGB32_NV = 0x8889;
pub const FLOAT_RGBA16_NV = 0x888A;
pub const FLOAT_RGBA32_NV = 0x888B;
pub const TEXTURE_FLOAT_COMPONENTS_NV = 0x888C;
pub const FLOAT_CLEAR_COLOR_VALUE_NV = 0x888D;
pub const FLOAT_RGBA_MODE_NV = 0x888E;
pub const TEXTURE_UNSIGNED_REMAP_MODE_NV = 0x888F;
pub const DEPTH_BOUNDS_TEST_EXT = 0x8890;
pub const DEPTH_BOUNDS_EXT = 0x8891;
pub const ARRAY_BUFFER = 0x8892;
pub const ARRAY_BUFFER_ARB = 0x8892;
pub const ELEMENT_ARRAY_BUFFER = 0x8893;
pub const ELEMENT_ARRAY_BUFFER_ARB = 0x8893;
pub const ARRAY_BUFFER_BINDING = 0x8894;
pub const ARRAY_BUFFER_BINDING_ARB = 0x8894;
pub const ELEMENT_ARRAY_BUFFER_BINDING = 0x8895;
pub const ELEMENT_ARRAY_BUFFER_BINDING_ARB = 0x8895;
pub const VERTEX_ARRAY_BUFFER_BINDING = 0x8896;
pub const VERTEX_ARRAY_BUFFER_BINDING_ARB = 0x8896;
pub const NORMAL_ARRAY_BUFFER_BINDING = 0x8897;
pub const NORMAL_ARRAY_BUFFER_BINDING_ARB = 0x8897;
pub const COLOR_ARRAY_BUFFER_BINDING = 0x8898;
pub const COLOR_ARRAY_BUFFER_BINDING_ARB = 0x8898;
pub const INDEX_ARRAY_BUFFER_BINDING = 0x8899;
pub const INDEX_ARRAY_BUFFER_BINDING_ARB = 0x8899;
pub const TEXTURE_COORD_ARRAY_BUFFER_BINDING = 0x889A;
pub const TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB = 0x889A;
pub const EDGE_FLAG_ARRAY_BUFFER_BINDING = 0x889B;
pub const EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB = 0x889B;
pub const SECONDARY_COLOR_ARRAY_BUFFER_BINDING = 0x889C;
pub const SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB = 0x889C;
pub const FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB = 0x889D;
pub const FOG_COORDINATE_ARRAY_BUFFER_BINDING = 0x889D;
pub const FOG_COORD_ARRAY_BUFFER_BINDING = 0x889D;
pub const WEIGHT_ARRAY_BUFFER_BINDING = 0x889E;
pub const WEIGHT_ARRAY_BUFFER_BINDING_ARB = 0x889E;
pub const WEIGHT_ARRAY_BUFFER_BINDING_OES = 0x889E;
pub const VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;
pub const VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB = 0x889F;
pub const PROGRAM_INSTRUCTIONS_ARB = 0x88A0;
pub const MAX_PROGRAM_INSTRUCTIONS_ARB = 0x88A1;
pub const PROGRAM_NATIVE_INSTRUCTIONS_ARB = 0x88A2;
pub const MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB = 0x88A3;
pub const PROGRAM_TEMPORARIES_ARB = 0x88A4;
pub const MAX_PROGRAM_TEMPORARIES_ARB = 0x88A5;
pub const PROGRAM_NATIVE_TEMPORARIES_ARB = 0x88A6;
pub const MAX_PROGRAM_NATIVE_TEMPORARIES_ARB = 0x88A7;
pub const PROGRAM_PARAMETERS_ARB = 0x88A8;
pub const MAX_PROGRAM_PARAMETERS_ARB = 0x88A9;
pub const PROGRAM_NATIVE_PARAMETERS_ARB = 0x88AA;
pub const MAX_PROGRAM_NATIVE_PARAMETERS_ARB = 0x88AB;
pub const PROGRAM_ATTRIBS_ARB = 0x88AC;
pub const MAX_PROGRAM_ATTRIBS_ARB = 0x88AD;
pub const PROGRAM_NATIVE_ATTRIBS_ARB = 0x88AE;
pub const MAX_PROGRAM_NATIVE_ATTRIBS_ARB = 0x88AF;
pub const PROGRAM_ADDRESS_REGISTERS_ARB = 0x88B0;
pub const MAX_PROGRAM_ADDRESS_REGISTERS_ARB = 0x88B1;
pub const PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB = 0x88B2;
pub const MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB = 0x88B3;
pub const MAX_PROGRAM_LOCAL_PARAMETERS_ARB = 0x88B4;
pub const MAX_PROGRAM_ENV_PARAMETERS_ARB = 0x88B5;
pub const PROGRAM_UNDER_NATIVE_LIMITS_ARB = 0x88B6;
pub const TRANSPOSE_CURRENT_MATRIX_ARB = 0x88B7;
pub const READ_ONLY = 0x88B8;
pub const READ_ONLY_ARB = 0x88B8;
pub const WRITE_ONLY = 0x88B9;
pub const WRITE_ONLY_ARB = 0x88B9;
pub const WRITE_ONLY_OES = 0x88B9;
pub const READ_WRITE = 0x88BA;
pub const READ_WRITE_ARB = 0x88BA;
pub const BUFFER_ACCESS = 0x88BB;
pub const BUFFER_ACCESS_ARB = 0x88BB;
pub const BUFFER_ACCESS_OES = 0x88BB;
pub const BUFFER_MAPPED = 0x88BC;
pub const BUFFER_MAPPED_ARB = 0x88BC;
pub const BUFFER_MAPPED_OES = 0x88BC;
pub const BUFFER_MAP_POINTER = 0x88BD;
pub const BUFFER_MAP_POINTER_ARB = 0x88BD;
pub const BUFFER_MAP_POINTER_OES = 0x88BD;
pub const WRITE_DISCARD_NV = 0x88BE;
pub const TIME_ELAPSED = 0x88BF;
pub const TIME_ELAPSED_EXT = 0x88BF;
pub const MATRIX0_ARB = 0x88C0;
pub const MATRIX1_ARB = 0x88C1;
pub const MATRIX2_ARB = 0x88C2;
pub const MATRIX3_ARB = 0x88C3;
pub const MATRIX4_ARB = 0x88C4;
pub const MATRIX5_ARB = 0x88C5;
pub const MATRIX6_ARB = 0x88C6;
pub const MATRIX7_ARB = 0x88C7;
pub const MATRIX8_ARB = 0x88C8;
pub const MATRIX9_ARB = 0x88C9;
pub const MATRIX10_ARB = 0x88CA;
pub const MATRIX11_ARB = 0x88CB;
pub const MATRIX12_ARB = 0x88CC;
pub const MATRIX13_ARB = 0x88CD;
pub const MATRIX14_ARB = 0x88CE;
pub const MATRIX15_ARB = 0x88CF;
pub const MATRIX16_ARB = 0x88D0;
pub const MATRIX17_ARB = 0x88D1;
pub const MATRIX18_ARB = 0x88D2;
pub const MATRIX19_ARB = 0x88D3;
pub const MATRIX20_ARB = 0x88D4;
pub const MATRIX21_ARB = 0x88D5;
pub const MATRIX22_ARB = 0x88D6;
pub const MATRIX23_ARB = 0x88D7;
pub const MATRIX24_ARB = 0x88D8;
pub const MATRIX25_ARB = 0x88D9;
pub const MATRIX26_ARB = 0x88DA;
pub const MATRIX27_ARB = 0x88DB;
pub const MATRIX28_ARB = 0x88DC;
pub const MATRIX29_ARB = 0x88DD;
pub const MATRIX30_ARB = 0x88DE;
pub const MATRIX31_ARB = 0x88DF;
pub const STREAM_DRAW = 0x88E0;
pub const STREAM_DRAW_ARB = 0x88E0;
pub const STREAM_READ = 0x88E1;
pub const STREAM_READ_ARB = 0x88E1;
pub const STREAM_COPY = 0x88E2;
pub const STREAM_COPY_ARB = 0x88E2;
pub const STATIC_DRAW = 0x88E4;
pub const STATIC_DRAW_ARB = 0x88E4;
pub const STATIC_READ = 0x88E5;
pub const STATIC_READ_ARB = 0x88E5;
pub const STATIC_COPY = 0x88E6;
pub const STATIC_COPY_ARB = 0x88E6;
pub const DYNAMIC_DRAW = 0x88E8;
pub const DYNAMIC_DRAW_ARB = 0x88E8;
pub const DYNAMIC_READ = 0x88E9;
pub const DYNAMIC_READ_ARB = 0x88E9;
pub const DYNAMIC_COPY = 0x88EA;
pub const DYNAMIC_COPY_ARB = 0x88EA;
pub const PIXEL_PACK_BUFFER = 0x88EB;
pub const PIXEL_PACK_BUFFER_ARB = 0x88EB;
pub const PIXEL_PACK_BUFFER_EXT = 0x88EB;
pub const PIXEL_PACK_BUFFER_NV = 0x88EB;
pub const PIXEL_UNPACK_BUFFER = 0x88EC;
pub const PIXEL_UNPACK_BUFFER_ARB = 0x88EC;
pub const PIXEL_UNPACK_BUFFER_EXT = 0x88EC;
pub const PIXEL_UNPACK_BUFFER_NV = 0x88EC;
pub const PIXEL_PACK_BUFFER_BINDING = 0x88ED;
pub const PIXEL_PACK_BUFFER_BINDING_ARB = 0x88ED;
pub const PIXEL_PACK_BUFFER_BINDING_EXT = 0x88ED;
pub const PIXEL_PACK_BUFFER_BINDING_NV = 0x88ED;
pub const ETC1_SRGB8_NV = 0x88EE;
pub const PIXEL_UNPACK_BUFFER_BINDING = 0x88EF;
pub const PIXEL_UNPACK_BUFFER_BINDING_ARB = 0x88EF;
pub const PIXEL_UNPACK_BUFFER_BINDING_EXT = 0x88EF;
pub const PIXEL_UNPACK_BUFFER_BINDING_NV = 0x88EF;
pub const DEPTH24_STENCIL8 = 0x88F0;
pub const DEPTH24_STENCIL8_EXT = 0x88F0;
pub const DEPTH24_STENCIL8_OES = 0x88F0;
pub const TEXTURE_STENCIL_SIZE = 0x88F1;
pub const TEXTURE_STENCIL_SIZE_EXT = 0x88F1;
pub const STENCIL_TAG_BITS_EXT = 0x88F2;
pub const STENCIL_CLEAR_TAG_VALUE_EXT = 0x88F3;
pub const MAX_PROGRAM_EXEC_INSTRUCTIONS_NV = 0x88F4;
pub const MAX_PROGRAM_CALL_DEPTH_NV = 0x88F5;
pub const MAX_PROGRAM_IF_DEPTH_NV = 0x88F6;
pub const MAX_PROGRAM_LOOP_DEPTH_NV = 0x88F7;
pub const MAX_PROGRAM_LOOP_COUNT_NV = 0x88F8;
pub const SRC1_COLOR = 0x88F9;
pub const SRC1_COLOR_EXT = 0x88F9;
pub const ONE_MINUS_SRC1_COLOR = 0x88FA;
pub const ONE_MINUS_SRC1_COLOR_EXT = 0x88FA;
pub const ONE_MINUS_SRC1_ALPHA = 0x88FB;
pub const ONE_MINUS_SRC1_ALPHA_EXT = 0x88FB;
pub const MAX_DUAL_SOURCE_DRAW_BUFFERS = 0x88FC;
pub const MAX_DUAL_SOURCE_DRAW_BUFFERS_EXT = 0x88FC;
pub const VERTEX_ATTRIB_ARRAY_INTEGER = 0x88FD;
pub const VERTEX_ATTRIB_ARRAY_INTEGER_EXT = 0x88FD;
pub const VERTEX_ATTRIB_ARRAY_INTEGER_NV = 0x88FD;
pub const VERTEX_ATTRIB_ARRAY_DIVISOR = 0x88FE;
pub const VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE = 0x88FE;
pub const VERTEX_ATTRIB_ARRAY_DIVISOR_ARB = 0x88FE;
pub const VERTEX_ATTRIB_ARRAY_DIVISOR_EXT = 0x88FE;
pub const VERTEX_ATTRIB_ARRAY_DIVISOR_NV = 0x88FE;
pub const MAX_ARRAY_TEXTURE_LAYERS = 0x88FF;
pub const MAX_ARRAY_TEXTURE_LAYERS_EXT = 0x88FF;
pub const MIN_PROGRAM_TEXEL_OFFSET = 0x8904;
pub const MIN_PROGRAM_TEXEL_OFFSET_EXT = 0x8904;
pub const MIN_PROGRAM_TEXEL_OFFSET_NV = 0x8904;
pub const MAX_PROGRAM_TEXEL_OFFSET = 0x8905;
pub const MAX_PROGRAM_TEXEL_OFFSET_EXT = 0x8905;
pub const MAX_PROGRAM_TEXEL_OFFSET_NV = 0x8905;
pub const PROGRAM_ATTRIB_COMPONENTS_NV = 0x8906;
pub const PROGRAM_RESULT_COMPONENTS_NV = 0x8907;
pub const MAX_PROGRAM_ATTRIB_COMPONENTS_NV = 0x8908;
pub const MAX_PROGRAM_RESULT_COMPONENTS_NV = 0x8909;
pub const STENCIL_TEST_TWO_SIDE_EXT = 0x8910;
pub const ACTIVE_STENCIL_FACE_EXT = 0x8911;
pub const MIRROR_CLAMP_TO_BORDER_EXT = 0x8912;
pub const SAMPLES_PASSED = 0x8914;
pub const SAMPLES_PASSED_ARB = 0x8914;
pub const GEOMETRY_VERTICES_OUT = 0x8916;
pub const GEOMETRY_LINKED_VERTICES_OUT_EXT = 0x8916;
pub const GEOMETRY_LINKED_VERTICES_OUT_OES = 0x8916;
pub const GEOMETRY_INPUT_TYPE = 0x8917;
pub const GEOMETRY_LINKED_INPUT_TYPE_EXT = 0x8917;
pub const GEOMETRY_LINKED_INPUT_TYPE_OES = 0x8917;
pub const GEOMETRY_OUTPUT_TYPE = 0x8918;
pub const GEOMETRY_LINKED_OUTPUT_TYPE_EXT = 0x8918;
pub const GEOMETRY_LINKED_OUTPUT_TYPE_OES = 0x8918;
pub const SAMPLER_BINDING = 0x8919;
pub const CLAMP_VERTEX_COLOR = 0x891A;
pub const CLAMP_VERTEX_COLOR_ARB = 0x891A;
pub const CLAMP_FRAGMENT_COLOR = 0x891B;
pub const CLAMP_FRAGMENT_COLOR_ARB = 0x891B;
pub const CLAMP_READ_COLOR = 0x891C;
pub const CLAMP_READ_COLOR_ARB = 0x891C;
pub const FIXED_ONLY = 0x891D;
pub const FIXED_ONLY_ARB = 0x891D;
pub const TESS_CONTROL_PROGRAM_NV = 0x891E;
pub const TESS_EVALUATION_PROGRAM_NV = 0x891F;
pub const FRAGMENT_SHADER_ATI = 0x8920;
pub const REG_0_ATI = 0x8921;
pub const REG_1_ATI = 0x8922;
pub const REG_2_ATI = 0x8923;
pub const REG_3_ATI = 0x8924;
pub const REG_4_ATI = 0x8925;
pub const REG_5_ATI = 0x8926;
pub const REG_6_ATI = 0x8927;
pub const REG_7_ATI = 0x8928;
pub const REG_8_ATI = 0x8929;
pub const REG_9_ATI = 0x892A;
pub const REG_10_ATI = 0x892B;
pub const REG_11_ATI = 0x892C;
pub const REG_12_ATI = 0x892D;
pub const REG_13_ATI = 0x892E;
pub const REG_14_ATI = 0x892F;
pub const REG_15_ATI = 0x8930;
pub const REG_16_ATI = 0x8931;
pub const REG_17_ATI = 0x8932;
pub const REG_18_ATI = 0x8933;
pub const REG_19_ATI = 0x8934;
pub const REG_20_ATI = 0x8935;
pub const REG_21_ATI = 0x8936;
pub const REG_22_ATI = 0x8937;
pub const REG_23_ATI = 0x8938;
pub const REG_24_ATI = 0x8939;
pub const REG_25_ATI = 0x893A;
pub const REG_26_ATI = 0x893B;
pub const REG_27_ATI = 0x893C;
pub const REG_28_ATI = 0x893D;
pub const REG_29_ATI = 0x893E;
pub const REG_30_ATI = 0x893F;
pub const REG_31_ATI = 0x8940;
pub const CON_0_ATI = 0x8941;
pub const CON_1_ATI = 0x8942;
pub const CON_2_ATI = 0x8943;
pub const CON_3_ATI = 0x8944;
pub const CON_4_ATI = 0x8945;
pub const CON_5_ATI = 0x8946;
pub const CON_6_ATI = 0x8947;
pub const CON_7_ATI = 0x8948;
pub const CON_8_ATI = 0x8949;
pub const CON_9_ATI = 0x894A;
pub const CON_10_ATI = 0x894B;
pub const CON_11_ATI = 0x894C;
pub const CON_12_ATI = 0x894D;
pub const CON_13_ATI = 0x894E;
pub const CON_14_ATI = 0x894F;
pub const CON_15_ATI = 0x8950;
pub const CON_16_ATI = 0x8951;
pub const CON_17_ATI = 0x8952;
pub const CON_18_ATI = 0x8953;
pub const CON_19_ATI = 0x8954;
pub const CON_20_ATI = 0x8955;
pub const CON_21_ATI = 0x8956;
pub const CON_22_ATI = 0x8957;
pub const CON_23_ATI = 0x8958;
pub const CON_24_ATI = 0x8959;
pub const CON_25_ATI = 0x895A;
pub const CON_26_ATI = 0x895B;
pub const CON_27_ATI = 0x895C;
pub const CON_28_ATI = 0x895D;
pub const CON_29_ATI = 0x895E;
pub const CON_30_ATI = 0x895F;
pub const CON_31_ATI = 0x8960;
pub const MOV_ATI = 0x8961;
pub const ADD_ATI = 0x8963;
pub const MUL_ATI = 0x8964;
pub const SUB_ATI = 0x8965;
pub const DOT3_ATI = 0x8966;
pub const DOT4_ATI = 0x8967;
pub const MAD_ATI = 0x8968;
pub const LERP_ATI = 0x8969;
pub const CND_ATI = 0x896A;
pub const CND0_ATI = 0x896B;
pub const DOT2_ADD_ATI = 0x896C;
pub const SECONDARY_INTERPOLATOR_ATI = 0x896D;
pub const NUM_FRAGMENT_REGISTERS_ATI = 0x896E;
pub const NUM_FRAGMENT_CONSTANTS_ATI = 0x896F;
pub const NUM_PASSES_ATI = 0x8970;
pub const NUM_INSTRUCTIONS_PER_PASS_ATI = 0x8971;
pub const NUM_INSTRUCTIONS_TOTAL_ATI = 0x8972;
pub const NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI = 0x8973;
pub const NUM_LOOPBACK_COMPONENTS_ATI = 0x8974;
pub const COLOR_ALPHA_PAIRING_ATI = 0x8975;
pub const SWIZZLE_STR_ATI = 0x8976;
pub const SWIZZLE_STQ_ATI = 0x8977;
pub const SWIZZLE_STR_DR_ATI = 0x8978;
pub const SWIZZLE_STQ_DQ_ATI = 0x8979;
pub const SWIZZLE_STRQ_ATI = 0x897A;
pub const SWIZZLE_STRQ_DQ_ATI = 0x897B;
pub const INTERLACE_OML = 0x8980;
pub const INTERLACE_READ_OML = 0x8981;
pub const FORMAT_SUBSAMPLE_24_24_OML = 0x8982;
pub const FORMAT_SUBSAMPLE_244_244_OML = 0x8983;
pub const PACK_RESAMPLE_OML = 0x8984;
pub const UNPACK_RESAMPLE_OML = 0x8985;
pub const RESAMPLE_REPLICATE_OML = 0x8986;
pub const RESAMPLE_ZERO_FILL_OML = 0x8987;
pub const RESAMPLE_AVERAGE_OML = 0x8988;
pub const RESAMPLE_DECIMATE_OML = 0x8989;
pub const POINT_SIZE_ARRAY_TYPE_OES = 0x898A;
pub const POINT_SIZE_ARRAY_STRIDE_OES = 0x898B;
pub const POINT_SIZE_ARRAY_POINTER_OES = 0x898C;
pub const MODELVIEW_MATRIX_FLOAT_AS_INT_BITS_OES = 0x898D;
pub const PROJECTION_MATRIX_FLOAT_AS_INT_BITS_OES = 0x898E;
pub const TEXTURE_MATRIX_FLOAT_AS_INT_BITS_OES = 0x898F;
pub const VERTEX_ATTRIB_MAP1_APPLE = 0x8A00;
pub const VERTEX_ATTRIB_MAP2_APPLE = 0x8A01;
pub const VERTEX_ATTRIB_MAP1_SIZE_APPLE = 0x8A02;
pub const VERTEX_ATTRIB_MAP1_COEFF_APPLE = 0x8A03;
pub const VERTEX_ATTRIB_MAP1_ORDER_APPLE = 0x8A04;
pub const VERTEX_ATTRIB_MAP1_DOMAIN_APPLE = 0x8A05;
pub const VERTEX_ATTRIB_MAP2_SIZE_APPLE = 0x8A06;
pub const VERTEX_ATTRIB_MAP2_COEFF_APPLE = 0x8A07;
pub const VERTEX_ATTRIB_MAP2_ORDER_APPLE = 0x8A08;
pub const VERTEX_ATTRIB_MAP2_DOMAIN_APPLE = 0x8A09;
pub const DRAW_PIXELS_APPLE = 0x8A0A;
pub const FENCE_APPLE = 0x8A0B;
pub const ELEMENT_ARRAY_APPLE = 0x8A0C;
pub const ELEMENT_ARRAY_TYPE_APPLE = 0x8A0D;
pub const ELEMENT_ARRAY_POINTER_APPLE = 0x8A0E;
pub const COLOR_FLOAT_APPLE = 0x8A0F;
pub const UNIFORM_BUFFER = 0x8A11;
pub const BUFFER_SERIALIZED_MODIFY_APPLE = 0x8A12;
pub const BUFFER_FLUSHING_UNMAP_APPLE = 0x8A13;
pub const AUX_DEPTH_STENCIL_APPLE = 0x8A14;
pub const PACK_ROW_BYTES_APPLE = 0x8A15;
pub const UNPACK_ROW_BYTES_APPLE = 0x8A16;
pub const RELEASED_APPLE = 0x8A19;
pub const VOLATILE_APPLE = 0x8A1A;
pub const RETAINED_APPLE = 0x8A1B;
pub const UNDEFINED_APPLE = 0x8A1C;
pub const PURGEABLE_APPLE = 0x8A1D;
pub const RGB_422_APPLE = 0x8A1F;
pub const UNIFORM_BUFFER_BINDING = 0x8A28;
pub const UNIFORM_BUFFER_START = 0x8A29;
pub const UNIFORM_BUFFER_SIZE = 0x8A2A;
pub const MAX_VERTEX_UNIFORM_BLOCKS = 0x8A2B;
pub const MAX_GEOMETRY_UNIFORM_BLOCKS = 0x8A2C;
pub const MAX_GEOMETRY_UNIFORM_BLOCKS_EXT = 0x8A2C;
pub const MAX_GEOMETRY_UNIFORM_BLOCKS_OES = 0x8A2C;
pub const MAX_FRAGMENT_UNIFORM_BLOCKS = 0x8A2D;
pub const MAX_COMBINED_UNIFORM_BLOCKS = 0x8A2E;
pub const MAX_UNIFORM_BUFFER_BINDINGS = 0x8A2F;
pub const MAX_UNIFORM_BLOCK_SIZE = 0x8A30;
pub const MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 0x8A31;
pub const MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS = 0x8A32;
pub const MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS_EXT = 0x8A32;
pub const MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS_OES = 0x8A32;
pub const MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 0x8A33;
pub const UNIFORM_BUFFER_OFFSET_ALIGNMENT = 0x8A34;
pub const ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH = 0x8A35;
pub const ACTIVE_UNIFORM_BLOCKS = 0x8A36;
pub const UNIFORM_TYPE = 0x8A37;
pub const UNIFORM_SIZE = 0x8A38;
pub const UNIFORM_NAME_LENGTH = 0x8A39;
pub const UNIFORM_BLOCK_INDEX = 0x8A3A;
pub const UNIFORM_OFFSET = 0x8A3B;
pub const UNIFORM_ARRAY_STRIDE = 0x8A3C;
pub const UNIFORM_MATRIX_STRIDE = 0x8A3D;
pub const UNIFORM_IS_ROW_MAJOR = 0x8A3E;
pub const UNIFORM_BLOCK_BINDING = 0x8A3F;
pub const UNIFORM_BLOCK_DATA_SIZE = 0x8A40;
pub const UNIFORM_BLOCK_NAME_LENGTH = 0x8A41;
pub const UNIFORM_BLOCK_ACTIVE_UNIFORMS = 0x8A42;
pub const UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 0x8A43;
pub const UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 0x8A44;
pub const UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER = 0x8A45;
pub const UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 0x8A46;
pub const TEXTURE_SRGB_DECODE_EXT = 0x8A48;
pub const DECODE_EXT = 0x8A49;
pub const SKIP_DECODE_EXT = 0x8A4A;
pub const PROGRAM_PIPELINE_OBJECT_EXT = 0x8A4F;
pub const RGB_RAW_422_APPLE = 0x8A51;
pub const FRAGMENT_SHADER_DISCARDS_SAMPLES_EXT = 0x8A52;
pub const SYNC_OBJECT_APPLE = 0x8A53;
pub const COMPRESSED_SRGB_PVRTC_2BPPV1_EXT = 0x8A54;
pub const COMPRESSED_SRGB_PVRTC_4BPPV1_EXT = 0x8A55;
pub const COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV1_EXT = 0x8A56;
pub const COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV1_EXT = 0x8A57;
pub const FRAGMENT_SHADER = 0x8B30;
pub const FRAGMENT_SHADER_ARB = 0x8B30;
pub const VERTEX_SHADER = 0x8B31;
pub const VERTEX_SHADER_ARB = 0x8B31;
pub const PROGRAM_OBJECT_ARB = 0x8B40;
pub const PROGRAM_OBJECT_EXT = 0x8B40;
pub const SHADER_OBJECT_ARB = 0x8B48;
pub const SHADER_OBJECT_EXT = 0x8B48;
pub const MAX_FRAGMENT_UNIFORM_COMPONENTS = 0x8B49;
pub const MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB = 0x8B49;
pub const MAX_VERTEX_UNIFORM_COMPONENTS = 0x8B4A;
pub const MAX_VERTEX_UNIFORM_COMPONENTS_ARB = 0x8B4A;
pub const MAX_VARYING_FLOATS = 0x8B4B;
pub const MAX_VARYING_COMPONENTS = 0x8B4B;
pub const MAX_VARYING_COMPONENTS_EXT = 0x8B4B;
pub const MAX_VARYING_FLOATS_ARB = 0x8B4B;
pub const MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C;
pub const MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB = 0x8B4C;
pub const MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;
pub const MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB = 0x8B4D;
pub const OBJECT_TYPE_ARB = 0x8B4E;
pub const SHADER_TYPE = 0x8B4F;
pub const OBJECT_SUBTYPE_ARB = 0x8B4F;
pub const FLOAT_VEC2 = 0x8B50;
pub const FLOAT_VEC2_ARB = 0x8B50;
pub const FLOAT_VEC3 = 0x8B51;
pub const FLOAT_VEC3_ARB = 0x8B51;
pub const FLOAT_VEC4 = 0x8B52;
pub const FLOAT_VEC4_ARB = 0x8B52;
pub const INT_VEC2 = 0x8B53;
pub const INT_VEC2_ARB = 0x8B53;
pub const INT_VEC3 = 0x8B54;
pub const INT_VEC3_ARB = 0x8B54;
pub const INT_VEC4 = 0x8B55;
pub const INT_VEC4_ARB = 0x8B55;
pub const BOOL = 0x8B56;
pub const BOOL_ARB = 0x8B56;
pub const BOOL_VEC2 = 0x8B57;
pub const BOOL_VEC2_ARB = 0x8B57;
pub const BOOL_VEC3 = 0x8B58;
pub const BOOL_VEC3_ARB = 0x8B58;
pub const BOOL_VEC4 = 0x8B59;
pub const BOOL_VEC4_ARB = 0x8B59;
pub const FLOAT_MAT2 = 0x8B5A;
pub const FLOAT_MAT2_ARB = 0x8B5A;
pub const FLOAT_MAT3 = 0x8B5B;
pub const FLOAT_MAT3_ARB = 0x8B5B;
pub const FLOAT_MAT4 = 0x8B5C;
pub const FLOAT_MAT4_ARB = 0x8B5C;
pub const SAMPLER_1D = 0x8B5D;
pub const SAMPLER_1D_ARB = 0x8B5D;
pub const SAMPLER_2D = 0x8B5E;
pub const SAMPLER_2D_ARB = 0x8B5E;
pub const SAMPLER_3D = 0x8B5F;
pub const SAMPLER_3D_ARB = 0x8B5F;
pub const SAMPLER_3D_OES = 0x8B5F;
pub const SAMPLER_CUBE = 0x8B60;
pub const SAMPLER_CUBE_ARB = 0x8B60;
pub const SAMPLER_1D_SHADOW = 0x8B61;
pub const SAMPLER_1D_SHADOW_ARB = 0x8B61;
pub const SAMPLER_2D_SHADOW = 0x8B62;
pub const SAMPLER_2D_SHADOW_ARB = 0x8B62;
pub const SAMPLER_2D_SHADOW_EXT = 0x8B62;
pub const SAMPLER_2D_RECT = 0x8B63;
pub const SAMPLER_2D_RECT_ARB = 0x8B63;
pub const SAMPLER_2D_RECT_SHADOW = 0x8B64;
pub const SAMPLER_2D_RECT_SHADOW_ARB = 0x8B64;
pub const FLOAT_MAT2x3 = 0x8B65;
pub const FLOAT_MAT2x3_NV = 0x8B65;
pub const FLOAT_MAT2x4 = 0x8B66;
pub const FLOAT_MAT2x4_NV = 0x8B66;
pub const FLOAT_MAT3x2 = 0x8B67;
pub const FLOAT_MAT3x2_NV = 0x8B67;
pub const FLOAT_MAT3x4 = 0x8B68;
pub const FLOAT_MAT3x4_NV = 0x8B68;
pub const FLOAT_MAT4x2 = 0x8B69;
pub const FLOAT_MAT4x2_NV = 0x8B69;
pub const FLOAT_MAT4x3 = 0x8B6A;
pub const FLOAT_MAT4x3_NV = 0x8B6A;
pub const DELETE_STATUS = 0x8B80;
pub const OBJECT_DELETE_STATUS_ARB = 0x8B80;
pub const COMPILE_STATUS = 0x8B81;
pub const OBJECT_COMPILE_STATUS_ARB = 0x8B81;
pub const LINK_STATUS = 0x8B82;
pub const OBJECT_LINK_STATUS_ARB = 0x8B82;
pub const VALIDATE_STATUS = 0x8B83;
pub const OBJECT_VALIDATE_STATUS_ARB = 0x8B83;
pub const INFO_LOG_LENGTH = 0x8B84;
pub const OBJECT_INFO_LOG_LENGTH_ARB = 0x8B84;
pub const ATTACHED_SHADERS = 0x8B85;
pub const OBJECT_ATTACHED_OBJECTS_ARB = 0x8B85;
pub const ACTIVE_UNIFORMS = 0x8B86;
pub const OBJECT_ACTIVE_UNIFORMS_ARB = 0x8B86;
pub const ACTIVE_UNIFORM_MAX_LENGTH = 0x8B87;
pub const OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB = 0x8B87;
pub const SHADER_SOURCE_LENGTH = 0x8B88;
pub const OBJECT_SHADER_SOURCE_LENGTH_ARB = 0x8B88;
pub const ACTIVE_ATTRIBUTES = 0x8B89;
pub const OBJECT_ACTIVE_ATTRIBUTES_ARB = 0x8B89;
pub const ACTIVE_ATTRIBUTE_MAX_LENGTH = 0x8B8A;
pub const OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB = 0x8B8A;
pub const FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8B8B;
pub const FRAGMENT_SHADER_DERIVATIVE_HINT_ARB = 0x8B8B;
pub const FRAGMENT_SHADER_DERIVATIVE_HINT_OES = 0x8B8B;
pub const SHADING_LANGUAGE_VERSION = 0x8B8C;
pub const SHADING_LANGUAGE_VERSION_ARB = 0x8B8C;
pub const CURRENT_PROGRAM = 0x8B8D;
// pub const ACTIVE_PROGRAM_EXT = 0x8B8D;
pub const PALETTE4_RGB8_OES = 0x8B90;
pub const PALETTE4_RGBA8_OES = 0x8B91;
pub const PALETTE4_R5_G6_B5_OES = 0x8B92;
pub const PALETTE4_RGBA4_OES = 0x8B93;
pub const PALETTE4_RGB5_A1_OES = 0x8B94;
pub const PALETTE8_RGB8_OES = 0x8B95;
pub const PALETTE8_RGBA8_OES = 0x8B96;
pub const PALETTE8_R5_G6_B5_OES = 0x8B97;
pub const PALETTE8_RGBA4_OES = 0x8B98;
pub const PALETTE8_RGB5_A1_OES = 0x8B99;
pub const IMPLEMENTATION_COLOR_READ_TYPE = 0x8B9A;
pub const IMPLEMENTATION_COLOR_READ_TYPE_OES = 0x8B9A;
pub const IMPLEMENTATION_COLOR_READ_FORMAT = 0x8B9B;
pub const IMPLEMENTATION_COLOR_READ_FORMAT_OES = 0x8B9B;
pub const POINT_SIZE_ARRAY_OES = 0x8B9C;
pub const TEXTURE_CROP_RECT_OES = 0x8B9D;
pub const MATRIX_INDEX_ARRAY_BUFFER_BINDING_OES = 0x8B9E;
pub const POINT_SIZE_ARRAY_BUFFER_BINDING_OES = 0x8B9F;
pub const FRAGMENT_PROGRAM_POSITION_MESA = 0x8BB0;
pub const FRAGMENT_PROGRAM_CALLBACK_MESA = 0x8BB1;
pub const FRAGMENT_PROGRAM_CALLBACK_FUNC_MESA = 0x8BB2;
pub const FRAGMENT_PROGRAM_CALLBACK_DATA_MESA = 0x8BB3;
pub const VERTEX_PROGRAM_POSITION_MESA = 0x8BB4;
pub const VERTEX_PROGRAM_CALLBACK_MESA = 0x8BB5;
pub const VERTEX_PROGRAM_CALLBACK_FUNC_MESA = 0x8BB6;
pub const VERTEX_PROGRAM_CALLBACK_DATA_MESA = 0x8BB7;
pub const TILE_RASTER_ORDER_FIXED_MESA = 0x8BB8;
pub const TILE_RASTER_ORDER_INCREASING_X_MESA = 0x8BB9;
pub const TILE_RASTER_ORDER_INCREASING_Y_MESA = 0x8BBA;
pub const FRAMEBUFFER_FLIP_Y_MESA = 0x8BBB;
pub const FRAMEBUFFER_FLIP_X_MESA = 0x8BBC;
pub const FRAMEBUFFER_SWAP_XY_MESA = 0x8BBD;
pub const COUNTER_TYPE_AMD = 0x8BC0;
pub const COUNTER_RANGE_AMD = 0x8BC1;
pub const UNSIGNED_INT64_AMD = 0x8BC2;
pub const PERCENTAGE_AMD = 0x8BC3;
pub const PERFMON_RESULT_AVAILABLE_AMD = 0x8BC4;
pub const PERFMON_RESULT_SIZE_AMD = 0x8BC5;
pub const PERFMON_RESULT_AMD = 0x8BC6;
pub const TEXTURE_WIDTH_QCOM = 0x8BD2;
pub const TEXTURE_HEIGHT_QCOM = 0x8BD3;
pub const TEXTURE_DEPTH_QCOM = 0x8BD4;
pub const TEXTURE_INTERNAL_FORMAT_QCOM = 0x8BD5;
pub const TEXTURE_FORMAT_QCOM = 0x8BD6;
pub const TEXTURE_TYPE_QCOM = 0x8BD7;
pub const TEXTURE_IMAGE_VALID_QCOM = 0x8BD8;
pub const TEXTURE_NUM_LEVELS_QCOM = 0x8BD9;
pub const TEXTURE_TARGET_QCOM = 0x8BDA;
pub const TEXTURE_OBJECT_VALID_QCOM = 0x8BDB;
pub const STATE_RESTORE = 0x8BDC;
pub const SAMPLER_EXTERNAL_2D_Y2Y_EXT = 0x8BE7;
pub const TEXTURE_PROTECTED_EXT = 0x8BFA;
pub const TEXTURE_FOVEATED_FEATURE_BITS_QCOM = 0x8BFB;
pub const TEXTURE_FOVEATED_MIN_PIXEL_DENSITY_QCOM = 0x8BFC;
pub const TEXTURE_FOVEATED_FEATURE_QUERY_QCOM = 0x8BFD;
pub const TEXTURE_FOVEATED_NUM_FOCAL_POINTS_QUERY_QCOM = 0x8BFE;
pub const FRAMEBUFFER_INCOMPLETE_FOVEATION_QCOM = 0x8BFF;
pub const COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00;
pub const COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01;
pub const COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02;
pub const COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03;
pub const MODULATE_COLOR_IMG = 0x8C04;
pub const RECIP_ADD_SIGNED_ALPHA_IMG = 0x8C05;
pub const TEXTURE_ALPHA_MODULATE_IMG = 0x8C06;
pub const FACTOR_ALPHA_MODULATE_IMG = 0x8C07;
pub const FRAGMENT_ALPHA_MODULATE_IMG = 0x8C08;
pub const ADD_BLEND_IMG = 0x8C09;
pub const SGX_BINARY_IMG = 0x8C0A;
pub const TEXTURE_RED_TYPE = 0x8C10;
pub const TEXTURE_RED_TYPE_ARB = 0x8C10;
pub const TEXTURE_GREEN_TYPE = 0x8C11;
pub const TEXTURE_GREEN_TYPE_ARB = 0x8C11;
pub const TEXTURE_BLUE_TYPE = 0x8C12;
pub const TEXTURE_BLUE_TYPE_ARB = 0x8C12;
pub const TEXTURE_ALPHA_TYPE = 0x8C13;
pub const TEXTURE_ALPHA_TYPE_ARB = 0x8C13;
pub const TEXTURE_LUMINANCE_TYPE = 0x8C14;
pub const TEXTURE_LUMINANCE_TYPE_ARB = 0x8C14;
pub const TEXTURE_INTENSITY_TYPE = 0x8C15;
pub const TEXTURE_INTENSITY_TYPE_ARB = 0x8C15;
pub const TEXTURE_DEPTH_TYPE = 0x8C16;
pub const TEXTURE_DEPTH_TYPE_ARB = 0x8C16;
pub const UNSIGNED_NORMALIZED = 0x8C17;
pub const UNSIGNED_NORMALIZED_ARB = 0x8C17;
pub const UNSIGNED_NORMALIZED_EXT = 0x8C17;
pub const TEXTURE_1D_ARRAY = 0x8C18;
pub const TEXTURE_1D_ARRAY_EXT = 0x8C18;
pub const PROXY_TEXTURE_1D_ARRAY = 0x8C19;
pub const PROXY_TEXTURE_1D_ARRAY_EXT = 0x8C19;
pub const TEXTURE_2D_ARRAY = 0x8C1A;
pub const TEXTURE_2D_ARRAY_EXT = 0x8C1A;
pub const PROXY_TEXTURE_2D_ARRAY = 0x8C1B;
pub const PROXY_TEXTURE_2D_ARRAY_EXT = 0x8C1B;
pub const TEXTURE_BINDING_1D_ARRAY = 0x8C1C;
pub const TEXTURE_BINDING_1D_ARRAY_EXT = 0x8C1C;
pub const TEXTURE_BINDING_2D_ARRAY = 0x8C1D;
pub const TEXTURE_BINDING_2D_ARRAY_EXT = 0x8C1D;
pub const GEOMETRY_PROGRAM_NV = 0x8C26;
pub const MAX_PROGRAM_OUTPUT_VERTICES_NV = 0x8C27;
pub const MAX_PROGRAM_TOTAL_OUTPUT_COMPONENTS_NV = 0x8C28;
pub const MAX_GEOMETRY_TEXTURE_IMAGE_UNITS = 0x8C29;
pub const MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_ARB = 0x8C29;
pub const MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_EXT = 0x8C29;
pub const MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_OES = 0x8C29;
pub const TEXTURE_BUFFER = 0x8C2A;
pub const TEXTURE_BUFFER_ARB = 0x8C2A;
pub const TEXTURE_BUFFER_EXT = 0x8C2A;
pub const TEXTURE_BUFFER_OES = 0x8C2A;
pub const TEXTURE_BUFFER_BINDING = 0x8C2A;
pub const TEXTURE_BUFFER_BINDING_EXT = 0x8C2A;
pub const TEXTURE_BUFFER_BINDING_OES = 0x8C2A;
pub const MAX_TEXTURE_BUFFER_SIZE = 0x8C2B;
pub const MAX_TEXTURE_BUFFER_SIZE_ARB = 0x8C2B;
pub const MAX_TEXTURE_BUFFER_SIZE_EXT = 0x8C2B;
pub const MAX_TEXTURE_BUFFER_SIZE_OES = 0x8C2B;
pub const TEXTURE_BINDING_BUFFER = 0x8C2C;
pub const TEXTURE_BINDING_BUFFER_ARB = 0x8C2C;
pub const TEXTURE_BINDING_BUFFER_EXT = 0x8C2C;
pub const TEXTURE_BINDING_BUFFER_OES = 0x8C2C;
pub const TEXTURE_BUFFER_DATA_STORE_BINDING = 0x8C2D;
pub const TEXTURE_BUFFER_DATA_STORE_BINDING_ARB = 0x8C2D;
pub const TEXTURE_BUFFER_DATA_STORE_BINDING_EXT = 0x8C2D;
pub const TEXTURE_BUFFER_DATA_STORE_BINDING_OES = 0x8C2D;
pub const TEXTURE_BUFFER_FORMAT_ARB = 0x8C2E;
pub const TEXTURE_BUFFER_FORMAT_EXT = 0x8C2E;
pub const ANY_SAMPLES_PASSED = 0x8C2F;
pub const ANY_SAMPLES_PASSED_EXT = 0x8C2F;
pub const SAMPLE_SHADING = 0x8C36;
pub const SAMPLE_SHADING_ARB = 0x8C36;
pub const SAMPLE_SHADING_OES = 0x8C36;
pub const MIN_SAMPLE_SHADING_VALUE = 0x8C37;
pub const MIN_SAMPLE_SHADING_VALUE_ARB = 0x8C37;
pub const MIN_SAMPLE_SHADING_VALUE_OES = 0x8C37;
pub const R11F_G11F_B10F = 0x8C3A;
pub const R11F_G11F_B10F_APPLE = 0x8C3A;
pub const R11F_G11F_B10F_EXT = 0x8C3A;
pub const UNSIGNED_INT_10F_11F_11F_REV = 0x8C3B;
pub const UNSIGNED_INT_10F_11F_11F_REV_APPLE = 0x8C3B;
pub const UNSIGNED_INT_10F_11F_11F_REV_EXT = 0x8C3B;
pub const RGBA_SIGNED_COMPONENTS_EXT = 0x8C3C;
pub const RGB9_E5 = 0x8C3D;
pub const RGB9_E5_APPLE = 0x8C3D;
pub const RGB9_E5_EXT = 0x8C3D;
pub const UNSIGNED_INT_5_9_9_9_REV = 0x8C3E;
pub const UNSIGNED_INT_5_9_9_9_REV_APPLE = 0x8C3E;
pub const UNSIGNED_INT_5_9_9_9_REV_EXT = 0x8C3E;
pub const TEXTURE_SHARED_SIZE = 0x8C3F;
pub const TEXTURE_SHARED_SIZE_EXT = 0x8C3F;
pub const SRGB = 0x8C40;
pub const SRGB_EXT = 0x8C40;
pub const SRGB8 = 0x8C41;
pub const SRGB8_EXT = 0x8C41;
pub const SRGB8_NV = 0x8C41;
pub const SRGB_ALPHA = 0x8C42;
pub const SRGB_ALPHA_EXT = 0x8C42;
pub const SRGB8_ALPHA8 = 0x8C43;
pub const SRGB8_ALPHA8_EXT = 0x8C43;
pub const SLUMINANCE_ALPHA = 0x8C44;
pub const SLUMINANCE_ALPHA_EXT = 0x8C44;
pub const SLUMINANCE_ALPHA_NV = 0x8C44;
pub const SLUMINANCE8_ALPHA8 = 0x8C45;
pub const SLUMINANCE8_ALPHA8_EXT = 0x8C45;
pub const SLUMINANCE8_ALPHA8_NV = 0x8C45;
pub const SLUMINANCE = 0x8C46;
pub const SLUMINANCE_EXT = 0x8C46;
pub const SLUMINANCE_NV = 0x8C46;
pub const SLUMINANCE8 = 0x8C47;
pub const SLUMINANCE8_EXT = 0x8C47;
pub const SLUMINANCE8_NV = 0x8C47;
pub const COMPRESSED_SRGB = 0x8C48;
pub const COMPRESSED_SRGB_EXT = 0x8C48;
pub const COMPRESSED_SRGB_ALPHA = 0x8C49;
pub const COMPRESSED_SRGB_ALPHA_EXT = 0x8C49;
pub const COMPRESSED_SLUMINANCE = 0x8C4A;
pub const COMPRESSED_SLUMINANCE_EXT = 0x8C4A;
pub const COMPRESSED_SLUMINANCE_ALPHA = 0x8C4B;
pub const COMPRESSED_SLUMINANCE_ALPHA_EXT = 0x8C4B;
pub const COMPRESSED_SRGB_S3TC_DXT1_EXT = 0x8C4C;
pub const COMPRESSED_SRGB_S3TC_DXT1_NV = 0x8C4C;
pub const COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 0x8C4D;
pub const COMPRESSED_SRGB_ALPHA_S3TC_DXT1_NV = 0x8C4D;
pub const COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 0x8C4E;
pub const COMPRESSED_SRGB_ALPHA_S3TC_DXT3_NV = 0x8C4E;
pub const COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 0x8C4F;
pub const COMPRESSED_SRGB_ALPHA_S3TC_DXT5_NV = 0x8C4F;
pub const COMPRESSED_LUMINANCE_LATC1_EXT = 0x8C70;
pub const COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT = 0x8C71;
pub const COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT = 0x8C72;
pub const COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT = 0x8C73;
pub const TESS_CONTROL_PROGRAM_PARAMETER_BUFFER_NV = 0x8C74;
pub const TESS_EVALUATION_PROGRAM_PARAMETER_BUFFER_NV = 0x8C75;
pub const TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH = 0x8C76;
pub const TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH_EXT = 0x8C76;
pub const BACK_PRIMARY_COLOR_NV = 0x8C77;
pub const BACK_SECONDARY_COLOR_NV = 0x8C78;
pub const TEXTURE_COORD_NV = 0x8C79;
pub const CLIP_DISTANCE_NV = 0x8C7A;
pub const VERTEX_ID_NV = 0x8C7B;
pub const PRIMITIVE_ID_NV = 0x8C7C;
pub const GENERIC_ATTRIB_NV = 0x8C7D;
pub const TRANSFORM_FEEDBACK_ATTRIBS_NV = 0x8C7E;
pub const TRANSFORM_FEEDBACK_BUFFER_MODE = 0x8C7F;
pub const TRANSFORM_FEEDBACK_BUFFER_MODE_EXT = 0x8C7F;
pub const TRANSFORM_FEEDBACK_BUFFER_MODE_NV = 0x8C7F;
pub const MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 0x8C80;
pub const MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_EXT = 0x8C80;
pub const MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_NV = 0x8C80;
pub const ACTIVE_VARYINGS_NV = 0x8C81;
pub const ACTIVE_VARYING_MAX_LENGTH_NV = 0x8C82;
pub const TRANSFORM_FEEDBACK_VARYINGS = 0x8C83;
pub const TRANSFORM_FEEDBACK_VARYINGS_EXT = 0x8C83;
pub const TRANSFORM_FEEDBACK_VARYINGS_NV = 0x8C83;
pub const TRANSFORM_FEEDBACK_BUFFER_START = 0x8C84;
pub const TRANSFORM_FEEDBACK_BUFFER_START_EXT = 0x8C84;
pub const TRANSFORM_FEEDBACK_BUFFER_START_NV = 0x8C84;
pub const TRANSFORM_FEEDBACK_BUFFER_SIZE = 0x8C85;
pub const TRANSFORM_FEEDBACK_BUFFER_SIZE_EXT = 0x8C85;
pub const TRANSFORM_FEEDBACK_BUFFER_SIZE_NV = 0x8C85;
pub const TRANSFORM_FEEDBACK_RECORD_NV = 0x8C86;
pub const PRIMITIVES_GENERATED = 0x8C87;
pub const PRIMITIVES_GENERATED_EXT = 0x8C87;
pub const PRIMITIVES_GENERATED_NV = 0x8C87;
pub const PRIMITIVES_GENERATED_OES = 0x8C87;
pub const TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8C88;
pub const TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_EXT = 0x8C88;
pub const TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_NV = 0x8C88;
pub const RASTERIZER_DISCARD = 0x8C89;
pub const RASTERIZER_DISCARD_EXT = 0x8C89;
pub const RASTERIZER_DISCARD_NV = 0x8C89;
pub const MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 0x8C8A;
pub const MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS_EXT = 0x8C8A;
pub const MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS_NV = 0x8C8A;
pub const MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 0x8C8B;
pub const MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_EXT = 0x8C8B;
pub const MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_NV = 0x8C8B;
pub const INTERLEAVED_ATTRIBS = 0x8C8C;
pub const INTERLEAVED_ATTRIBS_EXT = 0x8C8C;
pub const INTERLEAVED_ATTRIBS_NV = 0x8C8C;
pub const SEPARATE_ATTRIBS = 0x8C8D;
pub const SEPARATE_ATTRIBS_EXT = 0x8C8D;
pub const SEPARATE_ATTRIBS_NV = 0x8C8D;
pub const TRANSFORM_FEEDBACK_BUFFER = 0x8C8E;
pub const TRANSFORM_FEEDBACK_BUFFER_EXT = 0x8C8E;
pub const TRANSFORM_FEEDBACK_BUFFER_NV = 0x8C8E;
pub const TRANSFORM_FEEDBACK_BUFFER_BINDING = 0x8C8F;
pub const TRANSFORM_FEEDBACK_BUFFER_BINDING_EXT = 0x8C8F;
pub const TRANSFORM_FEEDBACK_BUFFER_BINDING_NV = 0x8C8F;
pub const MOTION_ESTIMATION_SEARCH_BLOCK_X_QCOM = 0x8C90;
pub const MOTION_ESTIMATION_SEARCH_BLOCK_Y_QCOM = 0x8C91;
pub const ATC_RGB_AMD = 0x8C92;
pub const ATC_RGBA_EXPLICIT_ALPHA_AMD = 0x8C93;
pub const POINT_SPRITE_COORD_ORIGIN = 0x8CA0;
pub const LOWER_LEFT = 0x8CA1;
pub const LOWER_LEFT_EXT = 0x8CA1;
pub const UPPER_LEFT = 0x8CA2;
pub const UPPER_LEFT_EXT = 0x8CA2;
pub const STENCIL_BACK_REF = 0x8CA3;
pub const STENCIL_BACK_VALUE_MASK = 0x8CA4;
pub const STENCIL_BACK_WRITEMASK = 0x8CA5;
pub const DRAW_FRAMEBUFFER_BINDING = 0x8CA6;
pub const DRAW_FRAMEBUFFER_BINDING_ANGLE = 0x8CA6;
pub const DRAW_FRAMEBUFFER_BINDING_APPLE = 0x8CA6;
pub const DRAW_FRAMEBUFFER_BINDING_EXT = 0x8CA6;
pub const DRAW_FRAMEBUFFER_BINDING_NV = 0x8CA6;
pub const FRAMEBUFFER_BINDING = 0x8CA6;
pub const FRAMEBUFFER_BINDING_ANGLE = 0x8CA6;
pub const FRAMEBUFFER_BINDING_EXT = 0x8CA6;
pub const FRAMEBUFFER_BINDING_OES = 0x8CA6;
pub const RENDERBUFFER_BINDING = 0x8CA7;
pub const RENDERBUFFER_BINDING_ANGLE = 0x8CA7;
pub const RENDERBUFFER_BINDING_EXT = 0x8CA7;
pub const RENDERBUFFER_BINDING_OES = 0x8CA7;
pub const READ_FRAMEBUFFER = 0x8CA8;
pub const READ_FRAMEBUFFER_ANGLE = 0x8CA8;
pub const READ_FRAMEBUFFER_APPLE = 0x8CA8;
pub const READ_FRAMEBUFFER_EXT = 0x8CA8;
pub const READ_FRAMEBUFFER_NV = 0x8CA8;
pub const DRAW_FRAMEBUFFER = 0x8CA9;
pub const DRAW_FRAMEBUFFER_ANGLE = 0x8CA9;
pub const DRAW_FRAMEBUFFER_APPLE = 0x8CA9;
pub const DRAW_FRAMEBUFFER_EXT = 0x8CA9;
pub const DRAW_FRAMEBUFFER_NV = 0x8CA9;
pub const READ_FRAMEBUFFER_BINDING = 0x8CAA;
pub const READ_FRAMEBUFFER_BINDING_ANGLE = 0x8CAA;
pub const READ_FRAMEBUFFER_BINDING_APPLE = 0x8CAA;
pub const READ_FRAMEBUFFER_BINDING_EXT = 0x8CAA;
pub const READ_FRAMEBUFFER_BINDING_NV = 0x8CAA;
pub const RENDERBUFFER_COVERAGE_SAMPLES_NV = 0x8CAB;
pub const RENDERBUFFER_SAMPLES = 0x8CAB;
pub const RENDERBUFFER_SAMPLES_ANGLE = 0x8CAB;
pub const RENDERBUFFER_SAMPLES_APPLE = 0x8CAB;
pub const RENDERBUFFER_SAMPLES_EXT = 0x8CAB;
pub const RENDERBUFFER_SAMPLES_NV = 0x8CAB;
pub const DEPTH_COMPONENT32F = 0x8CAC;
pub const DEPTH32F_STENCIL8 = 0x8CAD;
pub const FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0;
pub const FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT = 0x8CD0;
pub const FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_OES = 0x8CD0;
pub const FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1;
pub const FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT = 0x8CD1;
pub const FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_OES = 0x8CD1;
pub const FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2;
pub const FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT = 0x8CD2;
pub const FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_OES = 0x8CD2;
pub const FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;
pub const FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT = 0x8CD3;
pub const FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_OES = 0x8CD3;
pub const FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT = 0x8CD4;
pub const FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_OES = 0x8CD4;
pub const FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 0x8CD4;
pub const FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT = 0x8CD4;
pub const FRAMEBUFFER_COMPLETE = 0x8CD5;
pub const FRAMEBUFFER_COMPLETE_EXT = 0x8CD5;
pub const FRAMEBUFFER_COMPLETE_OES = 0x8CD5;
pub const FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6;
pub const FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT = 0x8CD6;
pub const FRAMEBUFFER_INCOMPLETE_ATTACHMENT_OES = 0x8CD6;
pub const FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;
pub const FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT = 0x8CD7;
pub const FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_OES = 0x8CD7;
pub const FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9;
pub const FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT = 0x8CD9;
pub const FRAMEBUFFER_INCOMPLETE_DIMENSIONS_OES = 0x8CD9;
pub const FRAMEBUFFER_INCOMPLETE_FORMATS_EXT = 0x8CDA;
pub const FRAMEBUFFER_INCOMPLETE_FORMATS_OES = 0x8CDA;
pub const FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER = 0x8CDB;
pub const FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT = 0x8CDB;
pub const FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_OES = 0x8CDB;
pub const FRAMEBUFFER_INCOMPLETE_READ_BUFFER = 0x8CDC;
pub const FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT = 0x8CDC;
pub const FRAMEBUFFER_INCOMPLETE_READ_BUFFER_OES = 0x8CDC;
pub const FRAMEBUFFER_UNSUPPORTED = 0x8CDD;
pub const FRAMEBUFFER_UNSUPPORTED_EXT = 0x8CDD;
pub const FRAMEBUFFER_UNSUPPORTED_OES = 0x8CDD;
pub const MAX_COLOR_ATTACHMENTS = 0x8CDF;
pub const MAX_COLOR_ATTACHMENTS_EXT = 0x8CDF;
pub const MAX_COLOR_ATTACHMENTS_NV = 0x8CDF;
pub const COLOR_ATTACHMENT0 = 0x8CE0;
pub const COLOR_ATTACHMENT0_EXT = 0x8CE0;
pub const COLOR_ATTACHMENT0_NV = 0x8CE0;
pub const COLOR_ATTACHMENT0_OES = 0x8CE0;
pub const COLOR_ATTACHMENT1 = 0x8CE1;
pub const COLOR_ATTACHMENT1_EXT = 0x8CE1;
pub const COLOR_ATTACHMENT1_NV = 0x8CE1;
pub const COLOR_ATTACHMENT2 = 0x8CE2;
pub const COLOR_ATTACHMENT2_EXT = 0x8CE2;
pub const COLOR_ATTACHMENT2_NV = 0x8CE2;
pub const COLOR_ATTACHMENT3 = 0x8CE3;
pub const COLOR_ATTACHMENT3_EXT = 0x8CE3;
pub const COLOR_ATTACHMENT3_NV = 0x8CE3;
pub const COLOR_ATTACHMENT4 = 0x8CE4;
pub const COLOR_ATTACHMENT4_EXT = 0x8CE4;
pub const COLOR_ATTACHMENT4_NV = 0x8CE4;
pub const COLOR_ATTACHMENT5 = 0x8CE5;
pub const COLOR_ATTACHMENT5_EXT = 0x8CE5;
pub const COLOR_ATTACHMENT5_NV = 0x8CE5;
pub const COLOR_ATTACHMENT6 = 0x8CE6;
pub const COLOR_ATTACHMENT6_EXT = 0x8CE6;
pub const COLOR_ATTACHMENT6_NV = 0x8CE6;
pub const COLOR_ATTACHMENT7 = 0x8CE7;
pub const COLOR_ATTACHMENT7_EXT = 0x8CE7;
pub const COLOR_ATTACHMENT7_NV = 0x8CE7;
pub const COLOR_ATTACHMENT8 = 0x8CE8;
pub const COLOR_ATTACHMENT8_EXT = 0x8CE8;
pub const COLOR_ATTACHMENT8_NV = 0x8CE8;
pub const COLOR_ATTACHMENT9 = 0x8CE9;
pub const COLOR_ATTACHMENT9_EXT = 0x8CE9;
pub const COLOR_ATTACHMENT9_NV = 0x8CE9;
pub const COLOR_ATTACHMENT10 = 0x8CEA;
pub const COLOR_ATTACHMENT10_EXT = 0x8CEA;
pub const COLOR_ATTACHMENT10_NV = 0x8CEA;
pub const COLOR_ATTACHMENT11 = 0x8CEB;
pub const COLOR_ATTACHMENT11_EXT = 0x8CEB;
pub const COLOR_ATTACHMENT11_NV = 0x8CEB;
pub const COLOR_ATTACHMENT12 = 0x8CEC;
pub const COLOR_ATTACHMENT12_EXT = 0x8CEC;
pub const COLOR_ATTACHMENT12_NV = 0x8CEC;
pub const COLOR_ATTACHMENT13 = 0x8CED;
pub const COLOR_ATTACHMENT13_EXT = 0x8CED;
pub const COLOR_ATTACHMENT13_NV = 0x8CED;
pub const COLOR_ATTACHMENT14 = 0x8CEE;
pub const COLOR_ATTACHMENT14_EXT = 0x8CEE;
pub const COLOR_ATTACHMENT14_NV = 0x8CEE;
pub const COLOR_ATTACHMENT15 = 0x8CEF;
pub const COLOR_ATTACHMENT15_EXT = 0x8CEF;
pub const COLOR_ATTACHMENT15_NV = 0x8CEF;
pub const COLOR_ATTACHMENT16 = 0x8CF0;
pub const COLOR_ATTACHMENT17 = 0x8CF1;
pub const COLOR_ATTACHMENT18 = 0x8CF2;
pub const COLOR_ATTACHMENT19 = 0x8CF3;
pub const COLOR_ATTACHMENT20 = 0x8CF4;
pub const COLOR_ATTACHMENT21 = 0x8CF5;
pub const COLOR_ATTACHMENT22 = 0x8CF6;
pub const COLOR_ATTACHMENT23 = 0x8CF7;
pub const COLOR_ATTACHMENT24 = 0x8CF8;
pub const COLOR_ATTACHMENT25 = 0x8CF9;
pub const COLOR_ATTACHMENT26 = 0x8CFA;
pub const COLOR_ATTACHMENT27 = 0x8CFB;
pub const COLOR_ATTACHMENT28 = 0x8CFC;
pub const COLOR_ATTACHMENT29 = 0x8CFD;
pub const COLOR_ATTACHMENT30 = 0x8CFE;
pub const COLOR_ATTACHMENT31 = 0x8CFF;
pub const DEPTH_ATTACHMENT = 0x8D00;
pub const DEPTH_ATTACHMENT_EXT = 0x8D00;
pub const DEPTH_ATTACHMENT_OES = 0x8D00;
pub const STENCIL_ATTACHMENT = 0x8D20;
pub const STENCIL_ATTACHMENT_EXT = 0x8D20;
pub const STENCIL_ATTACHMENT_OES = 0x8D20;
pub const FRAMEBUFFER = 0x8D40;
pub const FRAMEBUFFER_EXT = 0x8D40;
pub const FRAMEBUFFER_OES = 0x8D40;
pub const RENDERBUFFER = 0x8D41;
pub const RENDERBUFFER_EXT = 0x8D41;
pub const RENDERBUFFER_OES = 0x8D41;
pub const RENDERBUFFER_WIDTH = 0x8D42;
pub const RENDERBUFFER_WIDTH_EXT = 0x8D42;
pub const RENDERBUFFER_WIDTH_OES = 0x8D42;
pub const RENDERBUFFER_HEIGHT = 0x8D43;
pub const RENDERBUFFER_HEIGHT_EXT = 0x8D43;
pub const RENDERBUFFER_HEIGHT_OES = 0x8D43;
pub const RENDERBUFFER_INTERNAL_FORMAT = 0x8D44;
pub const RENDERBUFFER_INTERNAL_FORMAT_EXT = 0x8D44;
pub const RENDERBUFFER_INTERNAL_FORMAT_OES = 0x8D44;
pub const STENCIL_INDEX1 = 0x8D46;
pub const STENCIL_INDEX1_EXT = 0x8D46;
pub const STENCIL_INDEX1_OES = 0x8D46;
pub const STENCIL_INDEX4 = 0x8D47;
pub const STENCIL_INDEX4_EXT = 0x8D47;
pub const STENCIL_INDEX4_OES = 0x8D47;
pub const STENCIL_INDEX8 = 0x8D48;
pub const STENCIL_INDEX8_EXT = 0x8D48;
pub const STENCIL_INDEX8_OES = 0x8D48;
pub const STENCIL_INDEX16 = 0x8D49;
pub const STENCIL_INDEX16_EXT = 0x8D49;
pub const RENDERBUFFER_RED_SIZE = 0x8D50;
pub const RENDERBUFFER_RED_SIZE_EXT = 0x8D50;
pub const RENDERBUFFER_RED_SIZE_OES = 0x8D50;
pub const RENDERBUFFER_GREEN_SIZE = 0x8D51;
pub const RENDERBUFFER_GREEN_SIZE_EXT = 0x8D51;
pub const RENDERBUFFER_GREEN_SIZE_OES = 0x8D51;
pub const RENDERBUFFER_BLUE_SIZE = 0x8D52;
pub const RENDERBUFFER_BLUE_SIZE_EXT = 0x8D52;
pub const RENDERBUFFER_BLUE_SIZE_OES = 0x8D52;
pub const RENDERBUFFER_ALPHA_SIZE = 0x8D53;
pub const RENDERBUFFER_ALPHA_SIZE_EXT = 0x8D53;
pub const RENDERBUFFER_ALPHA_SIZE_OES = 0x8D53;
pub const RENDERBUFFER_DEPTH_SIZE = 0x8D54;
pub const RENDERBUFFER_DEPTH_SIZE_EXT = 0x8D54;
pub const RENDERBUFFER_DEPTH_SIZE_OES = 0x8D54;
pub const RENDERBUFFER_STENCIL_SIZE = 0x8D55;
pub const RENDERBUFFER_STENCIL_SIZE_EXT = 0x8D55;
pub const RENDERBUFFER_STENCIL_SIZE_OES = 0x8D55;
pub const FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 0x8D56;
pub const FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_ANGLE = 0x8D56;
pub const FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_APPLE = 0x8D56;
pub const FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_EXT = 0x8D56;
pub const FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_NV = 0x8D56;
pub const MAX_SAMPLES = 0x8D57;
pub const MAX_SAMPLES_ANGLE = 0x8D57;
pub const MAX_SAMPLES_APPLE = 0x8D57;
pub const MAX_SAMPLES_EXT = 0x8D57;
pub const MAX_SAMPLES_NV = 0x8D57;
pub const TEXTURE_GEN_STR_OES = 0x8D60;
pub const HALF_FLOAT_OES = 0x8D61;
pub const RGB565_OES = 0x8D62;
pub const RGB565 = 0x8D62;
pub const ETC1_RGB8_OES = 0x8D64;
pub const TEXTURE_EXTERNAL_OES = 0x8D65;
pub const SAMPLER_EXTERNAL_OES = 0x8D66;
pub const TEXTURE_BINDING_EXTERNAL_OES = 0x8D67;
pub const REQUIRED_TEXTURE_IMAGE_UNITS_OES = 0x8D68;
pub const PRIMITIVE_RESTART_FIXED_INDEX = 0x8D69;
pub const ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8D6A;
pub const ANY_SAMPLES_PASSED_CONSERVATIVE_EXT = 0x8D6A;
pub const MAX_ELEMENT_INDEX = 0x8D6B;
pub const FRAMEBUFFER_ATTACHMENT_TEXTURE_SAMPLES_EXT = 0x8D6C;
pub const RGBA32UI = 0x8D70;
pub const RGBA32UI_EXT = 0x8D70;
pub const RGB32UI = 0x8D71;
pub const RGB32UI_EXT = 0x8D71;
pub const ALPHA32UI_EXT = 0x8D72;
pub const INTENSITY32UI_EXT = 0x8D73;
pub const LUMINANCE32UI_EXT = 0x8D74;
pub const LUMINANCE_ALPHA32UI_EXT = 0x8D75;
pub const RGBA16UI = 0x8D76;
pub const RGBA16UI_EXT = 0x8D76;
pub const RGB16UI = 0x8D77;
pub const RGB16UI_EXT = 0x8D77;
pub const ALPHA16UI_EXT = 0x8D78;
pub const INTENSITY16UI_EXT = 0x8D79;
pub const LUMINANCE16UI_EXT = 0x8D7A;
pub const LUMINANCE_ALPHA16UI_EXT = 0x8D7B;
pub const RGBA8UI = 0x8D7C;
pub const RGBA8UI_EXT = 0x8D7C;
pub const RGB8UI = 0x8D7D;
pub const RGB8UI_EXT = 0x8D7D;
pub const ALPHA8UI_EXT = 0x8D7E;
pub const INTENSITY8UI_EXT = 0x8D7F;
pub const LUMINANCE8UI_EXT = 0x8D80;
pub const LUMINANCE_ALPHA8UI_EXT = 0x8D81;
pub const RGBA32I = 0x8D82;
pub const RGBA32I_EXT = 0x8D82;
pub const RGB32I = 0x8D83;
pub const RGB32I_EXT = 0x8D83;
pub const ALPHA32I_EXT = 0x8D84;
pub const INTENSITY32I_EXT = 0x8D85;
pub const LUMINANCE32I_EXT = 0x8D86;
pub const LUMINANCE_ALPHA32I_EXT = 0x8D87;
pub const RGBA16I = 0x8D88;
pub const RGBA16I_EXT = 0x8D88;
pub const RGB16I = 0x8D89;
pub const RGB16I_EXT = 0x8D89;
pub const ALPHA16I_EXT = 0x8D8A;
pub const INTENSITY16I_EXT = 0x8D8B;
pub const LUMINANCE16I_EXT = 0x8D8C;
pub const LUMINANCE_ALPHA16I_EXT = 0x8D8D;
pub const RGBA8I = 0x8D8E;
pub const RGBA8I_EXT = 0x8D8E;
pub const RGB8I = 0x8D8F;
pub const RGB8I_EXT = 0x8D8F;
pub const ALPHA8I_EXT = 0x8D90;
pub const INTENSITY8I_EXT = 0x8D91;
pub const LUMINANCE8I_EXT = 0x8D92;
pub const LUMINANCE_ALPHA8I_EXT = 0x8D93;
pub const RED_INTEGER = 0x8D94;
pub const RED_INTEGER_EXT = 0x8D94;
pub const GREEN_INTEGER = 0x8D95;
pub const GREEN_INTEGER_EXT = 0x8D95;
pub const BLUE_INTEGER = 0x8D96;
pub const BLUE_INTEGER_EXT = 0x8D96;
pub const ALPHA_INTEGER = 0x8D97;
pub const ALPHA_INTEGER_EXT = 0x8D97;
pub const RGB_INTEGER = 0x8D98;
pub const RGB_INTEGER_EXT = 0x8D98;
pub const RGBA_INTEGER = 0x8D99;
pub const RGBA_INTEGER_EXT = 0x8D99;
pub const BGR_INTEGER = 0x8D9A;
pub const BGR_INTEGER_EXT = 0x8D9A;
pub const BGRA_INTEGER = 0x8D9B;
pub const BGRA_INTEGER_EXT = 0x8D9B;
pub const LUMINANCE_INTEGER_EXT = 0x8D9C;
pub const LUMINANCE_ALPHA_INTEGER_EXT = 0x8D9D;
pub const RGBA_INTEGER_MODE_EXT = 0x8D9E;
pub const INT_2_10_10_10_REV = 0x8D9F;
pub const MAX_PROGRAM_PARAMETER_BUFFER_BINDINGS_NV = 0x8DA0;
pub const MAX_PROGRAM_PARAMETER_BUFFER_SIZE_NV = 0x8DA1;
pub const VERTEX_PROGRAM_PARAMETER_BUFFER_NV = 0x8DA2;
pub const GEOMETRY_PROGRAM_PARAMETER_BUFFER_NV = 0x8DA3;
pub const FRAGMENT_PROGRAM_PARAMETER_BUFFER_NV = 0x8DA4;
pub const MAX_PROGRAM_GENERIC_ATTRIBS_NV = 0x8DA5;
pub const MAX_PROGRAM_GENERIC_RESULTS_NV = 0x8DA6;
pub const FRAMEBUFFER_ATTACHMENT_LAYERED = 0x8DA7;
pub const FRAMEBUFFER_ATTACHMENT_LAYERED_ARB = 0x8DA7;
pub const FRAMEBUFFER_ATTACHMENT_LAYERED_EXT = 0x8DA7;
pub const FRAMEBUFFER_ATTACHMENT_LAYERED_OES = 0x8DA7;
pub const FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS = 0x8DA8;
pub const FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_ARB = 0x8DA8;
pub const FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_EXT = 0x8DA8;
pub const FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_OES = 0x8DA8;
pub const FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_ARB = 0x8DA9;
pub const FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_EXT = 0x8DA9;
pub const LAYER_NV = 0x8DAA;
pub const DEPTH_COMPONENT32F_NV = 0x8DAB;
pub const DEPTH32F_STENCIL8_NV = 0x8DAC;
pub const FLOAT_32_UNSIGNED_INT_24_8_REV = 0x8DAD;
pub const FLOAT_32_UNSIGNED_INT_24_8_REV_NV = 0x8DAD;
pub const SHADER_INCLUDE_ARB = 0x8DAE;
pub const DEPTH_BUFFER_FLOAT_MODE_NV = 0x8DAF;
pub const FRAMEBUFFER_SRGB = 0x8DB9;
pub const FRAMEBUFFER_SRGB_EXT = 0x8DB9;
pub const FRAMEBUFFER_SRGB_CAPABLE_EXT = 0x8DBA;
pub const COMPRESSED_RED_RGTC1 = 0x8DBB;
pub const COMPRESSED_RED_RGTC1_EXT = 0x8DBB;
pub const COMPRESSED_SIGNED_RED_RGTC1 = 0x8DBC;
pub const COMPRESSED_SIGNED_RED_RGTC1_EXT = 0x8DBC;
pub const COMPRESSED_RED_GREEN_RGTC2_EXT = 0x8DBD;
pub const COMPRESSED_RG_RGTC2 = 0x8DBD;
pub const COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = 0x8DBE;
pub const COMPRESSED_SIGNED_RG_RGTC2 = 0x8DBE;
pub const SAMPLER_1D_ARRAY = 0x8DC0;
pub const SAMPLER_1D_ARRAY_EXT = 0x8DC0;
pub const SAMPLER_2D_ARRAY = 0x8DC1;
pub const SAMPLER_2D_ARRAY_EXT = 0x8DC1;
pub const SAMPLER_BUFFER = 0x8DC2;
pub const SAMPLER_BUFFER_EXT = 0x8DC2;
pub const SAMPLER_BUFFER_OES = 0x8DC2;
pub const SAMPLER_1D_ARRAY_SHADOW = 0x8DC3;
pub const SAMPLER_1D_ARRAY_SHADOW_EXT = 0x8DC3;
pub const SAMPLER_2D_ARRAY_SHADOW = 0x8DC4;
pub const SAMPLER_2D_ARRAY_SHADOW_EXT = 0x8DC4;
pub const SAMPLER_2D_ARRAY_SHADOW_NV = 0x8DC4;
pub const SAMPLER_CUBE_SHADOW = 0x8DC5;
pub const SAMPLER_CUBE_SHADOW_EXT = 0x8DC5;
pub const SAMPLER_CUBE_SHADOW_NV = 0x8DC5;
pub const UNSIGNED_INT_VEC2 = 0x8DC6;
pub const UNSIGNED_INT_VEC2_EXT = 0x8DC6;
pub const UNSIGNED_INT_VEC3 = 0x8DC7;
pub const UNSIGNED_INT_VEC3_EXT = 0x8DC7;
pub const UNSIGNED_INT_VEC4 = 0x8DC8;
pub const UNSIGNED_INT_VEC4_EXT = 0x8DC8;
pub const INT_SAMPLER_1D = 0x8DC9;
pub const INT_SAMPLER_1D_EXT = 0x8DC9;
pub const INT_SAMPLER_2D = 0x8DCA;
pub const INT_SAMPLER_2D_EXT = 0x8DCA;
pub const INT_SAMPLER_3D = 0x8DCB;
pub const INT_SAMPLER_3D_EXT = 0x8DCB;
pub const INT_SAMPLER_CUBE = 0x8DCC;
pub const INT_SAMPLER_CUBE_EXT = 0x8DCC;
pub const INT_SAMPLER_2D_RECT = 0x8DCD;
pub const INT_SAMPLER_2D_RECT_EXT = 0x8DCD;
pub const INT_SAMPLER_1D_ARRAY = 0x8DCE;
pub const INT_SAMPLER_1D_ARRAY_EXT = 0x8DCE;
pub const INT_SAMPLER_2D_ARRAY = 0x8DCF;
pub const INT_SAMPLER_2D_ARRAY_EXT = 0x8DCF;
pub const INT_SAMPLER_BUFFER = 0x8DD0;
pub const INT_SAMPLER_BUFFER_EXT = 0x8DD0;
pub const INT_SAMPLER_BUFFER_OES = 0x8DD0;
pub const UNSIGNED_INT_SAMPLER_1D = 0x8DD1;
pub const UNSIGNED_INT_SAMPLER_1D_EXT = 0x8DD1;
pub const UNSIGNED_INT_SAMPLER_2D = 0x8DD2;
pub const UNSIGNED_INT_SAMPLER_2D_EXT = 0x8DD2;
pub const UNSIGNED_INT_SAMPLER_3D = 0x8DD3;
pub const UNSIGNED_INT_SAMPLER_3D_EXT = 0x8DD3;
pub const UNSIGNED_INT_SAMPLER_CUBE = 0x8DD4;
pub const UNSIGNED_INT_SAMPLER_CUBE_EXT = 0x8DD4;
pub const UNSIGNED_INT_SAMPLER_2D_RECT = 0x8DD5;
pub const UNSIGNED_INT_SAMPLER_2D_RECT_EXT = 0x8DD5;
pub const UNSIGNED_INT_SAMPLER_1D_ARRAY = 0x8DD6;
pub const UNSIGNED_INT_SAMPLER_1D_ARRAY_EXT = 0x8DD6;
pub const UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7;
pub const UNSIGNED_INT_SAMPLER_2D_ARRAY_EXT = 0x8DD7;
pub const UNSIGNED_INT_SAMPLER_BUFFER = 0x8DD8;
pub const UNSIGNED_INT_SAMPLER_BUFFER_EXT = 0x8DD8;
pub const UNSIGNED_INT_SAMPLER_BUFFER_OES = 0x8DD8;
pub const GEOMETRY_SHADER = 0x8DD9;
pub const GEOMETRY_SHADER_ARB = 0x8DD9;
pub const GEOMETRY_SHADER_EXT = 0x8DD9;
pub const GEOMETRY_SHADER_OES = 0x8DD9;
pub const GEOMETRY_VERTICES_OUT_ARB = 0x8DDA;
pub const GEOMETRY_VERTICES_OUT_EXT = 0x8DDA;
pub const GEOMETRY_INPUT_TYPE_ARB = 0x8DDB;
pub const GEOMETRY_INPUT_TYPE_EXT = 0x8DDB;
pub const GEOMETRY_OUTPUT_TYPE_ARB = 0x8DDC;
pub const GEOMETRY_OUTPUT_TYPE_EXT = 0x8DDC;
pub const MAX_GEOMETRY_VARYING_COMPONENTS_ARB = 0x8DDD;
pub const MAX_GEOMETRY_VARYING_COMPONENTS_EXT = 0x8DDD;
pub const MAX_VERTEX_VARYING_COMPONENTS_ARB = 0x8DDE;
pub const MAX_VERTEX_VARYING_COMPONENTS_EXT = 0x8DDE;
pub const MAX_GEOMETRY_UNIFORM_COMPONENTS = 0x8DDF;
pub const MAX_GEOMETRY_UNIFORM_COMPONENTS_ARB = 0x8DDF;
pub const MAX_GEOMETRY_UNIFORM_COMPONENTS_EXT = 0x8DDF;
pub const MAX_GEOMETRY_UNIFORM_COMPONENTS_OES = 0x8DDF;
pub const MAX_GEOMETRY_OUTPUT_VERTICES = 0x8DE0;
pub const MAX_GEOMETRY_OUTPUT_VERTICES_ARB = 0x8DE0;
pub const MAX_GEOMETRY_OUTPUT_VERTICES_EXT = 0x8DE0;
pub const MAX_GEOMETRY_OUTPUT_VERTICES_OES = 0x8DE0;
pub const MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS = 0x8DE1;
pub const MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_ARB = 0x8DE1;
pub const MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_EXT = 0x8DE1;
pub const MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_OES = 0x8DE1;
pub const MAX_VERTEX_BINDABLE_UNIFORMS_EXT = 0x8DE2;
pub const MAX_FRAGMENT_BINDABLE_UNIFORMS_EXT = 0x8DE3;
pub const MAX_GEOMETRY_BINDABLE_UNIFORMS_EXT = 0x8DE4;
pub const ACTIVE_SUBROUTINES = 0x8DE5;
pub const ACTIVE_SUBROUTINE_UNIFORMS = 0x8DE6;
pub const MAX_SUBROUTINES = 0x8DE7;
pub const MAX_SUBROUTINE_UNIFORM_LOCATIONS = 0x8DE8;
pub const NAMED_STRING_LENGTH_ARB = 0x8DE9;
pub const NAMED_STRING_TYPE_ARB = 0x8DEA;
pub const MAX_BINDABLE_UNIFORM_SIZE_EXT = 0x8DED;
pub const UNIFORM_BUFFER_EXT = 0x8DEE;
pub const UNIFORM_BUFFER_BINDING_EXT = 0x8DEF;
pub const LOW_FLOAT = 0x8DF0;
pub const MEDIUM_FLOAT = 0x8DF1;
pub const HIGH_FLOAT = 0x8DF2;
pub const LOW_INT = 0x8DF3;
pub const MEDIUM_INT = 0x8DF4;
pub const HIGH_INT = 0x8DF5;
pub const UNSIGNED_INT_10_10_10_2_OES = 0x8DF6;
pub const INT_10_10_10_2_OES = 0x8DF7;
pub const SHADER_BINARY_FORMATS = 0x8DF8;
pub const NUM_SHADER_BINARY_FORMATS = 0x8DF9;
pub const SHADER_COMPILER = 0x8DFA;
pub const MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB;
pub const MAX_VARYING_VECTORS = 0x8DFC;
pub const MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD;
pub const RENDERBUFFER_COLOR_SAMPLES_NV = 0x8E10;
pub const MAX_MULTISAMPLE_COVERAGE_MODES_NV = 0x8E11;
pub const MULTISAMPLE_COVERAGE_MODES_NV = 0x8E12;
pub const QUERY_WAIT = 0x8E13;
pub const QUERY_WAIT_NV = 0x8E13;
pub const QUERY_NO_WAIT = 0x8E14;
pub const QUERY_NO_WAIT_NV = 0x8E14;
pub const QUERY_BY_REGION_WAIT = 0x8E15;
pub const QUERY_BY_REGION_WAIT_NV = 0x8E15;
pub const QUERY_BY_REGION_NO_WAIT = 0x8E16;
pub const QUERY_BY_REGION_NO_WAIT_NV = 0x8E16;
pub const QUERY_WAIT_INVERTED = 0x8E17;
pub const QUERY_NO_WAIT_INVERTED = 0x8E18;
pub const QUERY_BY_REGION_WAIT_INVERTED = 0x8E19;
pub const QUERY_BY_REGION_NO_WAIT_INVERTED = 0x8E1A;
pub const POLYGON_OFFSET_CLAMP = 0x8E1B;
pub const POLYGON_OFFSET_CLAMP_EXT = 0x8E1B;
pub const MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS = 0x8E1E;
pub const MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS_EXT = 0x8E1E;
pub const MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS_OES = 0x8E1E;
pub const MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS = 0x8E1F;
pub const MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS_EXT = 0x8E1F;
pub const MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS_OES = 0x8E1F;
pub const COLOR_SAMPLES_NV = 0x8E20;
pub const TRANSFORM_FEEDBACK = 0x8E22;
pub const TRANSFORM_FEEDBACK_NV = 0x8E22;
pub const TRANSFORM_FEEDBACK_BUFFER_PAUSED = 0x8E23;
pub const TRANSFORM_FEEDBACK_PAUSED = 0x8E23;
pub const TRANSFORM_FEEDBACK_BUFFER_PAUSED_NV = 0x8E23;
pub const TRANSFORM_FEEDBACK_BUFFER_ACTIVE = 0x8E24;
pub const TRANSFORM_FEEDBACK_ACTIVE = 0x8E24;
pub const TRANSFORM_FEEDBACK_BUFFER_ACTIVE_NV = 0x8E24;
pub const TRANSFORM_FEEDBACK_BINDING = 0x8E25;
pub const TRANSFORM_FEEDBACK_BINDING_NV = 0x8E25;
pub const FRAME_NV = 0x8E26;
pub const FIELDS_NV = 0x8E27;
pub const CURRENT_TIME_NV = 0x8E28;
pub const TIMESTAMP = 0x8E28;
pub const TIMESTAMP_EXT = 0x8E28;
pub const NUM_FILL_STREAMS_NV = 0x8E29;
pub const PRESENT_TIME_NV = 0x8E2A;
pub const PRESENT_DURATION_NV = 0x8E2B;
pub const DEPTH_COMPONENT16_NONLINEAR_NV = 0x8E2C;
pub const PROGRAM_MATRIX_EXT = 0x8E2D;
pub const TRANSPOSE_PROGRAM_MATRIX_EXT = 0x8E2E;
pub const PROGRAM_MATRIX_STACK_DEPTH_EXT = 0x8E2F;
pub const TEXTURE_SWIZZLE_R = 0x8E42;
pub const TEXTURE_SWIZZLE_R_EXT = 0x8E42;
pub const TEXTURE_SWIZZLE_G = 0x8E43;
pub const TEXTURE_SWIZZLE_G_EXT = 0x8E43;
pub const TEXTURE_SWIZZLE_B = 0x8E44;
pub const TEXTURE_SWIZZLE_B_EXT = 0x8E44;
pub const TEXTURE_SWIZZLE_A = 0x8E45;
pub const TEXTURE_SWIZZLE_A_EXT = 0x8E45;
pub const TEXTURE_SWIZZLE_RGBA = 0x8E46;
pub const TEXTURE_SWIZZLE_RGBA_EXT = 0x8E46;
pub const ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS = 0x8E47;
pub const ACTIVE_SUBROUTINE_MAX_LENGTH = 0x8E48;
pub const ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH = 0x8E49;
pub const NUM_COMPATIBLE_SUBROUTINES = 0x8E4A;
pub const COMPATIBLE_SUBROUTINES = 0x8E4B;
pub const QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION = 0x8E4C;
pub const QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION_EXT = 0x8E4C;
pub const FIRST_VERTEX_CONVENTION = 0x8E4D;
pub const FIRST_VERTEX_CONVENTION_EXT = 0x8E4D;
pub const FIRST_VERTEX_CONVENTION_OES = 0x8E4D;
pub const LAST_VERTEX_CONVENTION = 0x8E4E;
pub const LAST_VERTEX_CONVENTION_EXT = 0x8E4E;
pub const LAST_VERTEX_CONVENTION_OES = 0x8E4E;
pub const PROVOKING_VERTEX = 0x8E4F;
pub const PROVOKING_VERTEX_EXT = 0x8E4F;
pub const SAMPLE_POSITION = 0x8E50;
pub const SAMPLE_POSITION_NV = 0x8E50;
pub const SAMPLE_LOCATION_ARB = 0x8E50;
pub const SAMPLE_LOCATION_NV = 0x8E50;
pub const SAMPLE_MASK = 0x8E51;
pub const SAMPLE_MASK_NV = 0x8E51;
pub const SAMPLE_MASK_VALUE = 0x8E52;
pub const SAMPLE_MASK_VALUE_NV = 0x8E52;
pub const TEXTURE_BINDING_RENDERBUFFER_NV = 0x8E53;
pub const TEXTURE_RENDERBUFFER_DATA_STORE_BINDING_NV = 0x8E54;
pub const TEXTURE_RENDERBUFFER_NV = 0x8E55;
pub const SAMPLER_RENDERBUFFER_NV = 0x8E56;
pub const INT_SAMPLER_RENDERBUFFER_NV = 0x8E57;
pub const UNSIGNED_INT_SAMPLER_RENDERBUFFER_NV = 0x8E58;
pub const MAX_SAMPLE_MASK_WORDS = 0x8E59;
pub const MAX_SAMPLE_MASK_WORDS_NV = 0x8E59;
pub const MAX_GEOMETRY_PROGRAM_INVOCATIONS_NV = 0x8E5A;
pub const MAX_GEOMETRY_SHADER_INVOCATIONS = 0x8E5A;
pub const MAX_GEOMETRY_SHADER_INVOCATIONS_EXT = 0x8E5A;
pub const MAX_GEOMETRY_SHADER_INVOCATIONS_OES = 0x8E5A;
pub const MIN_FRAGMENT_INTERPOLATION_OFFSET = 0x8E5B;
pub const MIN_FRAGMENT_INTERPOLATION_OFFSET_OES = 0x8E5B;
pub const MIN_FRAGMENT_INTERPOLATION_OFFSET_NV = 0x8E5B;
pub const MAX_FRAGMENT_INTERPOLATION_OFFSET = 0x8E5C;
pub const MAX_FRAGMENT_INTERPOLATION_OFFSET_OES = 0x8E5C;
pub const MAX_FRAGMENT_INTERPOLATION_OFFSET_NV = 0x8E5C;
pub const FRAGMENT_INTERPOLATION_OFFSET_BITS = 0x8E5D;
pub const FRAGMENT_INTERPOLATION_OFFSET_BITS_OES = 0x8E5D;
pub const FRAGMENT_PROGRAM_INTERPOLATION_OFFSET_BITS_NV = 0x8E5D;
pub const MIN_PROGRAM_TEXTURE_GATHER_OFFSET = 0x8E5E;
pub const MIN_PROGRAM_TEXTURE_GATHER_OFFSET_ARB = 0x8E5E;
pub const MIN_PROGRAM_TEXTURE_GATHER_OFFSET_NV = 0x8E5E;
pub const MAX_PROGRAM_TEXTURE_GATHER_OFFSET = 0x8E5F;
pub const MAX_PROGRAM_TEXTURE_GATHER_OFFSET_ARB = 0x8E5F;
pub const MAX_PROGRAM_TEXTURE_GATHER_OFFSET_NV = 0x8E5F;
pub const MAX_MESH_UNIFORM_BLOCKS_NV = 0x8E60;
pub const MAX_MESH_TEXTURE_IMAGE_UNITS_NV = 0x8E61;
pub const MAX_MESH_IMAGE_UNIFORMS_NV = 0x8E62;
pub const MAX_MESH_UNIFORM_COMPONENTS_NV = 0x8E63;
pub const MAX_MESH_ATOMIC_COUNTER_BUFFERS_NV = 0x8E64;
pub const MAX_MESH_ATOMIC_COUNTERS_NV = 0x8E65;
pub const MAX_MESH_SHADER_STORAGE_BLOCKS_NV = 0x8E66;
pub const MAX_COMBINED_MESH_UNIFORM_COMPONENTS_NV = 0x8E67;
pub const MAX_TASK_UNIFORM_BLOCKS_NV = 0x8E68;
pub const MAX_TASK_TEXTURE_IMAGE_UNITS_NV = 0x8E69;
pub const MAX_TASK_IMAGE_UNIFORMS_NV = 0x8E6A;
pub const MAX_TASK_UNIFORM_COMPONENTS_NV = 0x8E6B;
pub const MAX_TASK_ATOMIC_COUNTER_BUFFERS_NV = 0x8E6C;
pub const MAX_TASK_ATOMIC_COUNTERS_NV = 0x8E6D;
pub const MAX_TASK_SHADER_STORAGE_BLOCKS_NV = 0x8E6E;
pub const MAX_COMBINED_TASK_UNIFORM_COMPONENTS_NV = 0x8E6F;
pub const MAX_TRANSFORM_FEEDBACK_BUFFERS = 0x8E70;
pub const MAX_VERTEX_STREAMS = 0x8E71;
pub const PATCH_VERTICES = 0x8E72;
pub const PATCH_VERTICES_EXT = 0x8E72;
pub const PATCH_VERTICES_OES = 0x8E72;
pub const PATCH_DEFAULT_INNER_LEVEL = 0x8E73;
pub const PATCH_DEFAULT_INNER_LEVEL_EXT = 0x8E73;
pub const PATCH_DEFAULT_OUTER_LEVEL = 0x8E74;
pub const PATCH_DEFAULT_OUTER_LEVEL_EXT = 0x8E74;
pub const TESS_CONTROL_OUTPUT_VERTICES = 0x8E75;
pub const TESS_CONTROL_OUTPUT_VERTICES_EXT = 0x8E75;
pub const TESS_CONTROL_OUTPUT_VERTICES_OES = 0x8E75;
pub const TESS_GEN_MODE = 0x8E76;
pub const TESS_GEN_MODE_EXT = 0x8E76;
pub const TESS_GEN_MODE_OES = 0x8E76;
pub const TESS_GEN_SPACING = 0x8E77;
pub const TESS_GEN_SPACING_EXT = 0x8E77;
pub const TESS_GEN_SPACING_OES = 0x8E77;
pub const TESS_GEN_VERTEX_ORDER = 0x8E78;
pub const TESS_GEN_VERTEX_ORDER_EXT = 0x8E78;
pub const TESS_GEN_VERTEX_ORDER_OES = 0x8E78;
pub const TESS_GEN_POINT_MODE = 0x8E79;
pub const TESS_GEN_POINT_MODE_EXT = 0x8E79;
pub const TESS_GEN_POINT_MODE_OES = 0x8E79;
pub const ISOLINES = 0x8E7A;
pub const ISOLINES_EXT = 0x8E7A;
pub const ISOLINES_OES = 0x8E7A;
pub const FRACTIONAL_ODD = 0x8E7B;
pub const FRACTIONAL_ODD_EXT = 0x8E7B;
pub const FRACTIONAL_ODD_OES = 0x8E7B;
pub const FRACTIONAL_EVEN = 0x8E7C;
pub const FRACTIONAL_EVEN_EXT = 0x8E7C;
pub const FRACTIONAL_EVEN_OES = 0x8E7C;
pub const MAX_PATCH_VERTICES = 0x8E7D;
pub const MAX_PATCH_VERTICES_EXT = 0x8E7D;
pub const MAX_PATCH_VERTICES_OES = 0x8E7D;
pub const MAX_TESS_GEN_LEVEL = 0x8E7E;
pub const MAX_TESS_GEN_LEVEL_EXT = 0x8E7E;
pub const MAX_TESS_GEN_LEVEL_OES = 0x8E7E;
pub const MAX_TESS_CONTROL_UNIFORM_COMPONENTS = 0x8E7F;
pub const MAX_TESS_CONTROL_UNIFORM_COMPONENTS_EXT = 0x8E7F;
pub const MAX_TESS_CONTROL_UNIFORM_COMPONENTS_OES = 0x8E7F;
pub const MAX_TESS_EVALUATION_UNIFORM_COMPONENTS = 0x8E80;
pub const MAX_TESS_EVALUATION_UNIFORM_COMPONENTS_EXT = 0x8E80;
pub const MAX_TESS_EVALUATION_UNIFORM_COMPONENTS_OES = 0x8E80;
pub const MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS = 0x8E81;
pub const MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS_EXT = 0x8E81;
pub const MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS_OES = 0x8E81;
pub const MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS = 0x8E82;
pub const MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS_EXT = 0x8E82;
pub const MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS_OES = 0x8E82;
pub const MAX_TESS_CONTROL_OUTPUT_COMPONENTS = 0x8E83;
pub const MAX_TESS_CONTROL_OUTPUT_COMPONENTS_EXT = 0x8E83;
pub const MAX_TESS_CONTROL_OUTPUT_COMPONENTS_OES = 0x8E83;
pub const MAX_TESS_PATCH_COMPONENTS = 0x8E84;
pub const MAX_TESS_PATCH_COMPONENTS_EXT = 0x8E84;
pub const MAX_TESS_PATCH_COMPONENTS_OES = 0x8E84;
pub const MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS = 0x8E85;
pub const MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS_EXT = 0x8E85;
pub const MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS_OES = 0x8E85;
pub const MAX_TESS_EVALUATION_OUTPUT_COMPONENTS = 0x8E86;
pub const MAX_TESS_EVALUATION_OUTPUT_COMPONENTS_EXT = 0x8E86;
pub const MAX_TESS_EVALUATION_OUTPUT_COMPONENTS_OES = 0x8E86;
pub const TESS_EVALUATION_SHADER = 0x8E87;
pub const TESS_EVALUATION_SHADER_EXT = 0x8E87;
pub const TESS_EVALUATION_SHADER_OES = 0x8E87;
pub const TESS_CONTROL_SHADER = 0x8E88;
pub const TESS_CONTROL_SHADER_EXT = 0x8E88;
pub const TESS_CONTROL_SHADER_OES = 0x8E88;
pub const MAX_TESS_CONTROL_UNIFORM_BLOCKS = 0x8E89;
pub const MAX_TESS_CONTROL_UNIFORM_BLOCKS_EXT = 0x8E89;
pub const MAX_TESS_CONTROL_UNIFORM_BLOCKS_OES = 0x8E89;
pub const MAX_TESS_EVALUATION_UNIFORM_BLOCKS = 0x8E8A;
pub const MAX_TESS_EVALUATION_UNIFORM_BLOCKS_EXT = 0x8E8A;
pub const MAX_TESS_EVALUATION_UNIFORM_BLOCKS_OES = 0x8E8A;
pub const COMPRESSED_RGBA_BPTC_UNORM = 0x8E8C;
pub const COMPRESSED_RGBA_BPTC_UNORM_ARB = 0x8E8C;
pub const COMPRESSED_RGBA_BPTC_UNORM_EXT = 0x8E8C;
pub const COMPRESSED_SRGB_ALPHA_BPTC_UNORM = 0x8E8D;
pub const COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB = 0x8E8D;
pub const COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 0x8E8D;
pub const COMPRESSED_RGB_BPTC_SIGNED_FLOAT = 0x8E8E;
pub const COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB = 0x8E8E;
pub const COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 0x8E8E;
pub const COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT = 0x8E8F;
pub const COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB = 0x8E8F;
pub const COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 0x8E8F;
pub const COVERAGE_COMPONENT_NV = 0x8ED0;
pub const COVERAGE_COMPONENT4_NV = 0x8ED1;
pub const COVERAGE_ATTACHMENT_NV = 0x8ED2;
pub const COVERAGE_BUFFERS_NV = 0x8ED3;
pub const COVERAGE_SAMPLES_NV = 0x8ED4;
pub const COVERAGE_ALL_FRAGMENTS_NV = 0x8ED5;
pub const COVERAGE_EDGE_FRAGMENTS_NV = 0x8ED6;
pub const COVERAGE_AUTOMATIC_NV = 0x8ED7;
pub const INCLUSIVE_EXT = 0x8F10;
pub const EXCLUSIVE_EXT = 0x8F11;
pub const WINDOW_RECTANGLE_EXT = 0x8F12;
pub const WINDOW_RECTANGLE_MODE_EXT = 0x8F13;
pub const MAX_WINDOW_RECTANGLES_EXT = 0x8F14;
pub const NUM_WINDOW_RECTANGLES_EXT = 0x8F15;
pub const BUFFER_GPU_ADDRESS_NV = 0x8F1D;
pub const VERTEX_ATTRIB_ARRAY_UNIFIED_NV = 0x8F1E;
pub const ELEMENT_ARRAY_UNIFIED_NV = 0x8F1F;
pub const VERTEX_ATTRIB_ARRAY_ADDRESS_NV = 0x8F20;
pub const VERTEX_ARRAY_ADDRESS_NV = 0x8F21;
pub const NORMAL_ARRAY_ADDRESS_NV = 0x8F22;
pub const COLOR_ARRAY_ADDRESS_NV = 0x8F23;
pub const INDEX_ARRAY_ADDRESS_NV = 0x8F24;
pub const TEXTURE_COORD_ARRAY_ADDRESS_NV = 0x8F25;
pub const EDGE_FLAG_ARRAY_ADDRESS_NV = 0x8F26;
pub const SECONDARY_COLOR_ARRAY_ADDRESS_NV = 0x8F27;
pub const FOG_COORD_ARRAY_ADDRESS_NV = 0x8F28;
pub const ELEMENT_ARRAY_ADDRESS_NV = 0x8F29;
pub const VERTEX_ATTRIB_ARRAY_LENGTH_NV = 0x8F2A;
pub const VERTEX_ARRAY_LENGTH_NV = 0x8F2B;
pub const NORMAL_ARRAY_LENGTH_NV = 0x8F2C;
pub const COLOR_ARRAY_LENGTH_NV = 0x8F2D;
pub const INDEX_ARRAY_LENGTH_NV = 0x8F2E;
pub const TEXTURE_COORD_ARRAY_LENGTH_NV = 0x8F2F;
pub const EDGE_FLAG_ARRAY_LENGTH_NV = 0x8F30;
pub const SECONDARY_COLOR_ARRAY_LENGTH_NV = 0x8F31;
pub const FOG_COORD_ARRAY_LENGTH_NV = 0x8F32;
pub const ELEMENT_ARRAY_LENGTH_NV = 0x8F33;
pub const GPU_ADDRESS_NV = 0x8F34;
pub const MAX_SHADER_BUFFER_ADDRESS_NV = 0x8F35;
pub const COPY_READ_BUFFER = 0x8F36;
pub const COPY_READ_BUFFER_NV = 0x8F36;
pub const COPY_READ_BUFFER_BINDING = 0x8F36;
pub const COPY_WRITE_BUFFER = 0x8F37;
pub const COPY_WRITE_BUFFER_NV = 0x8F37;
pub const COPY_WRITE_BUFFER_BINDING = 0x8F37;
pub const MAX_IMAGE_UNITS = 0x8F38;
pub const MAX_IMAGE_UNITS_EXT = 0x8F38;
pub const MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS = 0x8F39;
pub const MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS_EXT = 0x8F39;
pub const MAX_COMBINED_SHADER_OUTPUT_RESOURCES = 0x8F39;
pub const IMAGE_BINDING_NAME = 0x8F3A;
pub const IMAGE_BINDING_NAME_EXT = 0x8F3A;
pub const IMAGE_BINDING_LEVEL = 0x8F3B;
pub const IMAGE_BINDING_LEVEL_EXT = 0x8F3B;
pub const IMAGE_BINDING_LAYERED = 0x8F3C;
pub const IMAGE_BINDING_LAYERED_EXT = 0x8F3C;
pub const IMAGE_BINDING_LAYER = 0x8F3D;
pub const IMAGE_BINDING_LAYER_EXT = 0x8F3D;
pub const IMAGE_BINDING_ACCESS = 0x8F3E;
pub const IMAGE_BINDING_ACCESS_EXT = 0x8F3E;
pub const DRAW_INDIRECT_BUFFER = 0x8F3F;
pub const DRAW_INDIRECT_UNIFIED_NV = 0x8F40;
pub const DRAW_INDIRECT_ADDRESS_NV = 0x8F41;
pub const DRAW_INDIRECT_LENGTH_NV = 0x8F42;
pub const DRAW_INDIRECT_BUFFER_BINDING = 0x8F43;
pub const MAX_PROGRAM_SUBROUTINE_PARAMETERS_NV = 0x8F44;
pub const MAX_PROGRAM_SUBROUTINE_NUM_NV = 0x8F45;
pub const DOUBLE_MAT2 = 0x8F46;
pub const DOUBLE_MAT2_EXT = 0x8F46;
pub const DOUBLE_MAT3 = 0x8F47;
pub const DOUBLE_MAT3_EXT = 0x8F47;
pub const DOUBLE_MAT4 = 0x8F48;
pub const DOUBLE_MAT4_EXT = 0x8F48;
pub const DOUBLE_MAT2x3 = 0x8F49;
pub const DOUBLE_MAT2x3_EXT = 0x8F49;
pub const DOUBLE_MAT2x4 = 0x8F4A;
pub const DOUBLE_MAT2x4_EXT = 0x8F4A;
pub const DOUBLE_MAT3x2 = 0x8F4B;
pub const DOUBLE_MAT3x2_EXT = 0x8F4B;
pub const DOUBLE_MAT3x4 = 0x8F4C;
pub const DOUBLE_MAT3x4_EXT = 0x8F4C;
pub const DOUBLE_MAT4x2 = 0x8F4D;
pub const DOUBLE_MAT4x2_EXT = 0x8F4D;
pub const DOUBLE_MAT4x3 = 0x8F4E;
pub const DOUBLE_MAT4x3_EXT = 0x8F4E;
pub const VERTEX_BINDING_BUFFER = 0x8F4F;
pub const MALI_SHADER_BINARY_ARM = 0x8F60;
pub const MALI_PROGRAM_BINARY_ARM = 0x8F61;
pub const MAX_SHADER_PIXEL_LOCAL_STORAGE_FAST_SIZE_EXT = 0x8F63;
pub const SHADER_PIXEL_LOCAL_STORAGE_EXT = 0x8F64;
pub const FETCH_PER_SAMPLE_ARM = 0x8F65;
pub const FRAGMENT_SHADER_FRAMEBUFFER_FETCH_MRT_ARM = 0x8F66;
pub const MAX_SHADER_PIXEL_LOCAL_STORAGE_SIZE_EXT = 0x8F67;
pub const TEXTURE_ASTC_DECODE_PRECISION_EXT = 0x8F69;
pub const TEXTURE_UNNORMALIZED_COORDINATES_ARM = 0x8F6A;
pub const RED_SNORM = 0x8F90;
pub const RG_SNORM = 0x8F91;
pub const RGB_SNORM = 0x8F92;
pub const RGBA_SNORM = 0x8F93;
pub const R8_SNORM = 0x8F94;
pub const RG8_SNORM = 0x8F95;
pub const RGB8_SNORM = 0x8F96;
pub const RGBA8_SNORM = 0x8F97;
pub const R16_SNORM = 0x8F98;
pub const R16_SNORM_EXT = 0x8F98;
pub const RG16_SNORM = 0x8F99;
pub const RG16_SNORM_EXT = 0x8F99;
pub const RGB16_SNORM = 0x8F9A;
pub const RGB16_SNORM_EXT = 0x8F9A;
pub const RGBA16_SNORM = 0x8F9B;
pub const RGBA16_SNORM_EXT = 0x8F9B;
pub const SIGNED_NORMALIZED = 0x8F9C;
pub const PRIMITIVE_RESTART = 0x8F9D;
pub const PRIMITIVE_RESTART_INDEX = 0x8F9E;
pub const MAX_PROGRAM_TEXTURE_GATHER_COMPONENTS_ARB = 0x8F9F;
pub const PERFMON_GLOBAL_MODE_QCOM = 0x8FA0;
pub const MAX_SHADER_SUBSAMPLED_IMAGE_UNITS_QCOM = 0x8FA1;
pub const BINNING_CONTROL_HINT_QCOM = 0x8FB0;
pub const CPU_OPTIMIZED_QCOM = 0x8FB1;
pub const GPU_OPTIMIZED_QCOM = 0x8FB2;
pub const RENDER_DIRECT_TO_FRAMEBUFFER_QCOM = 0x8FB3;
pub const GPU_DISJOINT_EXT = 0x8FBB;
pub const SR8_EXT = 0x8FBD;
pub const SRG8_EXT = 0x8FBE;
pub const TEXTURE_FORMAT_SRGB_OVERRIDE_EXT = 0x8FBF;
pub const SHADER_BINARY_VIV = 0x8FC4;
pub const INT8_NV = 0x8FE0;
pub const INT8_VEC2_NV = 0x8FE1;
pub const INT8_VEC3_NV = 0x8FE2;
pub const INT8_VEC4_NV = 0x8FE3;
pub const INT16_NV = 0x8FE4;
pub const INT16_VEC2_NV = 0x8FE5;
pub const INT16_VEC3_NV = 0x8FE6;
pub const INT16_VEC4_NV = 0x8FE7;
pub const INT64_VEC2_ARB = 0x8FE9;
pub const INT64_VEC2_NV = 0x8FE9;
pub const INT64_VEC3_ARB = 0x8FEA;
pub const INT64_VEC3_NV = 0x8FEA;
pub const INT64_VEC4_ARB = 0x8FEB;
pub const INT64_VEC4_NV = 0x8FEB;
pub const UNSIGNED_INT8_NV = 0x8FEC;
pub const UNSIGNED_INT8_VEC2_NV = 0x8FED;
pub const UNSIGNED_INT8_VEC3_NV = 0x8FEE;
pub const UNSIGNED_INT8_VEC4_NV = 0x8FEF;
pub const UNSIGNED_INT16_NV = 0x8FF0;
pub const UNSIGNED_INT16_VEC2_NV = 0x8FF1;
pub const UNSIGNED_INT16_VEC3_NV = 0x8FF2;
pub const UNSIGNED_INT16_VEC4_NV = 0x8FF3;
pub const UNSIGNED_INT64_VEC2_ARB = 0x8FF5;
pub const UNSIGNED_INT64_VEC2_NV = 0x8FF5;
pub const UNSIGNED_INT64_VEC3_ARB = 0x8FF6;
pub const UNSIGNED_INT64_VEC3_NV = 0x8FF6;
pub const UNSIGNED_INT64_VEC4_ARB = 0x8FF7;
pub const UNSIGNED_INT64_VEC4_NV = 0x8FF7;
pub const FLOAT16_NV = 0x8FF8;
pub const FLOAT16_VEC2_NV = 0x8FF9;
pub const FLOAT16_VEC3_NV = 0x8FFA;
pub const FLOAT16_VEC4_NV = 0x8FFB;
pub const DOUBLE_VEC2 = 0x8FFC;
pub const DOUBLE_VEC2_EXT = 0x8FFC;
pub const DOUBLE_VEC3 = 0x8FFD;
pub const DOUBLE_VEC3_EXT = 0x8FFD;
pub const DOUBLE_VEC4 = 0x8FFE;
pub const DOUBLE_VEC4_EXT = 0x8FFE;
pub const SAMPLER_BUFFER_AMD = 0x9001;
pub const INT_SAMPLER_BUFFER_AMD = 0x9002;
pub const UNSIGNED_INT_SAMPLER_BUFFER_AMD = 0x9003;
pub const TESSELLATION_MODE_AMD = 0x9004;
pub const TESSELLATION_FACTOR_AMD = 0x9005;
pub const DISCRETE_AMD = 0x9006;
pub const CONTINUOUS_AMD = 0x9007;
pub const TEXTURE_CUBE_MAP_ARRAY = 0x9009;
pub const TEXTURE_CUBE_MAP_ARRAY_ARB = 0x9009;
pub const TEXTURE_CUBE_MAP_ARRAY_EXT = 0x9009;
pub const TEXTURE_CUBE_MAP_ARRAY_OES = 0x9009;
pub const TEXTURE_BINDING_CUBE_MAP_ARRAY = 0x900A;
pub const TEXTURE_BINDING_CUBE_MAP_ARRAY_ARB = 0x900A;
pub const TEXTURE_BINDING_CUBE_MAP_ARRAY_EXT = 0x900A;
pub const TEXTURE_BINDING_CUBE_MAP_ARRAY_OES = 0x900A;
pub const PROXY_TEXTURE_CUBE_MAP_ARRAY = 0x900B;
pub const PROXY_TEXTURE_CUBE_MAP_ARRAY_ARB = 0x900B;
pub const SAMPLER_CUBE_MAP_ARRAY = 0x900C;
pub const SAMPLER_CUBE_MAP_ARRAY_ARB = 0x900C;
pub const SAMPLER_CUBE_MAP_ARRAY_EXT = 0x900C;
pub const SAMPLER_CUBE_MAP_ARRAY_OES = 0x900C;
pub const SAMPLER_CUBE_MAP_ARRAY_SHADOW = 0x900D;
pub const SAMPLER_CUBE_MAP_ARRAY_SHADOW_ARB = 0x900D;
pub const SAMPLER_CUBE_MAP_ARRAY_SHADOW_EXT = 0x900D;
pub const SAMPLER_CUBE_MAP_ARRAY_SHADOW_OES = 0x900D;
pub const INT_SAMPLER_CUBE_MAP_ARRAY = 0x900E;
pub const INT_SAMPLER_CUBE_MAP_ARRAY_ARB = 0x900E;
pub const INT_SAMPLER_CUBE_MAP_ARRAY_EXT = 0x900E;
pub const INT_SAMPLER_CUBE_MAP_ARRAY_OES = 0x900E;
pub const UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY = 0x900F;
pub const UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_ARB = 0x900F;
pub const UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_EXT = 0x900F;
pub const UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_OES = 0x900F;
pub const ALPHA_SNORM = 0x9010;
pub const LUMINANCE_SNORM = 0x9011;
pub const LUMINANCE_ALPHA_SNORM = 0x9012;
pub const INTENSITY_SNORM = 0x9013;
pub const ALPHA8_SNORM = 0x9014;
pub const LUMINANCE8_SNORM = 0x9015;
pub const LUMINANCE8_ALPHA8_SNORM = 0x9016;
pub const INTENSITY8_SNORM = 0x9017;
pub const ALPHA16_SNORM = 0x9018;
pub const LUMINANCE16_SNORM = 0x9019;
pub const LUMINANCE16_ALPHA16_SNORM = 0x901A;
pub const INTENSITY16_SNORM = 0x901B;
pub const FACTOR_MIN_AMD = 0x901C;
pub const FACTOR_MAX_AMD = 0x901D;
pub const DEPTH_CLAMP_NEAR_AMD = 0x901E;
pub const DEPTH_CLAMP_FAR_AMD = 0x901F;
pub const VIDEO_BUFFER_NV = 0x9020;
pub const VIDEO_BUFFER_BINDING_NV = 0x9021;
pub const FIELD_UPPER_NV = 0x9022;
pub const FIELD_LOWER_NV = 0x9023;
pub const NUM_VIDEO_CAPTURE_STREAMS_NV = 0x9024;
pub const NEXT_VIDEO_CAPTURE_BUFFER_STATUS_NV = 0x9025;
pub const VIDEO_CAPTURE_TO_422_SUPPORTED_NV = 0x9026;
pub const LAST_VIDEO_CAPTURE_STATUS_NV = 0x9027;
pub const VIDEO_BUFFER_PITCH_NV = 0x9028;
pub const VIDEO_COLOR_CONVERSION_MATRIX_NV = 0x9029;
pub const VIDEO_COLOR_CONVERSION_MAX_NV = 0x902A;
pub const VIDEO_COLOR_CONVERSION_MIN_NV = 0x902B;
pub const VIDEO_COLOR_CONVERSION_OFFSET_NV = 0x902C;
pub const VIDEO_BUFFER_INTERNAL_FORMAT_NV = 0x902D;
pub const PARTIAL_SUCCESS_NV = 0x902E;
pub const SUCCESS_NV = 0x902F;
pub const FAILURE_NV = 0x9030;
pub const YCBYCR8_422_NV = 0x9031;
pub const YCBAYCR8A_4224_NV = 0x9032;
pub const Z6Y10Z6CB10Z6Y10Z6CR10_422_NV = 0x9033;
pub const Z6Y10Z6CB10Z6A10Z6Y10Z6CR10Z6A10_4224_NV = 0x9034;
pub const Z4Y12Z4CB12Z4Y12Z4CR12_422_NV = 0x9035;
pub const Z4Y12Z4CB12Z4A12Z4Y12Z4CR12Z4A12_4224_NV = 0x9036;
pub const Z4Y12Z4CB12Z4CR12_444_NV = 0x9037;
pub const VIDEO_CAPTURE_FRAME_WIDTH_NV = 0x9038;
pub const VIDEO_CAPTURE_FRAME_HEIGHT_NV = 0x9039;
pub const VIDEO_CAPTURE_FIELD_UPPER_HEIGHT_NV = 0x903A;
pub const VIDEO_CAPTURE_FIELD_LOWER_HEIGHT_NV = 0x903B;
pub const VIDEO_CAPTURE_SURFACE_ORIGIN_NV = 0x903C;
pub const TEXTURE_COVERAGE_SAMPLES_NV = 0x9045;
pub const TEXTURE_COLOR_SAMPLES_NV = 0x9046;
pub const GPU_MEMORY_INFO_DEDICATED_VIDMEM_NVX = 0x9047;
pub const GPU_MEMORY_INFO_TOTAL_AVAILABLE_MEMORY_NVX = 0x9048;
pub const GPU_MEMORY_INFO_CURRENT_AVAILABLE_VIDMEM_NVX = 0x9049;
pub const GPU_MEMORY_INFO_EVICTION_COUNT_NVX = 0x904A;
pub const GPU_MEMORY_INFO_EVICTED_MEMORY_NVX = 0x904B;
pub const IMAGE_1D = 0x904C;
pub const IMAGE_1D_EXT = 0x904C;
pub const IMAGE_2D = 0x904D;
pub const IMAGE_2D_EXT = 0x904D;
pub const IMAGE_3D = 0x904E;
pub const IMAGE_3D_EXT = 0x904E;
pub const IMAGE_2D_RECT = 0x904F;
pub const IMAGE_2D_RECT_EXT = 0x904F;
pub const IMAGE_CUBE = 0x9050;
pub const IMAGE_CUBE_EXT = 0x9050;
pub const IMAGE_BUFFER = 0x9051;
pub const IMAGE_BUFFER_EXT = 0x9051;
pub const IMAGE_BUFFER_OES = 0x9051;
pub const IMAGE_1D_ARRAY = 0x9052;
pub const IMAGE_1D_ARRAY_EXT = 0x9052;
pub const IMAGE_2D_ARRAY = 0x9053;
pub const IMAGE_2D_ARRAY_EXT = 0x9053;
pub const IMAGE_CUBE_MAP_ARRAY = 0x9054;
pub const IMAGE_CUBE_MAP_ARRAY_EXT = 0x9054;
pub const IMAGE_CUBE_MAP_ARRAY_OES = 0x9054;
pub const IMAGE_2D_MULTISAMPLE = 0x9055;
pub const IMAGE_2D_MULTISAMPLE_EXT = 0x9055;
pub const IMAGE_2D_MULTISAMPLE_ARRAY = 0x9056;
pub const IMAGE_2D_MULTISAMPLE_ARRAY_EXT = 0x9056;
pub const INT_IMAGE_1D = 0x9057;
pub const INT_IMAGE_1D_EXT = 0x9057;
pub const INT_IMAGE_2D = 0x9058;
pub const INT_IMAGE_2D_EXT = 0x9058;
pub const INT_IMAGE_3D = 0x9059;
pub const INT_IMAGE_3D_EXT = 0x9059;
pub const INT_IMAGE_2D_RECT = 0x905A;
pub const INT_IMAGE_2D_RECT_EXT = 0x905A;
pub const INT_IMAGE_CUBE = 0x905B;
pub const INT_IMAGE_CUBE_EXT = 0x905B;
pub const INT_IMAGE_BUFFER = 0x905C;
pub const INT_IMAGE_BUFFER_EXT = 0x905C;
pub const INT_IMAGE_BUFFER_OES = 0x905C;
pub const INT_IMAGE_1D_ARRAY = 0x905D;
pub const INT_IMAGE_1D_ARRAY_EXT = 0x905D;
pub const INT_IMAGE_2D_ARRAY = 0x905E;
pub const INT_IMAGE_2D_ARRAY_EXT = 0x905E;
pub const INT_IMAGE_CUBE_MAP_ARRAY = 0x905F;
pub const INT_IMAGE_CUBE_MAP_ARRAY_EXT = 0x905F;
pub const INT_IMAGE_CUBE_MAP_ARRAY_OES = 0x905F;
pub const INT_IMAGE_2D_MULTISAMPLE = 0x9060;
pub const INT_IMAGE_2D_MULTISAMPLE_EXT = 0x9060;
pub const INT_IMAGE_2D_MULTISAMPLE_ARRAY = 0x9061;
pub const INT_IMAGE_2D_MULTISAMPLE_ARRAY_EXT = 0x9061;
pub const UNSIGNED_INT_IMAGE_1D = 0x9062;
pub const UNSIGNED_INT_IMAGE_1D_EXT = 0x9062;
pub const UNSIGNED_INT_IMAGE_2D = 0x9063;
pub const UNSIGNED_INT_IMAGE_2D_EXT = 0x9063;
pub const UNSIGNED_INT_IMAGE_3D = 0x9064;
pub const UNSIGNED_INT_IMAGE_3D_EXT = 0x9064;
pub const UNSIGNED_INT_IMAGE_2D_RECT = 0x9065;
pub const UNSIGNED_INT_IMAGE_2D_RECT_EXT = 0x9065;
pub const UNSIGNED_INT_IMAGE_CUBE = 0x9066;
pub const UNSIGNED_INT_IMAGE_CUBE_EXT = 0x9066;
pub const UNSIGNED_INT_IMAGE_BUFFER = 0x9067;
pub const UNSIGNED_INT_IMAGE_BUFFER_EXT = 0x9067;
pub const UNSIGNED_INT_IMAGE_BUFFER_OES = 0x9067;
pub const UNSIGNED_INT_IMAGE_1D_ARRAY = 0x9068;
pub const UNSIGNED_INT_IMAGE_1D_ARRAY_EXT = 0x9068;
pub const UNSIGNED_INT_IMAGE_2D_ARRAY = 0x9069;
pub const UNSIGNED_INT_IMAGE_2D_ARRAY_EXT = 0x9069;
pub const UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY = 0x906A;
pub const UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY_EXT = 0x906A;
pub const UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY_OES = 0x906A;
pub const UNSIGNED_INT_IMAGE_2D_MULTISAMPLE = 0x906B;
pub const UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_EXT = 0x906B;
pub const UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY = 0x906C;
pub const UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY_EXT = 0x906C;
pub const MAX_IMAGE_SAMPLES = 0x906D;
pub const MAX_IMAGE_SAMPLES_EXT = 0x906D;
pub const IMAGE_BINDING_FORMAT = 0x906E;
pub const IMAGE_BINDING_FORMAT_EXT = 0x906E;
pub const RGB10_A2UI = 0x906F;
pub const PATH_FORMAT_SVG_NV = 0x9070;
pub const PATH_FORMAT_PS_NV = 0x9071;
pub const STANDARD_FONT_NAME_NV = 0x9072;
pub const SYSTEM_FONT_NAME_NV = 0x9073;
pub const FILE_NAME_NV = 0x9074;
pub const PATH_STROKE_WIDTH_NV = 0x9075;
pub const PATH_END_CAPS_NV = 0x9076;
pub const PATH_INITIAL_END_CAP_NV = 0x9077;
pub const PATH_TERMINAL_END_CAP_NV = 0x9078;
pub const PATH_JOIN_STYLE_NV = 0x9079;
pub const PATH_MITER_LIMIT_NV = 0x907A;
pub const PATH_DASH_CAPS_NV = 0x907B;
pub const PATH_INITIAL_DASH_CAP_NV = 0x907C;
pub const PATH_TERMINAL_DASH_CAP_NV = 0x907D;
pub const PATH_DASH_OFFSET_NV = 0x907E;
pub const PATH_CLIENT_LENGTH_NV = 0x907F;
pub const PATH_FILL_MODE_NV = 0x9080;
pub const PATH_FILL_MASK_NV = 0x9081;
pub const PATH_FILL_COVER_MODE_NV = 0x9082;
pub const PATH_STROKE_COVER_MODE_NV = 0x9083;
pub const PATH_STROKE_MASK_NV = 0x9084;
pub const COUNT_UP_NV = 0x9088;
pub const COUNT_DOWN_NV = 0x9089;
pub const PATH_OBJECT_BOUNDING_BOX_NV = 0x908A;
pub const CONVEX_HULL_NV = 0x908B;
pub const BOUNDING_BOX_NV = 0x908D;
pub const TRANSLATE_X_NV = 0x908E;
pub const TRANSLATE_Y_NV = 0x908F;
pub const TRANSLATE_2D_NV = 0x9090;
pub const TRANSLATE_3D_NV = 0x9091;
pub const AFFINE_2D_NV = 0x9092;
pub const AFFINE_3D_NV = 0x9094;
pub const TRANSPOSE_AFFINE_2D_NV = 0x9096;
pub const TRANSPOSE_AFFINE_3D_NV = 0x9098;
pub const UTF8_NV = 0x909A;
pub const UTF16_NV = 0x909B;
pub const BOUNDING_BOX_OF_BOUNDING_BOXES_NV = 0x909C;
pub const PATH_COMMAND_COUNT_NV = 0x909D;
pub const PATH_COORD_COUNT_NV = 0x909E;
pub const PATH_DASH_ARRAY_COUNT_NV = 0x909F;
pub const PATH_COMPUTED_LENGTH_NV = 0x90A0;
pub const PATH_FILL_BOUNDING_BOX_NV = 0x90A1;
pub const PATH_STROKE_BOUNDING_BOX_NV = 0x90A2;
pub const SQUARE_NV = 0x90A3;
pub const ROUND_NV = 0x90A4;
pub const TRIANGULAR_NV = 0x90A5;
pub const BEVEL_NV = 0x90A6;
pub const MITER_REVERT_NV = 0x90A7;
pub const MITER_TRUNCATE_NV = 0x90A8;
pub const SKIP_MISSING_GLYPH_NV = 0x90A9;
pub const USE_MISSING_GLYPH_NV = 0x90AA;
pub const PATH_ERROR_POSITION_NV = 0x90AB;
pub const PATH_FOG_GEN_MODE_NV = 0x90AC;
pub const ACCUM_ADJACENT_PAIRS_NV = 0x90AD;
pub const ADJACENT_PAIRS_NV = 0x90AE;
pub const FIRST_TO_REST_NV = 0x90AF;
pub const PATH_GEN_MODE_NV = 0x90B0;
pub const PATH_GEN_COEFF_NV = 0x90B1;
pub const PATH_GEN_COLOR_FORMAT_NV = 0x90B2;
pub const PATH_GEN_COMPONENTS_NV = 0x90B3;
pub const PATH_DASH_OFFSET_RESET_NV = 0x90B4;
pub const MOVE_TO_RESETS_NV = 0x90B5;
pub const MOVE_TO_CONTINUES_NV = 0x90B6;
pub const PATH_STENCIL_FUNC_NV = 0x90B7;
pub const PATH_STENCIL_REF_NV = 0x90B8;
pub const PATH_STENCIL_VALUE_MASK_NV = 0x90B9;
pub const SCALED_RESOLVE_FASTEST_EXT = 0x90BA;
pub const SCALED_RESOLVE_NICEST_EXT = 0x90BB;
pub const MIN_MAP_BUFFER_ALIGNMENT = 0x90BC;
pub const PATH_STENCIL_DEPTH_OFFSET_FACTOR_NV = 0x90BD;
pub const PATH_STENCIL_DEPTH_OFFSET_UNITS_NV = 0x90BE;
pub const PATH_COVER_DEPTH_FUNC_NV = 0x90BF;
pub const IMAGE_FORMAT_COMPATIBILITY_TYPE = 0x90C7;
pub const IMAGE_FORMAT_COMPATIBILITY_BY_SIZE = 0x90C8;
pub const IMAGE_FORMAT_COMPATIBILITY_BY_CLASS = 0x90C9;
pub const MAX_VERTEX_IMAGE_UNIFORMS = 0x90CA;
pub const MAX_TESS_CONTROL_IMAGE_UNIFORMS = 0x90CB;
pub const MAX_TESS_CONTROL_IMAGE_UNIFORMS_EXT = 0x90CB;
pub const MAX_TESS_CONTROL_IMAGE_UNIFORMS_OES = 0x90CB;
pub const MAX_TESS_EVALUATION_IMAGE_UNIFORMS = 0x90CC;
pub const MAX_TESS_EVALUATION_IMAGE_UNIFORMS_EXT = 0x90CC;
pub const MAX_TESS_EVALUATION_IMAGE_UNIFORMS_OES = 0x90CC;
pub const MAX_GEOMETRY_IMAGE_UNIFORMS = 0x90CD;
pub const MAX_GEOMETRY_IMAGE_UNIFORMS_EXT = 0x90CD;
pub const MAX_GEOMETRY_IMAGE_UNIFORMS_OES = 0x90CD;
pub const MAX_FRAGMENT_IMAGE_UNIFORMS = 0x90CE;
pub const MAX_COMBINED_IMAGE_UNIFORMS = 0x90CF;
pub const MAX_DEEP_3D_TEXTURE_WIDTH_HEIGHT_NV = 0x90D0;
pub const MAX_DEEP_3D_TEXTURE_DEPTH_NV = 0x90D1;
pub const SHADER_STORAGE_BUFFER = 0x90D2;
pub const SHADER_STORAGE_BUFFER_BINDING = 0x90D3;
pub const SHADER_STORAGE_BUFFER_START = 0x90D4;
pub const SHADER_STORAGE_BUFFER_SIZE = 0x90D5;
pub const MAX_VERTEX_SHADER_STORAGE_BLOCKS = 0x90D6;
pub const MAX_GEOMETRY_SHADER_STORAGE_BLOCKS = 0x90D7;
pub const MAX_GEOMETRY_SHADER_STORAGE_BLOCKS_EXT = 0x90D7;
pub const MAX_GEOMETRY_SHADER_STORAGE_BLOCKS_OES = 0x90D7;
pub const MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS = 0x90D8;
pub const MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS_EXT = 0x90D8;
pub const MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS_OES = 0x90D8;
pub const MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS = 0x90D9;
pub const MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS_EXT = 0x90D9;
pub const MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS_OES = 0x90D9;
pub const MAX_FRAGMENT_SHADER_STORAGE_BLOCKS = 0x90DA;
pub const MAX_COMPUTE_SHADER_STORAGE_BLOCKS = 0x90DB;
pub const MAX_COMBINED_SHADER_STORAGE_BLOCKS = 0x90DC;
pub const MAX_SHADER_STORAGE_BUFFER_BINDINGS = 0x90DD;
pub const MAX_SHADER_STORAGE_BLOCK_SIZE = 0x90DE;
pub const SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT = 0x90DF;
pub const SYNC_X11_FENCE_EXT = 0x90E1;
pub const DEPTH_STENCIL_TEXTURE_MODE = 0x90EA;
pub const MAX_COMPUTE_WORK_GROUP_INVOCATIONS = 0x90EB;
pub const MAX_COMPUTE_FIXED_GROUP_INVOCATIONS_ARB = 0x90EB;
pub const UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER = 0x90EC;
pub const ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER = 0x90ED;
pub const DISPATCH_INDIRECT_BUFFER = 0x90EE;
pub const DISPATCH_INDIRECT_BUFFER_BINDING = 0x90EF;
pub const COLOR_ATTACHMENT_EXT = 0x90F0;
pub const MULTIVIEW_EXT = 0x90F1;
pub const MAX_MULTIVIEW_BUFFERS_EXT = 0x90F2;
pub const CONTEXT_ROBUST_ACCESS = 0x90F3;
pub const CONTEXT_ROBUST_ACCESS_EXT = 0x90F3;
pub const CONTEXT_ROBUST_ACCESS_KHR = 0x90F3;
pub const COMPUTE_PROGRAM_NV = 0x90FB;
pub const COMPUTE_PROGRAM_PARAMETER_BUFFER_NV = 0x90FC;
pub const TEXTURE_2D_MULTISAMPLE = 0x9100;
pub const PROXY_TEXTURE_2D_MULTISAMPLE = 0x9101;
pub const TEXTURE_2D_MULTISAMPLE_ARRAY = 0x9102;
pub const TEXTURE_2D_MULTISAMPLE_ARRAY_OES = 0x9102;
pub const PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY = 0x9103;
pub const TEXTURE_BINDING_2D_MULTISAMPLE = 0x9104;
pub const TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY = 0x9105;
pub const TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY_OES = 0x9105;
pub const TEXTURE_SAMPLES = 0x9106;
pub const TEXTURE_FIXED_SAMPLE_LOCATIONS = 0x9107;
pub const SAMPLER_2D_MULTISAMPLE = 0x9108;
pub const INT_SAMPLER_2D_MULTISAMPLE = 0x9109;
pub const UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE = 0x910A;
pub const SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910B;
pub const SAMPLER_2D_MULTISAMPLE_ARRAY_OES = 0x910B;
pub const INT_SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910C;
pub const INT_SAMPLER_2D_MULTISAMPLE_ARRAY_OES = 0x910C;
pub const UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910D;
pub const UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY_OES = 0x910D;
pub const MAX_COLOR_TEXTURE_SAMPLES = 0x910E;
pub const MAX_DEPTH_TEXTURE_SAMPLES = 0x910F;
pub const MAX_INTEGER_SAMPLES = 0x9110;
pub const MAX_SERVER_WAIT_TIMEOUT = 0x9111;
pub const MAX_SERVER_WAIT_TIMEOUT_APPLE = 0x9111;
pub const OBJECT_TYPE = 0x9112;
pub const OBJECT_TYPE_APPLE = 0x9112;
pub const SYNC_CONDITION = 0x9113;
pub const SYNC_CONDITION_APPLE = 0x9113;
pub const SYNC_STATUS = 0x9114;
pub const SYNC_STATUS_APPLE = 0x9114;
pub const SYNC_FLAGS = 0x9115;
pub const SYNC_FLAGS_APPLE = 0x9115;
pub const SYNC_FENCE = 0x9116;
pub const SYNC_FENCE_APPLE = 0x9116;
pub const SYNC_GPU_COMMANDS_COMPLETE = 0x9117;
pub const SYNC_GPU_COMMANDS_COMPLETE_APPLE = 0x9117;
pub const UNSIGNALED = 0x9118;
pub const UNSIGNALED_APPLE = 0x9118;
pub const SIGNALED = 0x9119;
pub const SIGNALED_APPLE = 0x9119;
pub const ALREADY_SIGNALED = 0x911A;
pub const ALREADY_SIGNALED_APPLE = 0x911A;
pub const TIMEOUT_EXPIRED = 0x911B;
pub const TIMEOUT_EXPIRED_APPLE = 0x911B;
pub const CONDITION_SATISFIED = 0x911C;
pub const CONDITION_SATISFIED_APPLE = 0x911C;
pub const WAIT_FAILED = 0x911D;
pub const WAIT_FAILED_APPLE = 0x911D;
pub const BUFFER_ACCESS_FLAGS = 0x911F;
pub const BUFFER_MAP_LENGTH = 0x9120;
pub const BUFFER_MAP_OFFSET = 0x9121;
pub const MAX_VERTEX_OUTPUT_COMPONENTS = 0x9122;
pub const MAX_GEOMETRY_INPUT_COMPONENTS = 0x9123;
pub const MAX_GEOMETRY_INPUT_COMPONENTS_EXT = 0x9123;
pub const MAX_GEOMETRY_INPUT_COMPONENTS_OES = 0x9123;
pub const MAX_GEOMETRY_OUTPUT_COMPONENTS = 0x9124;
pub const MAX_GEOMETRY_OUTPUT_COMPONENTS_EXT = 0x9124;
pub const MAX_GEOMETRY_OUTPUT_COMPONENTS_OES = 0x9124;
pub const MAX_FRAGMENT_INPUT_COMPONENTS = 0x9125;
pub const CONTEXT_PROFILE_MASK = 0x9126;
pub const UNPACK_COMPRESSED_BLOCK_WIDTH = 0x9127;
pub const UNPACK_COMPRESSED_BLOCK_HEIGHT = 0x9128;
pub const UNPACK_COMPRESSED_BLOCK_DEPTH = 0x9129;
pub const UNPACK_COMPRESSED_BLOCK_SIZE = 0x912A;
pub const PACK_COMPRESSED_BLOCK_WIDTH = 0x912B;
pub const PACK_COMPRESSED_BLOCK_HEIGHT = 0x912C;
pub const PACK_COMPRESSED_BLOCK_DEPTH = 0x912D;
pub const PACK_COMPRESSED_BLOCK_SIZE = 0x912E;
pub const TEXTURE_IMMUTABLE_FORMAT = 0x912F;
pub const TEXTURE_IMMUTABLE_FORMAT_EXT = 0x912F;
pub const SGX_PROGRAM_BINARY_IMG = 0x9130;
pub const RENDERBUFFER_SAMPLES_IMG = 0x9133;
pub const FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_IMG = 0x9134;
pub const MAX_SAMPLES_IMG = 0x9135;
pub const TEXTURE_SAMPLES_IMG = 0x9136;
pub const COMPRESSED_RGBA_PVRTC_2BPPV2_IMG = 0x9137;
pub const COMPRESSED_RGBA_PVRTC_4BPPV2_IMG = 0x9138;
pub const CUBIC_IMG = 0x9139;
pub const CUBIC_MIPMAP_NEAREST_IMG = 0x913A;
pub const CUBIC_MIPMAP_LINEAR_IMG = 0x913B;
pub const FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_AND_DOWNSAMPLE_IMG = 0x913C;
pub const NUM_DOWNSAMPLE_SCALES_IMG = 0x913D;
pub const DOWNSAMPLE_SCALES_IMG = 0x913E;
pub const FRAMEBUFFER_ATTACHMENT_TEXTURE_SCALE_IMG = 0x913F;
pub const MAX_DEBUG_MESSAGE_LENGTH = 0x9143;
pub const MAX_DEBUG_MESSAGE_LENGTH_AMD = 0x9143;
pub const MAX_DEBUG_MESSAGE_LENGTH_ARB = 0x9143;
pub const MAX_DEBUG_MESSAGE_LENGTH_KHR = 0x9143;
pub const MAX_DEBUG_LOGGED_MESSAGES = 0x9144;
pub const MAX_DEBUG_LOGGED_MESSAGES_AMD = 0x9144;
pub const MAX_DEBUG_LOGGED_MESSAGES_ARB = 0x9144;
pub const MAX_DEBUG_LOGGED_MESSAGES_KHR = 0x9144;
pub const DEBUG_LOGGED_MESSAGES = 0x9145;
pub const DEBUG_LOGGED_MESSAGES_AMD = 0x9145;
pub const DEBUG_LOGGED_MESSAGES_ARB = 0x9145;
pub const DEBUG_LOGGED_MESSAGES_KHR = 0x9145;
pub const DEBUG_SEVERITY_HIGH = 0x9146;
pub const DEBUG_SEVERITY_HIGH_AMD = 0x9146;
pub const DEBUG_SEVERITY_HIGH_ARB = 0x9146;
pub const DEBUG_SEVERITY_HIGH_KHR = 0x9146;
pub const DEBUG_SEVERITY_MEDIUM = 0x9147;
pub const DEBUG_SEVERITY_MEDIUM_AMD = 0x9147;
pub const DEBUG_SEVERITY_MEDIUM_ARB = 0x9147;
pub const DEBUG_SEVERITY_MEDIUM_KHR = 0x9147;
pub const DEBUG_SEVERITY_LOW = 0x9148;
pub const DEBUG_SEVERITY_LOW_AMD = 0x9148;
pub const DEBUG_SEVERITY_LOW_ARB = 0x9148;
pub const DEBUG_SEVERITY_LOW_KHR = 0x9148;
pub const DEBUG_CATEGORY_API_ERROR_AMD = 0x9149;
pub const DEBUG_CATEGORY_WINDOW_SYSTEM_AMD = 0x914A;
pub const DEBUG_CATEGORY_DEPRECATION_AMD = 0x914B;
pub const DEBUG_CATEGORY_UNDEFINED_BEHAVIOR_AMD = 0x914C;
pub const DEBUG_CATEGORY_PERFORMANCE_AMD = 0x914D;
pub const DEBUG_CATEGORY_SHADER_COMPILER_AMD = 0x914E;
pub const DEBUG_CATEGORY_APPLICATION_AMD = 0x914F;
pub const DEBUG_CATEGORY_OTHER_AMD = 0x9150;
pub const BUFFER_OBJECT_EXT = 0x9151;
pub const DATA_BUFFER_AMD = 0x9151;
pub const PERFORMANCE_MONITOR_AMD = 0x9152;
pub const QUERY_OBJECT_AMD = 0x9153;
pub const QUERY_OBJECT_EXT = 0x9153;
pub const VERTEX_ARRAY_OBJECT_AMD = 0x9154;
pub const VERTEX_ARRAY_OBJECT_EXT = 0x9154;
pub const SAMPLER_OBJECT_AMD = 0x9155;
pub const EXTERNAL_VIRTUAL_MEMORY_BUFFER_AMD = 0x9160;
pub const QUERY_BUFFER = 0x9192;
pub const QUERY_BUFFER_AMD = 0x9192;
pub const QUERY_BUFFER_BINDING = 0x9193;
pub const QUERY_BUFFER_BINDING_AMD = 0x9193;
pub const QUERY_RESULT_NO_WAIT = 0x9194;
pub const QUERY_RESULT_NO_WAIT_AMD = 0x9194;
pub const VIRTUAL_PAGE_SIZE_X_ARB = 0x9195;
pub const VIRTUAL_PAGE_SIZE_X_EXT = 0x9195;
pub const VIRTUAL_PAGE_SIZE_X_AMD = 0x9195;
pub const VIRTUAL_PAGE_SIZE_Y_ARB = 0x9196;
pub const VIRTUAL_PAGE_SIZE_Y_EXT = 0x9196;
pub const VIRTUAL_PAGE_SIZE_Y_AMD = 0x9196;
pub const VIRTUAL_PAGE_SIZE_Z_ARB = 0x9197;
pub const VIRTUAL_PAGE_SIZE_Z_EXT = 0x9197;
pub const VIRTUAL_PAGE_SIZE_Z_AMD = 0x9197;
pub const MAX_SPARSE_TEXTURE_SIZE_ARB = 0x9198;
pub const MAX_SPARSE_TEXTURE_SIZE_EXT = 0x9198;
pub const MAX_SPARSE_TEXTURE_SIZE_AMD = 0x9198;
pub const MAX_SPARSE_3D_TEXTURE_SIZE_ARB = 0x9199;
pub const MAX_SPARSE_3D_TEXTURE_SIZE_EXT = 0x9199;
pub const MAX_SPARSE_3D_TEXTURE_SIZE_AMD = 0x9199;
pub const MAX_SPARSE_ARRAY_TEXTURE_LAYERS = 0x919A;
pub const MAX_SPARSE_ARRAY_TEXTURE_LAYERS_ARB = 0x919A;
pub const MAX_SPARSE_ARRAY_TEXTURE_LAYERS_EXT = 0x919A;
pub const MIN_SPARSE_LEVEL_AMD = 0x919B;
pub const MIN_LOD_WARNING_AMD = 0x919C;
pub const TEXTURE_BUFFER_OFFSET = 0x919D;
pub const TEXTURE_BUFFER_OFFSET_EXT = 0x919D;
pub const TEXTURE_BUFFER_OFFSET_OES = 0x919D;
pub const TEXTURE_BUFFER_SIZE = 0x919E;
pub const TEXTURE_BUFFER_SIZE_EXT = 0x919E;
pub const TEXTURE_BUFFER_SIZE_OES = 0x919E;
pub const TEXTURE_BUFFER_OFFSET_ALIGNMENT = 0x919F;
pub const TEXTURE_BUFFER_OFFSET_ALIGNMENT_EXT = 0x919F;
pub const TEXTURE_BUFFER_OFFSET_ALIGNMENT_OES = 0x919F;
pub const STREAM_RASTERIZATION_AMD = 0x91A0;
pub const VERTEX_ELEMENT_SWIZZLE_AMD = 0x91A4;
pub const VERTEX_ID_SWIZZLE_AMD = 0x91A5;
pub const TEXTURE_SPARSE_ARB = 0x91A6;
pub const TEXTURE_SPARSE_EXT = 0x91A6;
pub const VIRTUAL_PAGE_SIZE_INDEX_ARB = 0x91A7;
pub const VIRTUAL_PAGE_SIZE_INDEX_EXT = 0x91A7;
pub const NUM_VIRTUAL_PAGE_SIZES_ARB = 0x91A8;
pub const NUM_VIRTUAL_PAGE_SIZES_EXT = 0x91A8;
pub const SPARSE_TEXTURE_FULL_ARRAY_CUBE_MIPMAPS_ARB = 0x91A9;
pub const SPARSE_TEXTURE_FULL_ARRAY_CUBE_MIPMAPS_EXT = 0x91A9;
pub const NUM_SPARSE_LEVELS_ARB = 0x91AA;
pub const NUM_SPARSE_LEVELS_EXT = 0x91AA;
pub const PIXELS_PER_SAMPLE_PATTERN_X_AMD = 0x91AE;
pub const PIXELS_PER_SAMPLE_PATTERN_Y_AMD = 0x91AF;
pub const MAX_SHADER_COMPILER_THREADS_KHR = 0x91B0;
pub const MAX_SHADER_COMPILER_THREADS_ARB = 0x91B0;
pub const COMPLETION_STATUS_KHR = 0x91B1;
pub const COMPLETION_STATUS_ARB = 0x91B1;
pub const RENDERBUFFER_STORAGE_SAMPLES_AMD = 0x91B2;
pub const MAX_COLOR_FRAMEBUFFER_SAMPLES_AMD = 0x91B3;
pub const MAX_COLOR_FRAMEBUFFER_STORAGE_SAMPLES_AMD = 0x91B4;
pub const MAX_DEPTH_STENCIL_FRAMEBUFFER_SAMPLES_AMD = 0x91B5;
pub const NUM_SUPPORTED_MULTISAMPLE_MODES_AMD = 0x91B6;
pub const SUPPORTED_MULTISAMPLE_MODES_AMD = 0x91B7;
pub const COMPUTE_SHADER = 0x91B9;
pub const MAX_COMPUTE_UNIFORM_BLOCKS = 0x91BB;
pub const MAX_COMPUTE_TEXTURE_IMAGE_UNITS = 0x91BC;
pub const MAX_COMPUTE_IMAGE_UNIFORMS = 0x91BD;
pub const MAX_COMPUTE_WORK_GROUP_COUNT = 0x91BE;
pub const MAX_COMPUTE_WORK_GROUP_SIZE = 0x91BF;
pub const MAX_COMPUTE_FIXED_GROUP_SIZE_ARB = 0x91BF;
pub const FLOAT16_MAT2_AMD = 0x91C5;
pub const FLOAT16_MAT3_AMD = 0x91C6;
pub const FLOAT16_MAT4_AMD = 0x91C7;
pub const FLOAT16_MAT2x3_AMD = 0x91C8;
pub const FLOAT16_MAT2x4_AMD = 0x91C9;
pub const FLOAT16_MAT3x2_AMD = 0x91CA;
pub const FLOAT16_MAT3x4_AMD = 0x91CB;
pub const FLOAT16_MAT4x2_AMD = 0x91CC;
pub const FLOAT16_MAT4x3_AMD = 0x91CD;
pub const UNPACK_FLIP_Y_WEBGL = 0x9240;
pub const UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;
pub const CONTEXT_LOST_WEBGL = 0x9242;
pub const UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;
pub const BROWSER_DEFAULT_WEBGL = 0x9244;
pub const SHADER_BINARY_DMP = 0x9250;
pub const SMAPHS30_PROGRAM_BINARY_DMP = 0x9251;
pub const SMAPHS_PROGRAM_BINARY_DMP = 0x9252;
pub const DMP_PROGRAM_BINARY_DMP = 0x9253;
pub const GCCSO_SHADER_BINARY_FJ = 0x9260;
pub const COMPRESSED_R11_EAC = 0x9270;
pub const COMPRESSED_R11_EAC_OES = 0x9270;
pub const COMPRESSED_SIGNED_R11_EAC = 0x9271;
pub const COMPRESSED_SIGNED_R11_EAC_OES = 0x9271;
pub const COMPRESSED_RG11_EAC = 0x9272;
pub const COMPRESSED_RG11_EAC_OES = 0x9272;
pub const COMPRESSED_SIGNED_RG11_EAC = 0x9273;
pub const COMPRESSED_SIGNED_RG11_EAC_OES = 0x9273;
pub const COMPRESSED_RGB8_ETC2 = 0x9274;
pub const COMPRESSED_RGB8_ETC2_OES = 0x9274;
pub const COMPRESSED_SRGB8_ETC2 = 0x9275;
pub const COMPRESSED_SRGB8_ETC2_OES = 0x9275;
pub const COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9276;
pub const COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2_OES = 0x9276;
pub const COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9277;
pub const COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2_OES = 0x9277;
pub const COMPRESSED_RGBA8_ETC2_EAC = 0x9278;
pub const COMPRESSED_RGBA8_ETC2_EAC_OES = 0x9278;
pub const COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 0x9279;
pub const COMPRESSED_SRGB8_ALPHA8_ETC2_EAC_OES = 0x9279;
pub const BLEND_PREMULTIPLIED_SRC_NV = 0x9280;
pub const BLEND_OVERLAP_NV = 0x9281;
pub const UNCORRELATED_NV = 0x9282;
pub const DISJOINT_NV = 0x9283;
pub const CONJOINT_NV = 0x9284;
pub const BLEND_ADVANCED_COHERENT_KHR = 0x9285;
pub const BLEND_ADVANCED_COHERENT_NV = 0x9285;
pub const SRC_NV = 0x9286;
pub const DST_NV = 0x9287;
pub const SRC_OVER_NV = 0x9288;
pub const DST_OVER_NV = 0x9289;
pub const SRC_IN_NV = 0x928A;
pub const DST_IN_NV = 0x928B;
pub const SRC_OUT_NV = 0x928C;
pub const DST_OUT_NV = 0x928D;
pub const SRC_ATOP_NV = 0x928E;
pub const DST_ATOP_NV = 0x928F;
pub const PLUS_NV = 0x9291;
pub const PLUS_DARKER_NV = 0x9292;
pub const MULTIPLY = 0x9294;
pub const MULTIPLY_KHR = 0x9294;
pub const MULTIPLY_NV = 0x9294;
pub const SCREEN = 0x9295;
pub const SCREEN_KHR = 0x9295;
pub const SCREEN_NV = 0x9295;
pub const OVERLAY = 0x9296;
pub const OVERLAY_KHR = 0x9296;
pub const OVERLAY_NV = 0x9296;
pub const DARKEN = 0x9297;
pub const DARKEN_KHR = 0x9297;
pub const DARKEN_NV = 0x9297;
pub const LIGHTEN = 0x9298;
pub const LIGHTEN_KHR = 0x9298;
pub const LIGHTEN_NV = 0x9298;
pub const COLORDODGE = 0x9299;
pub const COLORDODGE_KHR = 0x9299;
pub const COLORDODGE_NV = 0x9299;
pub const COLORBURN = 0x929A;
pub const COLORBURN_KHR = 0x929A;
pub const COLORBURN_NV = 0x929A;
pub const HARDLIGHT = 0x929B;
pub const HARDLIGHT_KHR = 0x929B;
pub const HARDLIGHT_NV = 0x929B;
pub const SOFTLIGHT = 0x929C;
pub const SOFTLIGHT_KHR = 0x929C;
pub const SOFTLIGHT_NV = 0x929C;
pub const DIFFERENCE = 0x929E;
pub const DIFFERENCE_KHR = 0x929E;
pub const DIFFERENCE_NV = 0x929E;
pub const MINUS_NV = 0x929F;
pub const EXCLUSION = 0x92A0;
pub const EXCLUSION_KHR = 0x92A0;
pub const EXCLUSION_NV = 0x92A0;
pub const CONTRAST_NV = 0x92A1;
pub const INVERT_RGB_NV = 0x92A3;
pub const LINEARDODGE_NV = 0x92A4;
pub const LINEARBURN_NV = 0x92A5;
pub const VIVIDLIGHT_NV = 0x92A6;
pub const LINEARLIGHT_NV = 0x92A7;
pub const PINLIGHT_NV = 0x92A8;
pub const HARDMIX_NV = 0x92A9;
pub const HSL_HUE = 0x92AD;
pub const HSL_HUE_KHR = 0x92AD;
pub const HSL_HUE_NV = 0x92AD;
pub const HSL_SATURATION = 0x92AE;
pub const HSL_SATURATION_KHR = 0x92AE;
pub const HSL_SATURATION_NV = 0x92AE;
pub const HSL_COLOR = 0x92AF;
pub const HSL_COLOR_KHR = 0x92AF;
pub const HSL_COLOR_NV = 0x92AF;
pub const HSL_LUMINOSITY = 0x92B0;
pub const HSL_LUMINOSITY_KHR = 0x92B0;
pub const HSL_LUMINOSITY_NV = 0x92B0;
pub const PLUS_CLAMPED_NV = 0x92B1;
pub const PLUS_CLAMPED_ALPHA_NV = 0x92B2;
pub const MINUS_CLAMPED_NV = 0x92B3;
pub const INVERT_OVG_NV = 0x92B4;
pub const MAX_LGPU_GPUS_NVX = 0x92BA;
pub const MULTICAST_GPUS_NV = 0x92BA;
pub const PURGED_CONTEXT_RESET_NV = 0x92BB;
pub const PRIMITIVE_BOUNDING_BOX_ARB = 0x92BE;
pub const PRIMITIVE_BOUNDING_BOX = 0x92BE;
pub const PRIMITIVE_BOUNDING_BOX_EXT = 0x92BE;
pub const PRIMITIVE_BOUNDING_BOX_OES = 0x92BE;
pub const ALPHA_TO_COVERAGE_DITHER_MODE_NV = 0x92BF;
pub const ATOMIC_COUNTER_BUFFER = 0x92C0;
pub const ATOMIC_COUNTER_BUFFER_BINDING = 0x92C1;
pub const ATOMIC_COUNTER_BUFFER_START = 0x92C2;
pub const ATOMIC_COUNTER_BUFFER_SIZE = 0x92C3;
pub const ATOMIC_COUNTER_BUFFER_DATA_SIZE = 0x92C4;
pub const ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS = 0x92C5;
pub const ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES = 0x92C6;
pub const ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER = 0x92C7;
pub const ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER = 0x92C8;
pub const ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER = 0x92C9;
pub const ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER = 0x92CA;
pub const ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER = 0x92CB;
pub const MAX_VERTEX_ATOMIC_COUNTER_BUFFERS = 0x92CC;
pub const MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS = 0x92CD;
pub const MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS_EXT = 0x92CD;
pub const MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS_OES = 0x92CD;
pub const MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS = 0x92CE;
pub const MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS_EXT = 0x92CE;
pub const MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS_OES = 0x92CE;
pub const MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS = 0x92CF;
pub const MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS_EXT = 0x92CF;
pub const MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS_OES = 0x92CF;
pub const MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS = 0x92D0;
pub const MAX_COMBINED_ATOMIC_COUNTER_BUFFERS = 0x92D1;
pub const MAX_VERTEX_ATOMIC_COUNTERS = 0x92D2;
pub const MAX_TESS_CONTROL_ATOMIC_COUNTERS = 0x92D3;
pub const MAX_TESS_CONTROL_ATOMIC_COUNTERS_EXT = 0x92D3;
pub const MAX_TESS_CONTROL_ATOMIC_COUNTERS_OES = 0x92D3;
pub const MAX_TESS_EVALUATION_ATOMIC_COUNTERS = 0x92D4;
pub const MAX_TESS_EVALUATION_ATOMIC_COUNTERS_EXT = 0x92D4;
pub const MAX_TESS_EVALUATION_ATOMIC_COUNTERS_OES = 0x92D4;
pub const MAX_GEOMETRY_ATOMIC_COUNTERS = 0x92D5;
pub const MAX_GEOMETRY_ATOMIC_COUNTERS_EXT = 0x92D5;
pub const MAX_GEOMETRY_ATOMIC_COUNTERS_OES = 0x92D5;
pub const MAX_FRAGMENT_ATOMIC_COUNTERS = 0x92D6;
pub const MAX_COMBINED_ATOMIC_COUNTERS = 0x92D7;
pub const MAX_ATOMIC_COUNTER_BUFFER_SIZE = 0x92D8;
pub const ACTIVE_ATOMIC_COUNTER_BUFFERS = 0x92D9;
pub const UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX = 0x92DA;
pub const UNSIGNED_INT_ATOMIC_COUNTER = 0x92DB;
pub const MAX_ATOMIC_COUNTER_BUFFER_BINDINGS = 0x92DC;
pub const FRAGMENT_COVERAGE_TO_COLOR_NV = 0x92DD;
pub const FRAGMENT_COVERAGE_COLOR_NV = 0x92DE;
pub const MESH_OUTPUT_PER_VERTEX_GRANULARITY_NV = 0x92DF;
pub const DEBUG_OUTPUT = 0x92E0;
pub const DEBUG_OUTPUT_KHR = 0x92E0;
pub const UNIFORM = 0x92E1;
pub const UNIFORM_BLOCK = 0x92E2;
pub const PROGRAM_INPUT = 0x92E3;
pub const PROGRAM_OUTPUT = 0x92E4;
pub const BUFFER_VARIABLE = 0x92E5;
pub const SHADER_STORAGE_BLOCK = 0x92E6;
pub const IS_PER_PATCH = 0x92E7;
pub const IS_PER_PATCH_EXT = 0x92E7;
pub const IS_PER_PATCH_OES = 0x92E7;
pub const VERTEX_SUBROUTINE = 0x92E8;
pub const TESS_CONTROL_SUBROUTINE = 0x92E9;
pub const TESS_EVALUATION_SUBROUTINE = 0x92EA;
pub const GEOMETRY_SUBROUTINE = 0x92EB;
pub const FRAGMENT_SUBROUTINE = 0x92EC;
pub const COMPUTE_SUBROUTINE = 0x92ED;
pub const VERTEX_SUBROUTINE_UNIFORM = 0x92EE;
pub const TESS_CONTROL_SUBROUTINE_UNIFORM = 0x92EF;
pub const TESS_EVALUATION_SUBROUTINE_UNIFORM = 0x92F0;
pub const GEOMETRY_SUBROUTINE_UNIFORM = 0x92F1;
pub const FRAGMENT_SUBROUTINE_UNIFORM = 0x92F2;
pub const COMPUTE_SUBROUTINE_UNIFORM = 0x92F3;
pub const TRANSFORM_FEEDBACK_VARYING = 0x92F4;
pub const ACTIVE_RESOURCES = 0x92F5;
pub const MAX_NAME_LENGTH = 0x92F6;
pub const MAX_NUM_ACTIVE_VARIABLES = 0x92F7;
pub const MAX_NUM_COMPATIBLE_SUBROUTINES = 0x92F8;
pub const NAME_LENGTH = 0x92F9;
pub const TYPE = 0x92FA;
pub const ARRAY_SIZE = 0x92FB;
pub const OFFSET = 0x92FC;
pub const BLOCK_INDEX = 0x92FD;
pub const ARRAY_STRIDE = 0x92FE;
pub const MATRIX_STRIDE = 0x92FF;
pub const IS_ROW_MAJOR = 0x9300;
pub const ATOMIC_COUNTER_BUFFER_INDEX = 0x9301;
pub const BUFFER_BINDING = 0x9302;
pub const BUFFER_DATA_SIZE = 0x9303;
pub const NUM_ACTIVE_VARIABLES = 0x9304;
pub const ACTIVE_VARIABLES = 0x9305;
pub const REFERENCED_BY_VERTEX_SHADER = 0x9306;
pub const REFERENCED_BY_TESS_CONTROL_SHADER = 0x9307;
pub const REFERENCED_BY_TESS_CONTROL_SHADER_EXT = 0x9307;
pub const REFERENCED_BY_TESS_CONTROL_SHADER_OES = 0x9307;
pub const REFERENCED_BY_TESS_EVALUATION_SHADER = 0x9308;
pub const REFERENCED_BY_TESS_EVALUATION_SHADER_EXT = 0x9308;
pub const REFERENCED_BY_TESS_EVALUATION_SHADER_OES = 0x9308;
pub const REFERENCED_BY_GEOMETRY_SHADER = 0x9309;
pub const REFERENCED_BY_GEOMETRY_SHADER_EXT = 0x9309;
pub const REFERENCED_BY_GEOMETRY_SHADER_OES = 0x9309;
pub const REFERENCED_BY_FRAGMENT_SHADER = 0x930A;
pub const REFERENCED_BY_COMPUTE_SHADER = 0x930B;
pub const TOP_LEVEL_ARRAY_SIZE = 0x930C;
pub const TOP_LEVEL_ARRAY_STRIDE = 0x930D;
pub const LOCATION = 0x930E;
pub const LOCATION_INDEX = 0x930F;
pub const LOCATION_INDEX_EXT = 0x930F;
pub const FRAMEBUFFER_DEFAULT_WIDTH = 0x9310;
pub const FRAMEBUFFER_DEFAULT_HEIGHT = 0x9311;
pub const FRAMEBUFFER_DEFAULT_LAYERS = 0x9312;
pub const FRAMEBUFFER_DEFAULT_LAYERS_EXT = 0x9312;
pub const FRAMEBUFFER_DEFAULT_LAYERS_OES = 0x9312;
pub const FRAMEBUFFER_DEFAULT_SAMPLES = 0x9313;
pub const FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS = 0x9314;
pub const MAX_FRAMEBUFFER_WIDTH = 0x9315;
pub const MAX_FRAMEBUFFER_HEIGHT = 0x9316;
pub const MAX_FRAMEBUFFER_LAYERS = 0x9317;
pub const MAX_FRAMEBUFFER_LAYERS_EXT = 0x9317;
pub const MAX_FRAMEBUFFER_LAYERS_OES = 0x9317;
pub const MAX_FRAMEBUFFER_SAMPLES = 0x9318;
pub const RASTER_MULTISAMPLE_EXT = 0x9327;
pub const RASTER_SAMPLES_EXT = 0x9328;
pub const MAX_RASTER_SAMPLES_EXT = 0x9329;
pub const RASTER_FIXED_SAMPLE_LOCATIONS_EXT = 0x932A;
pub const MULTISAMPLE_RASTERIZATION_ALLOWED_EXT = 0x932B;
pub const EFFECTIVE_RASTER_SAMPLES_EXT = 0x932C;
pub const DEPTH_SAMPLES_NV = 0x932D;
pub const STENCIL_SAMPLES_NV = 0x932E;
pub const MIXED_DEPTH_SAMPLES_SUPPORTED_NV = 0x932F;
pub const MIXED_STENCIL_SAMPLES_SUPPORTED_NV = 0x9330;
pub const COVERAGE_MODULATION_TABLE_NV = 0x9331;
pub const COVERAGE_MODULATION_NV = 0x9332;
pub const COVERAGE_MODULATION_TABLE_SIZE_NV = 0x9333;
pub const WARP_SIZE_NV = 0x9339;
pub const WARPS_PER_SM_NV = 0x933A;
pub const SM_COUNT_NV = 0x933B;
pub const FILL_RECTANGLE_NV = 0x933C;
pub const SAMPLE_LOCATION_SUBPIXEL_BITS_ARB = 0x933D;
pub const SAMPLE_LOCATION_SUBPIXEL_BITS_NV = 0x933D;
pub const SAMPLE_LOCATION_PIXEL_GRID_WIDTH_ARB = 0x933E;
pub const SAMPLE_LOCATION_PIXEL_GRID_WIDTH_NV = 0x933E;
pub const SAMPLE_LOCATION_PIXEL_GRID_HEIGHT_ARB = 0x933F;
pub const SAMPLE_LOCATION_PIXEL_GRID_HEIGHT_NV = 0x933F;
pub const PROGRAMMABLE_SAMPLE_LOCATION_TABLE_SIZE_ARB = 0x9340;
pub const PROGRAMMABLE_SAMPLE_LOCATION_TABLE_SIZE_NV = 0x9340;
pub const PROGRAMMABLE_SAMPLE_LOCATION_ARB = 0x9341;
pub const PROGRAMMABLE_SAMPLE_LOCATION_NV = 0x9341;
pub const FRAMEBUFFER_PROGRAMMABLE_SAMPLE_LOCATIONS_ARB = 0x9342;
pub const FRAMEBUFFER_PROGRAMMABLE_SAMPLE_LOCATIONS_NV = 0x9342;
pub const FRAMEBUFFER_SAMPLE_LOCATION_PIXEL_GRID_ARB = 0x9343;
pub const FRAMEBUFFER_SAMPLE_LOCATION_PIXEL_GRID_NV = 0x9343;
pub const MAX_COMPUTE_VARIABLE_GROUP_INVOCATIONS_ARB = 0x9344;
pub const MAX_COMPUTE_VARIABLE_GROUP_SIZE_ARB = 0x9345;
pub const CONSERVATIVE_RASTERIZATION_NV = 0x9346;
pub const SUBPIXEL_PRECISION_BIAS_X_BITS_NV = 0x9347;
pub const SUBPIXEL_PRECISION_BIAS_Y_BITS_NV = 0x9348;
pub const MAX_SUBPIXEL_PRECISION_BIAS_BITS_NV = 0x9349;
pub const LOCATION_COMPONENT = 0x934A;
pub const TRANSFORM_FEEDBACK_BUFFER_INDEX = 0x934B;
pub const TRANSFORM_FEEDBACK_BUFFER_STRIDE = 0x934C;
pub const ALPHA_TO_COVERAGE_DITHER_DEFAULT_NV = 0x934D;
pub const ALPHA_TO_COVERAGE_DITHER_ENABLE_NV = 0x934E;
pub const ALPHA_TO_COVERAGE_DITHER_DISABLE_NV = 0x934F;
pub const VIEWPORT_SWIZZLE_POSITIVE_X_NV = 0x9350;
pub const VIEWPORT_SWIZZLE_NEGATIVE_X_NV = 0x9351;
pub const VIEWPORT_SWIZZLE_POSITIVE_Y_NV = 0x9352;
pub const VIEWPORT_SWIZZLE_NEGATIVE_Y_NV = 0x9353;
pub const VIEWPORT_SWIZZLE_POSITIVE_Z_NV = 0x9354;
pub const VIEWPORT_SWIZZLE_NEGATIVE_Z_NV = 0x9355;
pub const VIEWPORT_SWIZZLE_POSITIVE_W_NV = 0x9356;
pub const VIEWPORT_SWIZZLE_NEGATIVE_W_NV = 0x9357;
pub const VIEWPORT_SWIZZLE_X_NV = 0x9358;
pub const VIEWPORT_SWIZZLE_Y_NV = 0x9359;
pub const VIEWPORT_SWIZZLE_Z_NV = 0x935A;
pub const VIEWPORT_SWIZZLE_W_NV = 0x935B;
pub const CLIP_ORIGIN = 0x935C;
pub const CLIP_ORIGIN_EXT = 0x935C;
pub const CLIP_DEPTH_MODE = 0x935D;
pub const CLIP_DEPTH_MODE_EXT = 0x935D;
pub const NEGATIVE_ONE_TO_ONE = 0x935E;
pub const NEGATIVE_ONE_TO_ONE_EXT = 0x935E;
pub const ZERO_TO_ONE = 0x935F;
pub const ZERO_TO_ONE_EXT = 0x935F;
pub const CLEAR_TEXTURE = 0x9365;
pub const TEXTURE_REDUCTION_MODE_ARB = 0x9366;
pub const TEXTURE_REDUCTION_MODE_EXT = 0x9366;
pub const WEIGHTED_AVERAGE_ARB = 0x9367;
pub const WEIGHTED_AVERAGE_EXT = 0x9367;
pub const FONT_GLYPHS_AVAILABLE_NV = 0x9368;
pub const FONT_TARGET_UNAVAILABLE_NV = 0x9369;
pub const FONT_UNAVAILABLE_NV = 0x936A;
pub const FONT_UNINTELLIGIBLE_NV = 0x936B;
pub const STANDARD_FONT_FORMAT_NV = 0x936C;
pub const FRAGMENT_INPUT_NV = 0x936D;
pub const UNIFORM_BUFFER_UNIFIED_NV = 0x936E;
pub const UNIFORM_BUFFER_ADDRESS_NV = 0x936F;
pub const UNIFORM_BUFFER_LENGTH_NV = 0x9370;
pub const MULTISAMPLES_NV = 0x9371;
pub const SUPERSAMPLE_SCALE_X_NV = 0x9372;
pub const SUPERSAMPLE_SCALE_Y_NV = 0x9373;
pub const CONFORMANT_NV = 0x9374;
pub const CONSERVATIVE_RASTER_DILATE_NV = 0x9379;
pub const CONSERVATIVE_RASTER_DILATE_RANGE_NV = 0x937A;
pub const CONSERVATIVE_RASTER_DILATE_GRANULARITY_NV = 0x937B;
pub const VIEWPORT_POSITION_W_SCALE_NV = 0x937C;
pub const VIEWPORT_POSITION_W_SCALE_X_COEFF_NV = 0x937D;
pub const VIEWPORT_POSITION_W_SCALE_Y_COEFF_NV = 0x937E;
pub const REPRESENTATIVE_FRAGMENT_TEST_NV = 0x937F;
pub const NUM_SAMPLE_COUNTS = 0x9380;
pub const MULTISAMPLE_LINE_WIDTH_RANGE_ARB = 0x9381;
pub const MULTISAMPLE_LINE_WIDTH_RANGE = 0x9381;
pub const MULTISAMPLE_LINE_WIDTH_GRANULARITY_ARB = 0x9382;
pub const MULTISAMPLE_LINE_WIDTH_GRANULARITY = 0x9382;
pub const VIEW_CLASS_EAC_R11 = 0x9383;
pub const VIEW_CLASS_EAC_RG11 = 0x9384;
pub const VIEW_CLASS_ETC2_RGB = 0x9385;
pub const VIEW_CLASS_ETC2_RGBA = 0x9386;
pub const VIEW_CLASS_ETC2_EAC_RGBA = 0x9387;
pub const VIEW_CLASS_ASTC_4x4_RGBA = 0x9388;
pub const VIEW_CLASS_ASTC_5x4_RGBA = 0x9389;
pub const VIEW_CLASS_ASTC_5x5_RGBA = 0x938A;
pub const VIEW_CLASS_ASTC_6x5_RGBA = 0x938B;
pub const VIEW_CLASS_ASTC_6x6_RGBA = 0x938C;
pub const VIEW_CLASS_ASTC_8x5_RGBA = 0x938D;
pub const VIEW_CLASS_ASTC_8x6_RGBA = 0x938E;
pub const VIEW_CLASS_ASTC_8x8_RGBA = 0x938F;
pub const VIEW_CLASS_ASTC_10x5_RGBA = 0x9390;
pub const VIEW_CLASS_ASTC_10x6_RGBA = 0x9391;
pub const VIEW_CLASS_ASTC_10x8_RGBA = 0x9392;
pub const VIEW_CLASS_ASTC_10x10_RGBA = 0x9393;
pub const VIEW_CLASS_ASTC_12x10_RGBA = 0x9394;
pub const VIEW_CLASS_ASTC_12x12_RGBA = 0x9395;
pub const TRANSLATED_SHADER_SOURCE_LENGTH_ANGLE = 0x93A0;
pub const BGRA8_EXT = 0x93A1;
pub const TEXTURE_USAGE_ANGLE = 0x93A2;
pub const FRAMEBUFFER_ATTACHMENT_ANGLE = 0x93A3;
pub const PACK_REVERSE_ROW_ORDER_ANGLE = 0x93A4;
pub const PROGRAM_BINARY_ANGLE = 0x93A6;
pub const COMPRESSED_RGBA_ASTC_4x4 = 0x93B0;
pub const COMPRESSED_RGBA_ASTC_4x4_KHR = 0x93B0;
pub const COMPRESSED_RGBA_ASTC_5x4 = 0x93B1;
pub const COMPRESSED_RGBA_ASTC_5x4_KHR = 0x93B1;
pub const COMPRESSED_RGBA_ASTC_5x5 = 0x93B2;
pub const COMPRESSED_RGBA_ASTC_5x5_KHR = 0x93B2;
pub const COMPRESSED_RGBA_ASTC_6x5 = 0x93B3;
pub const COMPRESSED_RGBA_ASTC_6x5_KHR = 0x93B3;
pub const COMPRESSED_RGBA_ASTC_6x6 = 0x93B4;
pub const COMPRESSED_RGBA_ASTC_6x6_KHR = 0x93B4;
pub const COMPRESSED_RGBA_ASTC_8x5 = 0x93B5;
pub const COMPRESSED_RGBA_ASTC_8x5_KHR = 0x93B5;
pub const COMPRESSED_RGBA_ASTC_8x6 = 0x93B6;
pub const COMPRESSED_RGBA_ASTC_8x6_KHR = 0x93B6;
pub const COMPRESSED_RGBA_ASTC_8x8 = 0x93B7;
pub const COMPRESSED_RGBA_ASTC_8x8_KHR = 0x93B7;
pub const COMPRESSED_RGBA_ASTC_10x5 = 0x93B8;
pub const COMPRESSED_RGBA_ASTC_10x5_KHR = 0x93B8;
pub const COMPRESSED_RGBA_ASTC_10x6 = 0x93B9;
pub const COMPRESSED_RGBA_ASTC_10x6_KHR = 0x93B9;
pub const COMPRESSED_RGBA_ASTC_10x8 = 0x93BA;
pub const COMPRESSED_RGBA_ASTC_10x8_KHR = 0x93BA;
pub const COMPRESSED_RGBA_ASTC_10x10 = 0x93BB;
pub const COMPRESSED_RGBA_ASTC_10x10_KHR = 0x93BB;
pub const COMPRESSED_RGBA_ASTC_12x10 = 0x93BC;
pub const COMPRESSED_RGBA_ASTC_12x10_KHR = 0x93BC;
pub const COMPRESSED_RGBA_ASTC_12x12 = 0x93BD;
pub const COMPRESSED_RGBA_ASTC_12x12_KHR = 0x93BD;
pub const COMPRESSED_RGBA_ASTC_3x3x3_OES = 0x93C0;
pub const COMPRESSED_RGBA_ASTC_4x3x3_OES = 0x93C1;
pub const COMPRESSED_RGBA_ASTC_4x4x3_OES = 0x93C2;
pub const COMPRESSED_RGBA_ASTC_4x4x4_OES = 0x93C3;
pub const COMPRESSED_RGBA_ASTC_5x4x4_OES = 0x93C4;
pub const COMPRESSED_RGBA_ASTC_5x5x4_OES = 0x93C5;
pub const COMPRESSED_RGBA_ASTC_5x5x5_OES = 0x93C6;
pub const COMPRESSED_RGBA_ASTC_6x5x5_OES = 0x93C7;
pub const COMPRESSED_RGBA_ASTC_6x6x5_OES = 0x93C8;
pub const COMPRESSED_RGBA_ASTC_6x6x6_OES = 0x93C9;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_4x4 = 0x93D0;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 0x93D0;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_5x4 = 0x93D1;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 0x93D1;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_5x5 = 0x93D2;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 0x93D2;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_6x5 = 0x93D3;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 0x93D3;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_6x6 = 0x93D4;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 0x93D4;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_8x5 = 0x93D5;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 0x93D5;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_8x6 = 0x93D6;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 0x93D6;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_8x8 = 0x93D7;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 0x93D7;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_10x5 = 0x93D8;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 0x93D8;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_10x6 = 0x93D9;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 0x93D9;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_10x8 = 0x93DA;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 0x93DA;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_10x10 = 0x93DB;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 0x93DB;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_12x10 = 0x93DC;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 0x93DC;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_12x12 = 0x93DD;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 0x93DD;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3_OES = 0x93E0;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3_OES = 0x93E1;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3_OES = 0x93E2;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4_OES = 0x93E3;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4_OES = 0x93E4;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4_OES = 0x93E5;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5_OES = 0x93E6;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5_OES = 0x93E7;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5_OES = 0x93E8;
pub const COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6_OES = 0x93E9;
pub const COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV2_IMG = 0x93F0;
pub const COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV2_IMG = 0x93F1;
pub const PERFQUERY_COUNTER_EVENT_INTEL = 0x94F0;
pub const PERFQUERY_COUNTER_DURATION_NORM_INTEL = 0x94F1;
pub const PERFQUERY_COUNTER_DURATION_RAW_INTEL = 0x94F2;
pub const PERFQUERY_COUNTER_THROUGHPUT_INTEL = 0x94F3;
pub const PERFQUERY_COUNTER_RAW_INTEL = 0x94F4;
pub const PERFQUERY_COUNTER_TIMESTAMP_INTEL = 0x94F5;
pub const PERFQUERY_COUNTER_DATA_UINT32_INTEL = 0x94F8;
pub const PERFQUERY_COUNTER_DATA_UINT64_INTEL = 0x94F9;
pub const PERFQUERY_COUNTER_DATA_FLOAT_INTEL = 0x94FA;
pub const PERFQUERY_COUNTER_DATA_DOUBLE_INTEL = 0x94FB;
pub const PERFQUERY_COUNTER_DATA_BOOL32_INTEL = 0x94FC;
pub const PERFQUERY_QUERY_NAME_LENGTH_MAX_INTEL = 0x94FD;
pub const PERFQUERY_COUNTER_NAME_LENGTH_MAX_INTEL = 0x94FE;
pub const PERFQUERY_COUNTER_DESC_LENGTH_MAX_INTEL = 0x94FF;
pub const PERFQUERY_GPA_EXTENDED_COUNTERS_INTEL = 0x9500;
pub const LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_EXT = 0x9530;
pub const LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_EXT = 0x9531;
pub const SUBGROUP_SIZE_KHR = 0x9532;
pub const SUBGROUP_SUPPORTED_STAGES_KHR = 0x9533;
pub const SUBGROUP_SUPPORTED_FEATURES_KHR = 0x9534;
pub const SUBGROUP_QUAD_ALL_STAGES_KHR = 0x9535;
pub const MAX_MESH_TOTAL_MEMORY_SIZE_NV = 0x9536;
pub const MAX_TASK_TOTAL_MEMORY_SIZE_NV = 0x9537;
pub const MAX_MESH_OUTPUT_VERTICES_NV = 0x9538;
pub const MAX_MESH_OUTPUT_PRIMITIVES_NV = 0x9539;
pub const MAX_TASK_OUTPUT_COUNT_NV = 0x953A;
pub const MAX_MESH_WORK_GROUP_SIZE_NV = 0x953B;
pub const MAX_TASK_WORK_GROUP_SIZE_NV = 0x953C;
pub const MAX_DRAW_MESH_TASKS_COUNT_NV = 0x953D;
pub const MESH_WORK_GROUP_SIZE_NV = 0x953E;
pub const TASK_WORK_GROUP_SIZE_NV = 0x953F;
pub const QUERY_RESOURCE_TYPE_VIDMEM_ALLOC_NV = 0x9540;
pub const QUERY_RESOURCE_MEMTYPE_VIDMEM_NV = 0x9542;
pub const MESH_OUTPUT_PER_PRIMITIVE_GRANULARITY_NV = 0x9543;
pub const QUERY_RESOURCE_SYS_RESERVED_NV = 0x9544;
pub const QUERY_RESOURCE_TEXTURE_NV = 0x9545;
pub const QUERY_RESOURCE_RENDERBUFFER_NV = 0x9546;
pub const QUERY_RESOURCE_BUFFEROBJECT_NV = 0x9547;
pub const PER_GPU_STORAGE_NV = 0x9548;
pub const MULTICAST_PROGRAMMABLE_SAMPLE_LOCATION_NV = 0x9549;
pub const UPLOAD_GPU_MASK_NVX = 0x954A;
pub const CONSERVATIVE_RASTER_MODE_NV = 0x954D;
pub const CONSERVATIVE_RASTER_MODE_POST_SNAP_NV = 0x954E;
pub const CONSERVATIVE_RASTER_MODE_PRE_SNAP_TRIANGLES_NV = 0x954F;
pub const CONSERVATIVE_RASTER_MODE_PRE_SNAP_NV = 0x9550;
pub const SHADER_BINARY_FORMAT_SPIR_V = 0x9551;
pub const SHADER_BINARY_FORMAT_SPIR_V_ARB = 0x9551;
pub const SPIR_V_BINARY = 0x9552;
pub const SPIR_V_BINARY_ARB = 0x9552;
pub const SPIR_V_EXTENSIONS = 0x9553;
pub const NUM_SPIR_V_EXTENSIONS = 0x9554;
pub const SCISSOR_TEST_EXCLUSIVE_NV = 0x9555;
pub const SCISSOR_BOX_EXCLUSIVE_NV = 0x9556;
pub const MAX_MESH_VIEWS_NV = 0x9557;
pub const RENDER_GPU_MASK_NV = 0x9558;
pub const MESH_SHADER_NV = 0x9559;
pub const TASK_SHADER_NV = 0x955A;
pub const SHADING_RATE_IMAGE_BINDING_NV = 0x955B;
pub const SHADING_RATE_IMAGE_TEXEL_WIDTH_NV = 0x955C;
pub const SHADING_RATE_IMAGE_TEXEL_HEIGHT_NV = 0x955D;
pub const SHADING_RATE_IMAGE_PALETTE_SIZE_NV = 0x955E;
pub const MAX_COARSE_FRAGMENT_SAMPLES_NV = 0x955F;
pub const SHADING_RATE_IMAGE_NV = 0x9563;
pub const SHADING_RATE_NO_INVOCATIONS_NV = 0x9564;
pub const SHADING_RATE_1_INVOCATION_PER_PIXEL_NV = 0x9565;
pub const SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV = 0x9566;
pub const SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV = 0x9567;
pub const SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV = 0x9568;
pub const SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV = 0x9569;
pub const SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV = 0x956A;
pub const SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV = 0x956B;
pub const SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV = 0x956C;
pub const SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV = 0x956D;
pub const SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV = 0x956E;
pub const SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV = 0x956F;
pub const MESH_VERTICES_OUT_NV = 0x9579;
pub const MESH_PRIMITIVES_OUT_NV = 0x957A;
pub const MESH_OUTPUT_TYPE_NV = 0x957B;
pub const MESH_SUBROUTINE_NV = 0x957C;
pub const TASK_SUBROUTINE_NV = 0x957D;
pub const MESH_SUBROUTINE_UNIFORM_NV = 0x957E;
pub const TASK_SUBROUTINE_UNIFORM_NV = 0x957F;
pub const TEXTURE_TILING_EXT = 0x9580;
pub const DEDICATED_MEMORY_OBJECT_EXT = 0x9581;
pub const NUM_TILING_TYPES_EXT = 0x9582;
pub const TILING_TYPES_EXT = 0x9583;
pub const OPTIMAL_TILING_EXT = 0x9584;
pub const LINEAR_TILING_EXT = 0x9585;
pub const HANDLE_TYPE_OPAQUE_FD_EXT = 0x9586;
pub const HANDLE_TYPE_OPAQUE_WIN32_EXT = 0x9587;
pub const HANDLE_TYPE_OPAQUE_WIN32_KMT_EXT = 0x9588;
pub const HANDLE_TYPE_D3D12_TILEPOOL_EXT = 0x9589;
pub const HANDLE_TYPE_D3D12_RESOURCE_EXT = 0x958A;
pub const HANDLE_TYPE_D3D11_IMAGE_EXT = 0x958B;
pub const HANDLE_TYPE_D3D11_IMAGE_KMT_EXT = 0x958C;
pub const LAYOUT_GENERAL_EXT = 0x958D;
pub const LAYOUT_COLOR_ATTACHMENT_EXT = 0x958E;
pub const LAYOUT_DEPTH_STENCIL_ATTACHMENT_EXT = 0x958F;
pub const LAYOUT_DEPTH_STENCIL_READ_ONLY_EXT = 0x9590;
pub const LAYOUT_SHADER_READ_ONLY_EXT = 0x9591;
pub const LAYOUT_TRANSFER_SRC_EXT = 0x9592;
pub const LAYOUT_TRANSFER_DST_EXT = 0x9593;
pub const HANDLE_TYPE_D3D12_FENCE_EXT = 0x9594;
pub const D3D12_FENCE_VALUE_EXT = 0x9595;
pub const TIMELINE_SEMAPHORE_VALUE_NV = 0x9595;
pub const NUM_DEVICE_UUIDS_EXT = 0x9596;
pub const DEVICE_UUID_EXT = 0x9597;
pub const DRIVER_UUID_EXT = 0x9598;
pub const DEVICE_LUID_EXT = 0x9599;
pub const DEVICE_NODE_MASK_EXT = 0x959A;
pub const PROTECTED_MEMORY_OBJECT_EXT = 0x959B;
pub const UNIFORM_BLOCK_REFERENCED_BY_MESH_SHADER_NV = 0x959C;
pub const UNIFORM_BLOCK_REFERENCED_BY_TASK_SHADER_NV = 0x959D;
pub const ATOMIC_COUNTER_BUFFER_REFERENCED_BY_MESH_SHADER_NV = 0x959E;
pub const ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TASK_SHADER_NV = 0x959F;
pub const REFERENCED_BY_MESH_SHADER_NV = 0x95A0;
pub const REFERENCED_BY_TASK_SHADER_NV = 0x95A1;
pub const MAX_MESH_WORK_GROUP_INVOCATIONS_NV = 0x95A2;
pub const MAX_TASK_WORK_GROUP_INVOCATIONS_NV = 0x95A3;
pub const ATTACHED_MEMORY_OBJECT_NV = 0x95A4;
pub const ATTACHED_MEMORY_OFFSET_NV = 0x95A5;
pub const MEMORY_ATTACHABLE_ALIGNMENT_NV = 0x95A6;
pub const MEMORY_ATTACHABLE_SIZE_NV = 0x95A7;
pub const MEMORY_ATTACHABLE_NV = 0x95A8;
pub const DETACHED_MEMORY_INCARNATION_NV = 0x95A9;
pub const DETACHED_TEXTURES_NV = 0x95AA;
pub const DETACHED_BUFFERS_NV = 0x95AB;
pub const MAX_DETACHED_TEXTURES_NV = 0x95AC;
pub const MAX_DETACHED_BUFFERS_NV = 0x95AD;
pub const SHADING_RATE_SAMPLE_ORDER_DEFAULT_NV = 0x95AE;
pub const SHADING_RATE_SAMPLE_ORDER_PIXEL_MAJOR_NV = 0x95AF;
pub const SHADING_RATE_SAMPLE_ORDER_SAMPLE_MAJOR_NV = 0x95B0;
pub const SHADING_RATE_IMAGE_PER_PRIMITIVE_NV = 0x95B1;
pub const SHADING_RATE_IMAGE_PALETTE_COUNT_NV = 0x95B2;
pub const SEMAPHORE_TYPE_NV = 0x95B3;
pub const SEMAPHORE_TYPE_BINARY_NV = 0x95B4;
pub const SEMAPHORE_TYPE_TIMELINE_NV = 0x95B5;
pub const MAX_TIMELINE_SEMAPHORE_VALUE_DIFFERENCE_NV = 0x95B6;
pub const FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_OVR = 0x9630;
pub const MAX_VIEWS_OVR = 0x9631;
pub const FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_OVR = 0x9632;
pub const FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR = 0x9633;
pub const GS_SHADER_BINARY_MTK = 0x9640;
pub const GS_PROGRAM_BINARY_MTK = 0x9641;
pub const MAX_SHADER_COMBINED_LOCAL_STORAGE_FAST_SIZE_EXT = 0x9650;
pub const MAX_SHADER_COMBINED_LOCAL_STORAGE_SIZE_EXT = 0x9651;
pub const FRAMEBUFFER_INCOMPLETE_INSUFFICIENT_SHADER_COMBINED_LOCAL_STORAGE_EXT = 0x9652;
pub const TEXTURE_FOVEATED_CUTOFF_DENSITY_QCOM = 0x96A0;
pub const FRAMEBUFFER_FETCH_NONCOHERENT_QCOM = 0x96A2;
pub const VALIDATE_SHADER_BINARY_QCOM = 0x96A3;
pub const SHADING_RATE_QCOM = 0x96A4;
pub const SHADING_RATE_PRESERVE_ASPECT_RATIO_QCOM = 0x96A5;
pub const SHADING_RATE_1X1_PIXELS_QCOM = 0x96A6;
pub const SHADING_RATE_1X2_PIXELS_QCOM = 0x96A7;
pub const SHADING_RATE_2X1_PIXELS_QCOM = 0x96A8;
pub const SHADING_RATE_2X2_PIXELS_QCOM = 0x96A9;
pub const SHADING_RATE_1X4_PIXELS_QCOM = 0x96AA;
pub const SHADING_RATE_4X1_PIXELS_QCOM = 0x96AB;
pub const SHADING_RATE_4X2_PIXELS_QCOM = 0x96AC;
pub const SHADING_RATE_2X4_PIXELS_QCOM = 0x96AD;
pub const SHADING_RATE_4X4_PIXELS_QCOM = 0x96AE;
pub const RASTER_POSITION_UNCLIPPED_IBM = 0x19262;
pub const CULL_VERTEX_IBM = 103050;
pub const ALL_STATIC_DATA_IBM = 103060;
pub const STATIC_VERTEX_ARRAY_IBM = 103061;
pub const VERTEX_ARRAY_LIST_IBM = 103070;
pub const NORMAL_ARRAY_LIST_IBM = 103071;
pub const COLOR_ARRAY_LIST_IBM = 103072;
pub const INDEX_ARRAY_LIST_IBM = 103073;
pub const TEXTURE_COORD_ARRAY_LIST_IBM = 103074;
pub const EDGE_FLAG_ARRAY_LIST_IBM = 103075;
pub const FOG_COORDINATE_ARRAY_LIST_IBM = 103076;
pub const SECONDARY_COLOR_ARRAY_LIST_IBM = 103077;
pub const VERTEX_ARRAY_LIST_STRIDE_IBM = 103080;
pub const NORMAL_ARRAY_LIST_STRIDE_IBM = 103081;
pub const COLOR_ARRAY_LIST_STRIDE_IBM = 103082;
pub const INDEX_ARRAY_LIST_STRIDE_IBM = 103083;
pub const TEXTURE_COORD_ARRAY_LIST_STRIDE_IBM = 103084;
pub const EDGE_FLAG_ARRAY_LIST_STRIDE_IBM = 103085;
pub const FOG_COORDINATE_ARRAY_LIST_STRIDE_IBM = 103086;
pub const SECONDARY_COLOR_ARRAY_LIST_STRIDE_IBM = 103087;
pub const PREFER_DOUBLEBUFFER_HINT_PGI = 0x1A1F8;
pub const CONSERVE_MEMORY_HINT_PGI = 0x1A1FD;
pub const RECLAIM_MEMORY_HINT_PGI = 0x1A1FE;
pub const NATIVE_GRAPHICS_HANDLE_PGI = 0x1A202;
pub const NATIVE_GRAPHICS_BEGIN_HINT_PGI = 0x1A203;
pub const NATIVE_GRAPHICS_END_HINT_PGI = 0x1A204;
pub const ALWAYS_FAST_HINT_PGI = 0x1A20C;
pub const ALWAYS_SOFT_HINT_PGI = 0x1A20D;
pub const ALLOW_DRAW_OBJ_HINT_PGI = 0x1A20E;
pub const ALLOW_DRAW_WIN_HINT_PGI = 0x1A20F;
pub const ALLOW_DRAW_FRG_HINT_PGI = 0x1A210;
pub const ALLOW_DRAW_MEM_HINT_PGI = 0x1A211;
pub const STRICT_DEPTHFUNC_HINT_PGI = 0x1A216;
pub const STRICT_LIGHTING_HINT_PGI = 0x1A217;
pub const STRICT_SCISSOR_HINT_PGI = 0x1A218;
pub const FULL_STIPPLE_HINT_PGI = 0x1A219;
pub const CLIP_NEAR_HINT_PGI = 0x1A220;
pub const CLIP_FAR_HINT_PGI = 0x1A221;
pub const WIDE_LINE_HINT_PGI = 0x1A222;
pub const BACK_NORMALS_HINT_PGI = 0x1A223;
pub const VERTEX_DATA_HINT_PGI = 0x1A22A;
pub const VERTEX_CONSISTENT_HINT_PGI = 0x1A22B;
pub const MATERIAL_SIDE_HINT_PGI = 0x1A22C;
pub const MAX_VERTEX_HINT_PGI = 0x1A22D;

pub const Error = error{
    InvalidEnum,
    InvalidValue,
    InvalidOperation,
    StackOverflow,
    StackUnderflow,
    OutOfMemory,
    InvalidFramebufferOperation,
    ContextLost,
    //TableTooLarge,
    Unlisted,
};

fn errorFromCode(err: GLenum) Error {
    return switch (err) {
        INVALID_ENUM => Error.InvalidEnum,
        INVALID_VALUE => Error.InvalidValue,
        INVALID_OPERATION => Error.InvalidOperation,
        STACK_OVERFLOW => Error.StackOverflow,
        STACK_UNDERFLOW => Error.StackUnderflow,
        OUT_OF_MEMORY => Error.OutOfMemory,
        INVALID_FRAMEBUFFER_OPERATION => Error.InvalidFramebufferOperation,
        CONTEXT_LOST => Error.ContextLost,
        //TABLE_TOO_LARGE => Error.TableTooLarge,
        else => Error.Unlisted,
    };
}

pub const CommandFlags = struct {
    cullFace: bool = false,
    frontFace: bool = false,
    hint: bool = false,
    lineWidth: bool = false,
    pointSize: bool = false,
    polygonMode: bool = false,
    scissor: bool = false,
    texParameterf: bool = false,
    texParameterfv: bool = false,
    texParameteri: bool = false,
    texParameteriv: bool = false,
    texImage1D: bool = false,
    texImage2D: bool = false,
    drawBuffer: bool = false,
    clear: bool = false,
    clearColor: bool = false,
    clearStencil: bool = false,
    clearDepth: bool = false,
    stencilMask: bool = false,
    colorMask: bool = false,
    depthMask: bool = false,
    disable: bool = false,
    enable: bool = false,
    finish: bool = false,
    flush: bool = false,
    blendFunc: bool = false,
    logicOp: bool = false,
    stencilFunc: bool = false,
    stencilOp: bool = false,
    depthFunc: bool = false,
    pixelStoref: bool = false,
    pixelStorei: bool = false,
    readBuffer: bool = false,
    readPixels: bool = false,
    getBooleanv: bool = false,
    getDoublev: bool = false,
    getError: bool = true,
    getFloatv: bool = false,
    getIntegerv: bool = false,
    getString: bool = false,
    getTexImage: bool = false,
    getTexParameterfv: bool = false,
    getTexParameteriv: bool = false,
    getTexLevelParameterfv: bool = false,
    getTexLevelParameteriv: bool = false,
    isEnabled: bool = false,
    depthRange: bool = false,
    viewport: bool = false,
    newList: bool = false,
    endList: bool = false,
    callList: bool = false,
    callLists: bool = false,
    deleteLists: bool = false,
    genLists: bool = false,
    listBase: bool = false,
    begin: bool = false,
    bitmap: bool = false,
    color3b: bool = false,
    color3bv: bool = false,
    color3d: bool = false,
    color3dv: bool = false,
    color3f: bool = false,
    color3fv: bool = false,
    color3i: bool = false,
    color3iv: bool = false,
    color3s: bool = false,
    color3sv: bool = false,
    color3ub: bool = false,
    color3ubv: bool = false,
    color3ui: bool = false,
    color3uiv: bool = false,
    color3us: bool = false,
    color3usv: bool = false,
    color4b: bool = false,
    color4bv: bool = false,
    color4d: bool = false,
    color4dv: bool = false,
    color4f: bool = false,
    color4fv: bool = false,
    color4i: bool = false,
    color4iv: bool = false,
    color4s: bool = false,
    color4sv: bool = false,
    color4ub: bool = false,
    color4ubv: bool = false,
    color4ui: bool = false,
    color4uiv: bool = false,
    color4us: bool = false,
    color4usv: bool = false,
    edgeFlag: bool = false,
    edgeFlagv: bool = false,
    end: bool = false,
    indexd: bool = false,
    indexdv: bool = false,
    indexf: bool = false,
    indexfv: bool = false,
    indexi: bool = false,
    indexiv: bool = false,
    indexs: bool = false,
    indexsv: bool = false,
    normal3b: bool = false,
    normal3bv: bool = false,
    normal3d: bool = false,
    normal3dv: bool = false,
    normal3f: bool = false,
    normal3fv: bool = false,
    normal3i: bool = false,
    normal3iv: bool = false,
    normal3s: bool = false,
    normal3sv: bool = false,
    rasterPos2d: bool = false,
    rasterPos2dv: bool = false,
    rasterPos2f: bool = false,
    rasterPos2fv: bool = false,
    rasterPos2i: bool = false,
    rasterPos2iv: bool = false,
    rasterPos2s: bool = false,
    rasterPos2sv: bool = false,
    rasterPos3d: bool = false,
    rasterPos3dv: bool = false,
    rasterPos3f: bool = false,
    rasterPos3fv: bool = false,
    rasterPos3i: bool = false,
    rasterPos3iv: bool = false,
    rasterPos3s: bool = false,
    rasterPos3sv: bool = false,
    rasterPos4d: bool = false,
    rasterPos4dv: bool = false,
    rasterPos4f: bool = false,
    rasterPos4fv: bool = false,
    rasterPos4i: bool = false,
    rasterPos4iv: bool = false,
    rasterPos4s: bool = false,
    rasterPos4sv: bool = false,
    rectd: bool = false,
    rectdv: bool = false,
    rectf: bool = false,
    rectfv: bool = false,
    recti: bool = false,
    rectiv: bool = false,
    rects: bool = false,
    rectsv: bool = false,
    texCoord1d: bool = false,
    texCoord1dv: bool = false,
    texCoord1f: bool = false,
    texCoord1fv: bool = false,
    texCoord1i: bool = false,
    texCoord1iv: bool = false,
    texCoord1s: bool = false,
    texCoord1sv: bool = false,
    texCoord2d: bool = false,
    texCoord2dv: bool = false,
    texCoord2f: bool = false,
    texCoord2fv: bool = false,
    texCoord2i: bool = false,
    texCoord2iv: bool = false,
    texCoord2s: bool = false,
    texCoord2sv: bool = false,
    texCoord3d: bool = false,
    texCoord3dv: bool = false,
    texCoord3f: bool = false,
    texCoord3fv: bool = false,
    texCoord3i: bool = false,
    texCoord3iv: bool = false,
    texCoord3s: bool = false,
    texCoord3sv: bool = false,
    texCoord4d: bool = false,
    texCoord4dv: bool = false,
    texCoord4f: bool = false,
    texCoord4fv: bool = false,
    texCoord4i: bool = false,
    texCoord4iv: bool = false,
    texCoord4s: bool = false,
    texCoord4sv: bool = false,
    vertex2d: bool = false,
    vertex2dv: bool = false,
    vertex2f: bool = false,
    vertex2fv: bool = false,
    vertex2i: bool = false,
    vertex2iv: bool = false,
    vertex2s: bool = false,
    vertex2sv: bool = false,
    vertex3d: bool = false,
    vertex3dv: bool = false,
    vertex3f: bool = false,
    vertex3fv: bool = false,
    vertex3i: bool = false,
    vertex3iv: bool = false,
    vertex3s: bool = false,
    vertex3sv: bool = false,
    vertex4d: bool = false,
    vertex4dv: bool = false,
    vertex4f: bool = false,
    vertex4fv: bool = false,
    vertex4i: bool = false,
    vertex4iv: bool = false,
    vertex4s: bool = false,
    vertex4sv: bool = false,
    clipPlane: bool = false,
    colorMaterial: bool = false,
    fogf: bool = false,
    fogfv: bool = false,
    fogi: bool = false,
    fogiv: bool = false,
    lightf: bool = false,
    lightfv: bool = false,
    lighti: bool = false,
    lightiv: bool = false,
    lightModelf: bool = false,
    lightModelfv: bool = false,
    lightModeli: bool = false,
    lightModeliv: bool = false,
    lineStipple: bool = false,
    materialf: bool = false,
    materialfv: bool = false,
    materiali: bool = false,
    materialiv: bool = false,
    polygonStipple: bool = false,
    shadeModel: bool = false,
    texEnvf: bool = false,
    texEnvfv: bool = false,
    texEnvi: bool = false,
    texEnviv: bool = false,
    texGend: bool = false,
    texGendv: bool = false,
    texGenf: bool = false,
    texGenfv: bool = false,
    texGeni: bool = false,
    texGeniv: bool = false,
    feedbackBuffer: bool = false,
    selectBuffer: bool = false,
    renderMode: bool = false,
    initNames: bool = false,
    loadName: bool = false,
    passThrough: bool = false,
    popName: bool = false,
    pushName: bool = false,
    clearAccum: bool = false,
    clearIndex: bool = false,
    indexMask: bool = false,
    accum: bool = false,
    popAttrib: bool = false,
    pushAttrib: bool = false,
    map1d: bool = false,
    map1f: bool = false,
    map2d: bool = false,
    map2f: bool = false,
    mapGrid1d: bool = false,
    mapGrid1f: bool = false,
    mapGrid2d: bool = false,
    mapGrid2f: bool = false,
    evalCoord1d: bool = false,
    evalCoord1dv: bool = false,
    evalCoord1f: bool = false,
    evalCoord1fv: bool = false,
    evalCoord2d: bool = false,
    evalCoord2dv: bool = false,
    evalCoord2f: bool = false,
    evalCoord2fv: bool = false,
    evalMesh1: bool = false,
    evalPoint1: bool = false,
    evalMesh2: bool = false,
    evalPoint2: bool = false,
    alphaFunc: bool = false,
    pixelZoom: bool = false,
    pixelTransferf: bool = false,
    pixelTransferi: bool = false,
    pixelMapfv: bool = false,
    pixelMapuiv: bool = false,
    pixelMapusv: bool = false,
    copyPixels: bool = false,
    drawPixels: bool = false,
    getClipPlane: bool = false,
    getLightfv: bool = false,
    getLightiv: bool = false,
    getMapdv: bool = false,
    getMapfv: bool = false,
    getMapiv: bool = false,
    getMaterialfv: bool = false,
    getMaterialiv: bool = false,
    getPixelMapfv: bool = false,
    getPixelMapuiv: bool = false,
    getPixelMapusv: bool = false,
    getPolygonStipple: bool = false,
    getTexEnvfv: bool = false,
    getTexEnviv: bool = false,
    getTexGendv: bool = false,
    getTexGenfv: bool = false,
    getTexGeniv: bool = false,
    isList: bool = false,
    frustum: bool = false,
    loadIdentity: bool = false,
    loadMatrixf: bool = false,
    loadMatrixd: bool = false,
    matrixMode: bool = false,
    multMatrixf: bool = false,
    multMatrixd: bool = false,
    ortho: bool = false,
    popMatrix: bool = false,
    pushMatrix: bool = false,
    rotated: bool = false,
    rotatef: bool = false,
    scaled: bool = false,
    scalef: bool = false,
    translated: bool = false,
    translatef: bool = false,
    drawArrays: bool = false,
    drawElements: bool = false,
    getPointerv: bool = false,
    polygonOffset: bool = false,
    copyTexImage1D: bool = false,
    copyTexImage2D: bool = false,
    copyTexSubImage1D: bool = false,
    copyTexSubImage2D: bool = false,
    texSubImage1D: bool = false,
    texSubImage2D: bool = false,
    bindTexture: bool = false,
    deleteTextures: bool = false,
    genTextures: bool = false,
    isTexture: bool = false,
    arrayElement: bool = false,
    colorPointer: bool = false,
    disableClientState: bool = false,
    edgeFlagPointer: bool = false,
    enableClientState: bool = false,
    indexPointer: bool = false,
    interleavedArrays: bool = false,
    normalPointer: bool = false,
    texCoordPointer: bool = false,
    vertexPointer: bool = false,
    areTexturesResident: bool = false,
    prioritizeTextures: bool = false,
    indexub: bool = false,
    indexubv: bool = false,
    popClientAttrib: bool = false,
    pushClientAttrib: bool = false,
    drawRangeElements: bool = false,
    texImage3D: bool = false,
    texSubImage3D: bool = false,
    copyTexSubImage3D: bool = false,
    activeTexture: bool = false,
    sampleCoverage: bool = false,
    compressedTexImage3D: bool = false,
    compressedTexImage2D: bool = false,
    compressedTexImage1D: bool = false,
    compressedTexSubImage3D: bool = false,
    compressedTexSubImage2D: bool = false,
    compressedTexSubImage1D: bool = false,
    getCompressedTexImage: bool = false,
    clientActiveTexture: bool = false,
    multiTexCoord1d: bool = false,
    multiTexCoord1dv: bool = false,
    multiTexCoord1f: bool = false,
    multiTexCoord1fv: bool = false,
    multiTexCoord1i: bool = false,
    multiTexCoord1iv: bool = false,
    multiTexCoord1s: bool = false,
    multiTexCoord1sv: bool = false,
    multiTexCoord2d: bool = false,
    multiTexCoord2dv: bool = false,
    multiTexCoord2f: bool = false,
    multiTexCoord2fv: bool = false,
    multiTexCoord2i: bool = false,
    multiTexCoord2iv: bool = false,
    multiTexCoord2s: bool = false,
    multiTexCoord2sv: bool = false,
    multiTexCoord3d: bool = false,
    multiTexCoord3dv: bool = false,
    multiTexCoord3f: bool = false,
    multiTexCoord3fv: bool = false,
    multiTexCoord3i: bool = false,
    multiTexCoord3iv: bool = false,
    multiTexCoord3s: bool = false,
    multiTexCoord3sv: bool = false,
    multiTexCoord4d: bool = false,
    multiTexCoord4dv: bool = false,
    multiTexCoord4f: bool = false,
    multiTexCoord4fv: bool = false,
    multiTexCoord4i: bool = false,
    multiTexCoord4iv: bool = false,
    multiTexCoord4s: bool = false,
    multiTexCoord4sv: bool = false,
    loadTransposeMatrixf: bool = false,
    loadTransposeMatrixd: bool = false,
    multTransposeMatrixf: bool = false,
    multTransposeMatrixd: bool = false,
    blendFuncSeparate: bool = false,
    multiDrawArrays: bool = false,
    multiDrawElements: bool = false,
    pointParameterf: bool = false,
    pointParameterfv: bool = false,
    pointParameteri: bool = false,
    pointParameteriv: bool = false,
    fogCoordf: bool = false,
    fogCoordfv: bool = false,
    fogCoordd: bool = false,
    fogCoorddv: bool = false,
    fogCoordPointer: bool = false,
    secondaryColor3b: bool = false,
    secondaryColor3bv: bool = false,
    secondaryColor3d: bool = false,
    secondaryColor3dv: bool = false,
    secondaryColor3f: bool = false,
    secondaryColor3fv: bool = false,
    secondaryColor3i: bool = false,
    secondaryColor3iv: bool = false,
    secondaryColor3s: bool = false,
    secondaryColor3sv: bool = false,
    secondaryColor3ub: bool = false,
    secondaryColor3ubv: bool = false,
    secondaryColor3ui: bool = false,
    secondaryColor3uiv: bool = false,
    secondaryColor3us: bool = false,
    secondaryColor3usv: bool = false,
    secondaryColorPointer: bool = false,
    windowPos2d: bool = false,
    windowPos2dv: bool = false,
    windowPos2f: bool = false,
    windowPos2fv: bool = false,
    windowPos2i: bool = false,
    windowPos2iv: bool = false,
    windowPos2s: bool = false,
    windowPos2sv: bool = false,
    windowPos3d: bool = false,
    windowPos3dv: bool = false,
    windowPos3f: bool = false,
    windowPos3fv: bool = false,
    windowPos3i: bool = false,
    windowPos3iv: bool = false,
    windowPos3s: bool = false,
    windowPos3sv: bool = false,
    blendColor: bool = false,
    blendEquation: bool = false,
    genQueries: bool = false,
    deleteQueries: bool = false,
    isQuery: bool = false,
    beginQuery: bool = false,
    endQuery: bool = false,
    getQueryiv: bool = false,
    getQueryObjectiv: bool = false,
    getQueryObjectuiv: bool = false,
    bindBuffer: bool = false,
    deleteBuffers: bool = false,
    genBuffers: bool = false,
    isBuffer: bool = false,
    bufferData: bool = false,
    bufferSubData: bool = false,
    getBufferSubData: bool = false,
    mapBuffer: bool = false,
    unmapBuffer: bool = false,
    getBufferParameteriv: bool = false,
    getBufferPointerv: bool = false,
    blendEquationSeparate: bool = false,
    drawBuffers: bool = false,
    stencilOpSeparate: bool = false,
    stencilFuncSeparate: bool = false,
    stencilMaskSeparate: bool = false,
    attachShader: bool = false,
    bindAttribLocation: bool = false,
    compileShader: bool = false,
    createProgram: bool = false,
    createShader: bool = false,
    deleteProgram: bool = false,
    deleteShader: bool = false,
    detachShader: bool = false,
    disableVertexAttribArray: bool = false,
    enableVertexAttribArray: bool = false,
    getActiveAttrib: bool = false,
    getActiveUniform: bool = false,
    getAttachedShaders: bool = false,
    getAttribLocation: bool = false,
    getProgramiv: bool = false,
    getProgramInfoLog: bool = false,
    getShaderiv: bool = false,
    getShaderInfoLog: bool = false,
    getShaderSource: bool = false,
    getUniformLocation: bool = false,
    getUniformfv: bool = false,
    getUniformiv: bool = false,
    getVertexAttribdv: bool = false,
    getVertexAttribfv: bool = false,
    getVertexAttribiv: bool = false,
    getVertexAttribPointerv: bool = false,
    isProgram: bool = false,
    isShader: bool = false,
    linkProgram: bool = false,
    shaderSource: bool = false,
    useProgram: bool = false,
    uniform1f: bool = false,
    uniform2f: bool = false,
    uniform3f: bool = false,
    uniform4f: bool = false,
    uniform1i: bool = false,
    uniform2i: bool = false,
    uniform3i: bool = false,
    uniform4i: bool = false,
    uniform1fv: bool = false,
    uniform2fv: bool = false,
    uniform3fv: bool = false,
    uniform4fv: bool = false,
    uniform1iv: bool = false,
    uniform2iv: bool = false,
    uniform3iv: bool = false,
    uniform4iv: bool = false,
    uniformMatrix2fv: bool = false,
    uniformMatrix3fv: bool = false,
    uniformMatrix4fv: bool = false,
    validateProgram: bool = false,
    vertexAttrib1d: bool = false,
    vertexAttrib1dv: bool = false,
    vertexAttrib1f: bool = false,
    vertexAttrib1fv: bool = false,
    vertexAttrib1s: bool = false,
    vertexAttrib1sv: bool = false,
    vertexAttrib2d: bool = false,
    vertexAttrib2dv: bool = false,
    vertexAttrib2f: bool = false,
    vertexAttrib2fv: bool = false,
    vertexAttrib2s: bool = false,
    vertexAttrib2sv: bool = false,
    vertexAttrib3d: bool = false,
    vertexAttrib3dv: bool = false,
    vertexAttrib3f: bool = false,
    vertexAttrib3fv: bool = false,
    vertexAttrib3s: bool = false,
    vertexAttrib3sv: bool = false,
    vertexAttrib4Nbv: bool = false,
    vertexAttrib4Niv: bool = false,
    vertexAttrib4Nsv: bool = false,
    vertexAttrib4Nub: bool = false,
    vertexAttrib4Nubv: bool = false,
    vertexAttrib4Nuiv: bool = false,
    vertexAttrib4Nusv: bool = false,
    vertexAttrib4bv: bool = false,
    vertexAttrib4d: bool = false,
    vertexAttrib4dv: bool = false,
    vertexAttrib4f: bool = false,
    vertexAttrib4fv: bool = false,
    vertexAttrib4iv: bool = false,
    vertexAttrib4s: bool = false,
    vertexAttrib4sv: bool = false,
    vertexAttrib4ubv: bool = false,
    vertexAttrib4uiv: bool = false,
    vertexAttrib4usv: bool = false,
    vertexAttribPointer: bool = false,
    uniformMatrix2x3fv: bool = false,
    uniformMatrix3x2fv: bool = false,
    uniformMatrix2x4fv: bool = false,
    uniformMatrix4x2fv: bool = false,
    uniformMatrix3x4fv: bool = false,
    uniformMatrix4x3fv: bool = false,
    colorMaski: bool = false,
    getBooleani_v: bool = false,
    getIntegeri_v: bool = false,
    enablei: bool = false,
    disablei: bool = false,
    isEnabledi: bool = false,
    beginTransformFeedback: bool = false,
    endTransformFeedback: bool = false,
    bindBufferRange: bool = false,
    bindBufferBase: bool = false,
    transformFeedbackVaryings: bool = false,
    getTransformFeedbackVarying: bool = false,
    clampColor: bool = false,
    beginConditionalRender: bool = false,
    endConditionalRender: bool = false,
    vertexAttribIPointer: bool = false,
    getVertexAttribIiv: bool = false,
    getVertexAttribIuiv: bool = false,
    vertexAttribI1i: bool = false,
    vertexAttribI2i: bool = false,
    vertexAttribI3i: bool = false,
    vertexAttribI4i: bool = false,
    vertexAttribI1ui: bool = false,
    vertexAttribI2ui: bool = false,
    vertexAttribI3ui: bool = false,
    vertexAttribI4ui: bool = false,
    vertexAttribI1iv: bool = false,
    vertexAttribI2iv: bool = false,
    vertexAttribI3iv: bool = false,
    vertexAttribI4iv: bool = false,
    vertexAttribI1uiv: bool = false,
    vertexAttribI2uiv: bool = false,
    vertexAttribI3uiv: bool = false,
    vertexAttribI4uiv: bool = false,
    vertexAttribI4bv: bool = false,
    vertexAttribI4sv: bool = false,
    vertexAttribI4ubv: bool = false,
    vertexAttribI4usv: bool = false,
    getUniformuiv: bool = false,
    bindFragDataLocation: bool = false,
    getFragDataLocation: bool = false,
    uniform1ui: bool = false,
    uniform2ui: bool = false,
    uniform3ui: bool = false,
    uniform4ui: bool = false,
    uniform1uiv: bool = false,
    uniform2uiv: bool = false,
    uniform3uiv: bool = false,
    uniform4uiv: bool = false,
    texParameterIiv: bool = false,
    texParameterIuiv: bool = false,
    getTexParameterIiv: bool = false,
    getTexParameterIuiv: bool = false,
    clearBufferiv: bool = false,
    clearBufferuiv: bool = false,
    clearBufferfv: bool = false,
    clearBufferfi: bool = false,
    getStringi: bool = false,
    isRenderbuffer: bool = false,
    bindRenderbuffer: bool = false,
    deleteRenderbuffers: bool = false,
    genRenderbuffers: bool = false,
    renderbufferStorage: bool = false,
    getRenderbufferParameteriv: bool = false,
    isFramebuffer: bool = false,
    bindFramebuffer: bool = false,
    deleteFramebuffers: bool = false,
    genFramebuffers: bool = false,
    checkFramebufferStatus: bool = false,
    framebufferTexture1D: bool = false,
    framebufferTexture2D: bool = false,
    framebufferTexture3D: bool = false,
    framebufferRenderbuffer: bool = false,
    getFramebufferAttachmentParameteriv: bool = false,
    generateMipmap: bool = false,
    blitFramebuffer: bool = false,
    renderbufferStorageMultisample: bool = false,
    framebufferTextureLayer: bool = false,
    mapBufferRange: bool = false,
    flushMappedBufferRange: bool = false,
    bindVertexArray: bool = false,
    deleteVertexArrays: bool = false,
    genVertexArrays: bool = false,
    isVertexArray: bool = false,
    drawArraysInstanced: bool = false,
    drawElementsInstanced: bool = false,
    texBuffer: bool = false,
    primitiveRestartIndex: bool = false,
    copyBufferSubData: bool = false,
    getUniformIndices: bool = false,
    getActiveUniformsiv: bool = false,
    getActiveUniformName: bool = false,
    getUniformBlockIndex: bool = false,
    getActiveUniformBlockiv: bool = false,
    getActiveUniformBlockName: bool = false,
    uniformBlockBinding: bool = false,
    drawElementsBaseVertex: bool = false,
    drawRangeElementsBaseVertex: bool = false,
    drawElementsInstancedBaseVertex: bool = false,
    multiDrawElementsBaseVertex: bool = false,
    provokingVertex: bool = false,
    fenceSync: bool = false,
    isSync: bool = false,
    deleteSync: bool = false,
    clientWaitSync: bool = false,
    waitSync: bool = false,
    getInteger64v: bool = false,
    getSynciv: bool = false,
    getInteger64i_v: bool = false,
    getBufferParameteri64v: bool = false,
    framebufferTexture: bool = false,
    texImage2DMultisample: bool = false,
    texImage3DMultisample: bool = false,
    getMultisamplefv: bool = false,
    sampleMaski: bool = false,
    bindFragDataLocationIndexed: bool = false,
    getFragDataIndex: bool = false,
    genSamplers: bool = false,
    deleteSamplers: bool = false,
    isSampler: bool = false,
    bindSampler: bool = false,
    samplerParameteri: bool = false,
    samplerParameteriv: bool = false,
    samplerParameterf: bool = false,
    samplerParameterfv: bool = false,
    samplerParameterIiv: bool = false,
    samplerParameterIuiv: bool = false,
    getSamplerParameteriv: bool = false,
    getSamplerParameterIiv: bool = false,
    getSamplerParameterfv: bool = false,
    getSamplerParameterIuiv: bool = false,
    queryCounter: bool = false,
    getQueryObjecti64v: bool = false,
    getQueryObjectui64v: bool = false,
    vertexAttribDivisor: bool = false,
    vertexAttribP1ui: bool = false,
    vertexAttribP1uiv: bool = false,
    vertexAttribP2ui: bool = false,
    vertexAttribP2uiv: bool = false,
    vertexAttribP3ui: bool = false,
    vertexAttribP3uiv: bool = false,
    vertexAttribP4ui: bool = false,
    vertexAttribP4uiv: bool = false,
    vertexP2ui: bool = false,
    vertexP2uiv: bool = false,
    vertexP3ui: bool = false,
    vertexP3uiv: bool = false,
    vertexP4ui: bool = false,
    vertexP4uiv: bool = false,
    texCoordP1ui: bool = false,
    texCoordP1uiv: bool = false,
    texCoordP2ui: bool = false,
    texCoordP2uiv: bool = false,
    texCoordP3ui: bool = false,
    texCoordP3uiv: bool = false,
    texCoordP4ui: bool = false,
    texCoordP4uiv: bool = false,
    multiTexCoordP1ui: bool = false,
    multiTexCoordP1uiv: bool = false,
    multiTexCoordP2ui: bool = false,
    multiTexCoordP2uiv: bool = false,
    multiTexCoordP3ui: bool = false,
    multiTexCoordP3uiv: bool = false,
    multiTexCoordP4ui: bool = false,
    multiTexCoordP4uiv: bool = false,
    normalP3ui: bool = false,
    normalP3uiv: bool = false,
    colorP3ui: bool = false,
    colorP3uiv: bool = false,
    colorP4ui: bool = false,
    colorP4uiv: bool = false,
    secondaryColorP3ui: bool = false,
    secondaryColorP3uiv: bool = false,
    minSampleShading: bool = false,
    blendEquationi: bool = false,
    blendEquationSeparatei: bool = false,
    blendFunci: bool = false,
    blendFuncSeparatei: bool = false,
    drawArraysIndirect: bool = false,
    drawElementsIndirect: bool = false,
    uniform1d: bool = false,
    uniform2d: bool = false,
    uniform3d: bool = false,
    uniform4d: bool = false,
    uniform1dv: bool = false,
    uniform2dv: bool = false,
    uniform3dv: bool = false,
    uniform4dv: bool = false,
    uniformMatrix2dv: bool = false,
    uniformMatrix3dv: bool = false,
    uniformMatrix4dv: bool = false,
    uniformMatrix2x3dv: bool = false,
    uniformMatrix2x4dv: bool = false,
    uniformMatrix3x2dv: bool = false,
    uniformMatrix3x4dv: bool = false,
    uniformMatrix4x2dv: bool = false,
    uniformMatrix4x3dv: bool = false,
    getUniformdv: bool = false,
    getSubroutineUniformLocation: bool = false,
    getSubroutineIndex: bool = false,
    getActiveSubroutineUniformiv: bool = false,
    getActiveSubroutineUniformName: bool = false,
    getActiveSubroutineName: bool = false,
    uniformSubroutinesuiv: bool = false,
    getUniformSubroutineuiv: bool = false,
    getProgramStageiv: bool = false,
    patchParameteri: bool = false,
    patchParameterfv: bool = false,
    bindTransformFeedback: bool = false,
    deleteTransformFeedbacks: bool = false,
    genTransformFeedbacks: bool = false,
    isTransformFeedback: bool = false,
    pauseTransformFeedback: bool = false,
    resumeTransformFeedback: bool = false,
    drawTransformFeedback: bool = false,
    drawTransformFeedbackStream: bool = false,
    beginQueryIndexed: bool = false,
    endQueryIndexed: bool = false,
    getQueryIndexediv: bool = false,
    releaseShaderCompiler: bool = false,
    shaderBinary: bool = false,
    getShaderPrecisionFormat: bool = false,
    depthRangef: bool = false,
    clearDepthf: bool = false,
    getProgramBinary: bool = false,
    programBinary: bool = false,
    programParameteri: bool = false,
    useProgramStages: bool = false,
    activeShaderProgram: bool = false,
    createShaderProgramv: bool = false,
    bindProgramPipeline: bool = false,
    deleteProgramPipelines: bool = false,
    genProgramPipelines: bool = false,
    isProgramPipeline: bool = false,
    getProgramPipelineiv: bool = false,
    programUniform1i: bool = false,
    programUniform1iv: bool = false,
    programUniform1f: bool = false,
    programUniform1fv: bool = false,
    programUniform1d: bool = false,
    programUniform1dv: bool = false,
    programUniform1ui: bool = false,
    programUniform1uiv: bool = false,
    programUniform2i: bool = false,
    programUniform2iv: bool = false,
    programUniform2f: bool = false,
    programUniform2fv: bool = false,
    programUniform2d: bool = false,
    programUniform2dv: bool = false,
    programUniform2ui: bool = false,
    programUniform2uiv: bool = false,
    programUniform3i: bool = false,
    programUniform3iv: bool = false,
    programUniform3f: bool = false,
    programUniform3fv: bool = false,
    programUniform3d: bool = false,
    programUniform3dv: bool = false,
    programUniform3ui: bool = false,
    programUniform3uiv: bool = false,
    programUniform4i: bool = false,
    programUniform4iv: bool = false,
    programUniform4f: bool = false,
    programUniform4fv: bool = false,
    programUniform4d: bool = false,
    programUniform4dv: bool = false,
    programUniform4ui: bool = false,
    programUniform4uiv: bool = false,
    programUniformMatrix2fv: bool = false,
    programUniformMatrix3fv: bool = false,
    programUniformMatrix4fv: bool = false,
    programUniformMatrix2dv: bool = false,
    programUniformMatrix3dv: bool = false,
    programUniformMatrix4dv: bool = false,
    programUniformMatrix2x3fv: bool = false,
    programUniformMatrix3x2fv: bool = false,
    programUniformMatrix2x4fv: bool = false,
    programUniformMatrix4x2fv: bool = false,
    programUniformMatrix3x4fv: bool = false,
    programUniformMatrix4x3fv: bool = false,
    programUniformMatrix2x3dv: bool = false,
    programUniformMatrix3x2dv: bool = false,
    programUniformMatrix2x4dv: bool = false,
    programUniformMatrix4x2dv: bool = false,
    programUniformMatrix3x4dv: bool = false,
    programUniformMatrix4x3dv: bool = false,
    validateProgramPipeline: bool = false,
    getProgramPipelineInfoLog: bool = false,
    vertexAttribL1d: bool = false,
    vertexAttribL2d: bool = false,
    vertexAttribL3d: bool = false,
    vertexAttribL4d: bool = false,
    vertexAttribL1dv: bool = false,
    vertexAttribL2dv: bool = false,
    vertexAttribL3dv: bool = false,
    vertexAttribL4dv: bool = false,
    vertexAttribLPointer: bool = false,
    getVertexAttribLdv: bool = false,
    viewportArrayv: bool = false,
    viewportIndexedf: bool = false,
    viewportIndexedfv: bool = false,
    scissorArrayv: bool = false,
    scissorIndexed: bool = false,
    scissorIndexedv: bool = false,
    depthRangeArrayv: bool = false,
    depthRangeIndexed: bool = false,
    getFloati_v: bool = false,
    getDoublei_v: bool = false,
    drawArraysInstancedBaseInstance: bool = false,
    drawElementsInstancedBaseInstance: bool = false,
    drawElementsInstancedBaseVertexBaseInstance: bool = false,
    getInternalformativ: bool = false,
    getActiveAtomicCounterBufferiv: bool = false,
    bindImageTexture: bool = false,
    memoryBarrier: bool = false,
    texStorage1D: bool = false,
    texStorage2D: bool = false,
    texStorage3D: bool = false,
    drawTransformFeedbackInstanced: bool = false,
    drawTransformFeedbackStreamInstanced: bool = false,
    clearBufferData: bool = false,
    clearBufferSubData: bool = false,
    dispatchCompute: bool = false,
    dispatchComputeIndirect: bool = false,
    copyImageSubData: bool = false,
    framebufferParameteri: bool = false,
    getFramebufferParameteriv: bool = false,
    getInternalformati64v: bool = false,
    invalidateTexSubImage: bool = false,
    invalidateTexImage: bool = false,
    invalidateBufferSubData: bool = false,
    invalidateBufferData: bool = false,
    invalidateFramebuffer: bool = false,
    invalidateSubFramebuffer: bool = false,
    multiDrawArraysIndirect: bool = false,
    multiDrawElementsIndirect: bool = false,
    getProgramInterfaceiv: bool = false,
    getProgramResourceIndex: bool = false,
    getProgramResourceName: bool = false,
    getProgramResourceiv: bool = false,
    getProgramResourceLocation: bool = false,
    getProgramResourceLocationIndex: bool = false,
    shaderStorageBlockBinding: bool = false,
    texBufferRange: bool = false,
    texStorage2DMultisample: bool = false,
    texStorage3DMultisample: bool = false,
    textureView: bool = false,
    bindVertexBuffer: bool = false,
    vertexAttribFormat: bool = false,
    vertexAttribIFormat: bool = false,
    vertexAttribLFormat: bool = false,
    vertexAttribBinding: bool = false,
    vertexBindingDivisor: bool = false,
    debugMessageControl: bool = false,
    debugMessageInsert: bool = false,
    debugMessageCallback: bool = false,
    getDebugMessageLog: bool = false,
    pushDebugGroup: bool = false,
    popDebugGroup: bool = false,
    objectLabel: bool = false,
    getObjectLabel: bool = false,
    objectPtrLabel: bool = false,
    getObjectPtrLabel: bool = false,
    bufferStorage: bool = false,
    clearTexImage: bool = false,
    clearTexSubImage: bool = false,
    bindBuffersBase: bool = false,
    bindBuffersRange: bool = false,
    bindTextures: bool = false,
    bindSamplers: bool = false,
    bindImageTextures: bool = false,
    bindVertexBuffers: bool = false,
    clipControl: bool = false,
    createTransformFeedbacks: bool = false,
    transformFeedbackBufferBase: bool = false,
    transformFeedbackBufferRange: bool = false,
    getTransformFeedbackiv: bool = false,
    getTransformFeedbacki_v: bool = false,
    getTransformFeedbacki64_v: bool = false,
    createBuffers: bool = false,
    namedBufferStorage: bool = false,
    namedBufferData: bool = false,
    namedBufferSubData: bool = false,
    copyNamedBufferSubData: bool = false,
    clearNamedBufferData: bool = false,
    clearNamedBufferSubData: bool = false,
    mapNamedBuffer: bool = false,
    mapNamedBufferRange: bool = false,
    unmapNamedBuffer: bool = false,
    flushMappedNamedBufferRange: bool = false,
    getNamedBufferParameteriv: bool = false,
    getNamedBufferParameteri64v: bool = false,
    getNamedBufferPointerv: bool = false,
    getNamedBufferSubData: bool = false,
    createFramebuffers: bool = false,
    namedFramebufferRenderbuffer: bool = false,
    namedFramebufferParameteri: bool = false,
    namedFramebufferTexture: bool = false,
    namedFramebufferTextureLayer: bool = false,
    namedFramebufferDrawBuffer: bool = false,
    namedFramebufferDrawBuffers: bool = false,
    namedFramebufferReadBuffer: bool = false,
    invalidateNamedFramebufferData: bool = false,
    invalidateNamedFramebufferSubData: bool = false,
    clearNamedFramebufferiv: bool = false,
    clearNamedFramebufferuiv: bool = false,
    clearNamedFramebufferfv: bool = false,
    clearNamedFramebufferfi: bool = false,
    blitNamedFramebuffer: bool = false,
    checkNamedFramebufferStatus: bool = false,
    getNamedFramebufferParameteriv: bool = false,
    getNamedFramebufferAttachmentParameteriv: bool = false,
    createRenderbuffers: bool = false,
    namedRenderbufferStorage: bool = false,
    namedRenderbufferStorageMultisample: bool = false,
    getNamedRenderbufferParameteriv: bool = false,
    createTextures: bool = false,
    textureBuffer: bool = false,
    textureBufferRange: bool = false,
    textureStorage1D: bool = false,
    textureStorage2D: bool = false,
    textureStorage3D: bool = false,
    textureStorage2DMultisample: bool = false,
    textureStorage3DMultisample: bool = false,
    textureSubImage1D: bool = false,
    textureSubImage2D: bool = false,
    textureSubImage3D: bool = false,
    compressedTextureSubImage1D: bool = false,
    compressedTextureSubImage2D: bool = false,
    compressedTextureSubImage3D: bool = false,
    copyTextureSubImage1D: bool = false,
    copyTextureSubImage2D: bool = false,
    copyTextureSubImage3D: bool = false,
    textureParameterf: bool = false,
    textureParameterfv: bool = false,
    textureParameteri: bool = false,
    textureParameterIiv: bool = false,
    textureParameterIuiv: bool = false,
    textureParameteriv: bool = false,
    generateTextureMipmap: bool = false,
    bindTextureUnit: bool = false,
    getTextureImage: bool = false,
    getCompressedTextureImage: bool = false,
    getTextureLevelParameterfv: bool = false,
    getTextureLevelParameteriv: bool = false,
    getTextureParameterfv: bool = false,
    getTextureParameterIiv: bool = false,
    getTextureParameterIuiv: bool = false,
    getTextureParameteriv: bool = false,
    createVertexArrays: bool = false,
    disableVertexArrayAttrib: bool = false,
    enableVertexArrayAttrib: bool = false,
    vertexArrayElementBuffer: bool = false,
    vertexArrayVertexBuffer: bool = false,
    vertexArrayVertexBuffers: bool = false,
    vertexArrayAttribBinding: bool = false,
    vertexArrayAttribFormat: bool = false,
    vertexArrayAttribIFormat: bool = false,
    vertexArrayAttribLFormat: bool = false,
    vertexArrayBindingDivisor: bool = false,
    getVertexArrayiv: bool = false,
    getVertexArrayIndexediv: bool = false,
    getVertexArrayIndexed64iv: bool = false,
    createSamplers: bool = false,
    createProgramPipelines: bool = false,
    createQueries: bool = false,
    getQueryBufferObjecti64v: bool = false,
    getQueryBufferObjectiv: bool = false,
    getQueryBufferObjectui64v: bool = false,
    getQueryBufferObjectuiv: bool = false,
    memoryBarrierByRegion: bool = false,
    getTextureSubImage: bool = false,
    getCompressedTextureSubImage: bool = false,
    getGraphicsResetStatus: bool = false,
    getnCompressedTexImage: bool = false,
    getnTexImage: bool = false,
    getnUniformdv: bool = false,
    getnUniformfv: bool = false,
    getnUniformiv: bool = false,
    getnUniformuiv: bool = false,
    readnPixels: bool = false,
    getnMapdv: bool = false,
    getnMapfv: bool = false,
    getnMapiv: bool = false,
    getnPixelMapfv: bool = false,
    getnPixelMapuiv: bool = false,
    getnPixelMapusv: bool = false,
    getnPolygonStipple: bool = false,
    getnColorTable: bool = false,
    getnConvolutionFilter: bool = false,
    getnSeparableFilter: bool = false,
    getnHistogram: bool = false,
    getnMinmax: bool = false,
    textureBarrier: bool = false,
    specializeShader: bool = false,
    multiDrawArraysIndirectCount: bool = false,
    multiDrawElementsIndirectCount: bool = false,
    polygonOffsetClamp: bool = false,
    clipPlanef: bool = false,
    frustumf: bool = false,
    getClipPlanef: bool = false,
    orthof: bool = false,
    alphaFuncx: bool = false,
    clearColorx: bool = false,
    clearDepthx: bool = false,
    clipPlanex: bool = false,
    color4x: bool = false,
    depthRangex: bool = false,
    fogx: bool = false,
    fogxv: bool = false,
    frustumx: bool = false,
    getClipPlanex: bool = false,
    getFixedv: bool = false,
    getLightxv: bool = false,
    getMaterialxv: bool = false,
    getTexEnvxv: bool = false,
    getTexParameterxv: bool = false,
    lightModelx: bool = false,
    lightModelxv: bool = false,
    lightx: bool = false,
    lightxv: bool = false,
    lineWidthx: bool = false,
    loadMatrixx: bool = false,
    materialx: bool = false,
    materialxv: bool = false,
    multMatrixx: bool = false,
    multiTexCoord4x: bool = false,
    normal3x: bool = false,
    orthox: bool = false,
    pointParameterx: bool = false,
    pointParameterxv: bool = false,
    pointSizex: bool = false,
    polygonOffsetx: bool = false,
    rotatex: bool = false,
    sampleCoveragex: bool = false,
    scalex: bool = false,
    texEnvx: bool = false,
    texEnvxv: bool = false,
    texParameterx: bool = false,
    texParameterxv: bool = false,
    translatex: bool = false,
    blendBarrier: bool = false,
    primitiveBoundingBox: bool = false,
    pub fn CmdType(comptime tag: std.meta.FieldEnum(CommandFlags)) type {
        return switch (tag) {
            .cullFace => *const fn (_mode: GLenum) callconv(.C) void,
            .frontFace => *const fn (_mode: GLenum) callconv(.C) void,
            .hint => *const fn (_target: GLenum, _mode: GLenum) callconv(.C) void,
            .lineWidth => *const fn (_width: GLfloat) callconv(.C) void,
            .pointSize => *const fn (_size: GLfloat) callconv(.C) void,
            .polygonMode => *const fn (_face: GLenum, _mode: GLenum) callconv(.C) void,
            .scissor => *const fn (_x: GLint, _y: GLint, _width: GLsizei, _height: GLsizei) callconv(.C) void,
            .texParameterf => *const fn (_target: GLenum, _pname: GLenum, _param: GLfloat) callconv(.C) void,
            .texParameterfv => *const fn (_target: GLenum, _pname: GLenum, _params: [*c]const GLfloat) callconv(.C) void,
            .texParameteri => *const fn (_target: GLenum, _pname: GLenum, _param: GLint) callconv(.C) void,
            .texParameteriv => *const fn (_target: GLenum, _pname: GLenum, _params: [*c]const GLint) callconv(.C) void,
            .texImage1D => *const fn (_target: GLenum, _level: GLint, _internalformat: GLint, _width: GLsizei, _border: GLint, _format: GLenum, _type: GLenum, _pixels: ?*const anyopaque) callconv(.C) void,
            .texImage2D => *const fn (_target: GLenum, _level: GLint, _internalformat: GLint, _width: GLsizei, _height: GLsizei, _border: GLint, _format: GLenum, _type: GLenum, _pixels: ?*const anyopaque) callconv(.C) void,
            .drawBuffer => *const fn (_buf: GLenum) callconv(.C) void,
            .clear => *const fn (_mask: GLbitfield) callconv(.C) void,
            .clearColor => *const fn (_red: GLfloat, _green: GLfloat, _blue: GLfloat, _alpha: GLfloat) callconv(.C) void,
            .clearStencil => *const fn (_s: GLint) callconv(.C) void,
            .clearDepth => *const fn (_depth: GLdouble) callconv(.C) void,
            .stencilMask => *const fn (_mask: GLuint) callconv(.C) void,
            .colorMask => *const fn (_red: GLboolean, _green: GLboolean, _blue: GLboolean, _alpha: GLboolean) callconv(.C) void,
            .depthMask => *const fn (_flag: GLboolean) callconv(.C) void,
            .disable => *const fn (_cap: GLenum) callconv(.C) void,
            .enable => *const fn (_cap: GLenum) callconv(.C) void,
            .finish => *const fn () callconv(.C) void,
            .flush => *const fn () callconv(.C) void,
            .blendFunc => *const fn (_sfactor: GLenum, _dfactor: GLenum) callconv(.C) void,
            .logicOp => *const fn (_opcode: GLenum) callconv(.C) void,
            .stencilFunc => *const fn (_func: GLenum, _ref: GLint, _mask: GLuint) callconv(.C) void,
            .stencilOp => *const fn (_fail: GLenum, _zfail: GLenum, _zpass: GLenum) callconv(.C) void,
            .depthFunc => *const fn (_func: GLenum) callconv(.C) void,
            .pixelStoref => *const fn (_pname: GLenum, _param: GLfloat) callconv(.C) void,
            .pixelStorei => *const fn (_pname: GLenum, _param: GLint) callconv(.C) void,
            .readBuffer => *const fn (_src: GLenum) callconv(.C) void,
            .readPixels => *const fn (_x: GLint, _y: GLint, _width: GLsizei, _height: GLsizei, _format: GLenum, _type: GLenum, _pixels: ?*anyopaque) callconv(.C) void,
            .getBooleanv => *const fn (_pname: GLenum, _data: [*c]GLboolean) callconv(.C) void,
            .getDoublev => *const fn (_pname: GLenum, _data: [*c]GLdouble) callconv(.C) void,
            .getError => *const fn () callconv(.C) GLenum,
            .getFloatv => *const fn (_pname: GLenum, _data: [*c]GLfloat) callconv(.C) void,
            .getIntegerv => *const fn (_pname: GLenum, _data: [*c]GLint) callconv(.C) void,
            .getString => *const fn (_name: GLenum) callconv(.C) ?[*:0]const GLubyte,
            .getTexImage => *const fn (_target: GLenum, _level: GLint, _format: GLenum, _type: GLenum, _pixels: ?*anyopaque) callconv(.C) void,
            .getTexParameterfv => *const fn (_target: GLenum, _pname: GLenum, _params: [*c]GLfloat) callconv(.C) void,
            .getTexParameteriv => *const fn (_target: GLenum, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .getTexLevelParameterfv => *const fn (_target: GLenum, _level: GLint, _pname: GLenum, _params: [*c]GLfloat) callconv(.C) void,
            .getTexLevelParameteriv => *const fn (_target: GLenum, _level: GLint, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .isEnabled => *const fn (_cap: GLenum) callconv(.C) GLboolean,
            .depthRange => *const fn (_n: GLdouble, _f: GLdouble) callconv(.C) void,
            .viewport => *const fn (_x: GLint, _y: GLint, _width: GLsizei, _height: GLsizei) callconv(.C) void,
            .newList => *const fn (_list: GLuint, _mode: GLenum) callconv(.C) void,
            .endList => *const fn () callconv(.C) void,
            .callList => *const fn (_list: GLuint) callconv(.C) void,
            .callLists => *const fn (_n: GLsizei, _type: GLenum, _lists: ?*const anyopaque) callconv(.C) void,
            .deleteLists => *const fn (_list: GLuint, _range: GLsizei) callconv(.C) void,
            .genLists => *const fn (_range: GLsizei) callconv(.C) GLuint,
            .listBase => *const fn (_base: GLuint) callconv(.C) void,
            .begin => *const fn (_mode: GLenum) callconv(.C) void,
            .bitmap => *const fn (_width: GLsizei, _height: GLsizei, _xorig: GLfloat, _yorig: GLfloat, _xmove: GLfloat, _ymove: GLfloat, _bitmap: ?[*:0]const GLubyte) callconv(.C) void,
            .color3b => *const fn (_red: GLbyte, _green: GLbyte, _blue: GLbyte) callconv(.C) void,
            .color3bv => *const fn (_v: [*c]const GLbyte) callconv(.C) void,
            .color3d => *const fn (_red: GLdouble, _green: GLdouble, _blue: GLdouble) callconv(.C) void,
            .color3dv => *const fn (_v: [*c]const GLdouble) callconv(.C) void,
            .color3f => *const fn (_red: GLfloat, _green: GLfloat, _blue: GLfloat) callconv(.C) void,
            .color3fv => *const fn (_v: [*c]const GLfloat) callconv(.C) void,
            .color3i => *const fn (_red: GLint, _green: GLint, _blue: GLint) callconv(.C) void,
            .color3iv => *const fn (_v: [*c]const GLint) callconv(.C) void,
            .color3s => *const fn (_red: GLshort, _green: GLshort, _blue: GLshort) callconv(.C) void,
            .color3sv => *const fn (_v: [*c]const GLshort) callconv(.C) void,
            .color3ub => *const fn (_red: GLubyte, _green: GLubyte, _blue: GLubyte) callconv(.C) void,
            .color3ubv => *const fn (_v: ?[*:0]const GLubyte) callconv(.C) void,
            .color3ui => *const fn (_red: GLuint, _green: GLuint, _blue: GLuint) callconv(.C) void,
            .color3uiv => *const fn (_v: [*c]const GLuint) callconv(.C) void,
            .color3us => *const fn (_red: GLushort, _green: GLushort, _blue: GLushort) callconv(.C) void,
            .color3usv => *const fn (_v: [*c]const GLushort) callconv(.C) void,
            .color4b => *const fn (_red: GLbyte, _green: GLbyte, _blue: GLbyte, _alpha: GLbyte) callconv(.C) void,
            .color4bv => *const fn (_v: [*c]const GLbyte) callconv(.C) void,
            .color4d => *const fn (_red: GLdouble, _green: GLdouble, _blue: GLdouble, _alpha: GLdouble) callconv(.C) void,
            .color4dv => *const fn (_v: [*c]const GLdouble) callconv(.C) void,
            .color4f => *const fn (_red: GLfloat, _green: GLfloat, _blue: GLfloat, _alpha: GLfloat) callconv(.C) void,
            .color4fv => *const fn (_v: [*c]const GLfloat) callconv(.C) void,
            .color4i => *const fn (_red: GLint, _green: GLint, _blue: GLint, _alpha: GLint) callconv(.C) void,
            .color4iv => *const fn (_v: [*c]const GLint) callconv(.C) void,
            .color4s => *const fn (_red: GLshort, _green: GLshort, _blue: GLshort, _alpha: GLshort) callconv(.C) void,
            .color4sv => *const fn (_v: [*c]const GLshort) callconv(.C) void,
            .color4ub => *const fn (_red: GLubyte, _green: GLubyte, _blue: GLubyte, _alpha: GLubyte) callconv(.C) void,
            .color4ubv => *const fn (_v: ?[*:0]const GLubyte) callconv(.C) void,
            .color4ui => *const fn (_red: GLuint, _green: GLuint, _blue: GLuint, _alpha: GLuint) callconv(.C) void,
            .color4uiv => *const fn (_v: [*c]const GLuint) callconv(.C) void,
            .color4us => *const fn (_red: GLushort, _green: GLushort, _blue: GLushort, _alpha: GLushort) callconv(.C) void,
            .color4usv => *const fn (_v: [*c]const GLushort) callconv(.C) void,
            .edgeFlag => *const fn (_flag: GLboolean) callconv(.C) void,
            .edgeFlagv => *const fn (_flag: [*c]const GLboolean) callconv(.C) void,
            .end => *const fn () callconv(.C) void,
            .indexd => *const fn (_c: GLdouble) callconv(.C) void,
            .indexdv => *const fn (_c: [*c]const GLdouble) callconv(.C) void,
            .indexf => *const fn (_c: GLfloat) callconv(.C) void,
            .indexfv => *const fn (_c: [*c]const GLfloat) callconv(.C) void,
            .indexi => *const fn (_c: GLint) callconv(.C) void,
            .indexiv => *const fn (_c: [*c]const GLint) callconv(.C) void,
            .indexs => *const fn (_c: GLshort) callconv(.C) void,
            .indexsv => *const fn (_c: [*c]const GLshort) callconv(.C) void,
            .normal3b => *const fn (_nx: GLbyte, _ny: GLbyte, _nz: GLbyte) callconv(.C) void,
            .normal3bv => *const fn (_v: [*c]const GLbyte) callconv(.C) void,
            .normal3d => *const fn (_nx: GLdouble, _ny: GLdouble, _nz: GLdouble) callconv(.C) void,
            .normal3dv => *const fn (_v: [*c]const GLdouble) callconv(.C) void,
            .normal3f => *const fn (_nx: GLfloat, _ny: GLfloat, _nz: GLfloat) callconv(.C) void,
            .normal3fv => *const fn (_v: [*c]const GLfloat) callconv(.C) void,
            .normal3i => *const fn (_nx: GLint, _ny: GLint, _nz: GLint) callconv(.C) void,
            .normal3iv => *const fn (_v: [*c]const GLint) callconv(.C) void,
            .normal3s => *const fn (_nx: GLshort, _ny: GLshort, _nz: GLshort) callconv(.C) void,
            .normal3sv => *const fn (_v: [*c]const GLshort) callconv(.C) void,
            .rasterPos2d => *const fn (_x: GLdouble, _y: GLdouble) callconv(.C) void,
            .rasterPos2dv => *const fn (_v: [*c]const GLdouble) callconv(.C) void,
            .rasterPos2f => *const fn (_x: GLfloat, _y: GLfloat) callconv(.C) void,
            .rasterPos2fv => *const fn (_v: [*c]const GLfloat) callconv(.C) void,
            .rasterPos2i => *const fn (_x: GLint, _y: GLint) callconv(.C) void,
            .rasterPos2iv => *const fn (_v: [*c]const GLint) callconv(.C) void,
            .rasterPos2s => *const fn (_x: GLshort, _y: GLshort) callconv(.C) void,
            .rasterPos2sv => *const fn (_v: [*c]const GLshort) callconv(.C) void,
            .rasterPos3d => *const fn (_x: GLdouble, _y: GLdouble, _z: GLdouble) callconv(.C) void,
            .rasterPos3dv => *const fn (_v: [*c]const GLdouble) callconv(.C) void,
            .rasterPos3f => *const fn (_x: GLfloat, _y: GLfloat, _z: GLfloat) callconv(.C) void,
            .rasterPos3fv => *const fn (_v: [*c]const GLfloat) callconv(.C) void,
            .rasterPos3i => *const fn (_x: GLint, _y: GLint, _z: GLint) callconv(.C) void,
            .rasterPos3iv => *const fn (_v: [*c]const GLint) callconv(.C) void,
            .rasterPos3s => *const fn (_x: GLshort, _y: GLshort, _z: GLshort) callconv(.C) void,
            .rasterPos3sv => *const fn (_v: [*c]const GLshort) callconv(.C) void,
            .rasterPos4d => *const fn (_x: GLdouble, _y: GLdouble, _z: GLdouble, _w: GLdouble) callconv(.C) void,
            .rasterPos4dv => *const fn (_v: [*c]const GLdouble) callconv(.C) void,
            .rasterPos4f => *const fn (_x: GLfloat, _y: GLfloat, _z: GLfloat, _w: GLfloat) callconv(.C) void,
            .rasterPos4fv => *const fn (_v: [*c]const GLfloat) callconv(.C) void,
            .rasterPos4i => *const fn (_x: GLint, _y: GLint, _z: GLint, _w: GLint) callconv(.C) void,
            .rasterPos4iv => *const fn (_v: [*c]const GLint) callconv(.C) void,
            .rasterPos4s => *const fn (_x: GLshort, _y: GLshort, _z: GLshort, _w: GLshort) callconv(.C) void,
            .rasterPos4sv => *const fn (_v: [*c]const GLshort) callconv(.C) void,
            .rectd => *const fn (_x1: GLdouble, _y1: GLdouble, _x2: GLdouble, _y2: GLdouble) callconv(.C) void,
            .rectdv => *const fn (_v1: [*c]const GLdouble, _v2: [*c]const GLdouble) callconv(.C) void,
            .rectf => *const fn (_x1: GLfloat, _y1: GLfloat, _x2: GLfloat, _y2: GLfloat) callconv(.C) void,
            .rectfv => *const fn (_v1: [*c]const GLfloat, _v2: [*c]const GLfloat) callconv(.C) void,
            .recti => *const fn (_x1: GLint, _y1: GLint, _x2: GLint, _y2: GLint) callconv(.C) void,
            .rectiv => *const fn (_v1: [*c]const GLint, _v2: [*c]const GLint) callconv(.C) void,
            .rects => *const fn (_x1: GLshort, _y1: GLshort, _x2: GLshort, _y2: GLshort) callconv(.C) void,
            .rectsv => *const fn (_v1: [*c]const GLshort, _v2: [*c]const GLshort) callconv(.C) void,
            .texCoord1d => *const fn (_s: GLdouble) callconv(.C) void,
            .texCoord1dv => *const fn (_v: [*c]const GLdouble) callconv(.C) void,
            .texCoord1f => *const fn (_s: GLfloat) callconv(.C) void,
            .texCoord1fv => *const fn (_v: [*c]const GLfloat) callconv(.C) void,
            .texCoord1i => *const fn (_s: GLint) callconv(.C) void,
            .texCoord1iv => *const fn (_v: [*c]const GLint) callconv(.C) void,
            .texCoord1s => *const fn (_s: GLshort) callconv(.C) void,
            .texCoord1sv => *const fn (_v: [*c]const GLshort) callconv(.C) void,
            .texCoord2d => *const fn (_s: GLdouble, _t: GLdouble) callconv(.C) void,
            .texCoord2dv => *const fn (_v: [*c]const GLdouble) callconv(.C) void,
            .texCoord2f => *const fn (_s: GLfloat, _t: GLfloat) callconv(.C) void,
            .texCoord2fv => *const fn (_v: [*c]const GLfloat) callconv(.C) void,
            .texCoord2i => *const fn (_s: GLint, _t: GLint) callconv(.C) void,
            .texCoord2iv => *const fn (_v: [*c]const GLint) callconv(.C) void,
            .texCoord2s => *const fn (_s: GLshort, _t: GLshort) callconv(.C) void,
            .texCoord2sv => *const fn (_v: [*c]const GLshort) callconv(.C) void,
            .texCoord3d => *const fn (_s: GLdouble, _t: GLdouble, _r: GLdouble) callconv(.C) void,
            .texCoord3dv => *const fn (_v: [*c]const GLdouble) callconv(.C) void,
            .texCoord3f => *const fn (_s: GLfloat, _t: GLfloat, _r: GLfloat) callconv(.C) void,
            .texCoord3fv => *const fn (_v: [*c]const GLfloat) callconv(.C) void,
            .texCoord3i => *const fn (_s: GLint, _t: GLint, _r: GLint) callconv(.C) void,
            .texCoord3iv => *const fn (_v: [*c]const GLint) callconv(.C) void,
            .texCoord3s => *const fn (_s: GLshort, _t: GLshort, _r: GLshort) callconv(.C) void,
            .texCoord3sv => *const fn (_v: [*c]const GLshort) callconv(.C) void,
            .texCoord4d => *const fn (_s: GLdouble, _t: GLdouble, _r: GLdouble, _q: GLdouble) callconv(.C) void,
            .texCoord4dv => *const fn (_v: [*c]const GLdouble) callconv(.C) void,
            .texCoord4f => *const fn (_s: GLfloat, _t: GLfloat, _r: GLfloat, _q: GLfloat) callconv(.C) void,
            .texCoord4fv => *const fn (_v: [*c]const GLfloat) callconv(.C) void,
            .texCoord4i => *const fn (_s: GLint, _t: GLint, _r: GLint, _q: GLint) callconv(.C) void,
            .texCoord4iv => *const fn (_v: [*c]const GLint) callconv(.C) void,
            .texCoord4s => *const fn (_s: GLshort, _t: GLshort, _r: GLshort, _q: GLshort) callconv(.C) void,
            .texCoord4sv => *const fn (_v: [*c]const GLshort) callconv(.C) void,
            .vertex2d => *const fn (_x: GLdouble, _y: GLdouble) callconv(.C) void,
            .vertex2dv => *const fn (_v: [*c]const GLdouble) callconv(.C) void,
            .vertex2f => *const fn (_x: GLfloat, _y: GLfloat) callconv(.C) void,
            .vertex2fv => *const fn (_v: [*c]const GLfloat) callconv(.C) void,
            .vertex2i => *const fn (_x: GLint, _y: GLint) callconv(.C) void,
            .vertex2iv => *const fn (_v: [*c]const GLint) callconv(.C) void,
            .vertex2s => *const fn (_x: GLshort, _y: GLshort) callconv(.C) void,
            .vertex2sv => *const fn (_v: [*c]const GLshort) callconv(.C) void,
            .vertex3d => *const fn (_x: GLdouble, _y: GLdouble, _z: GLdouble) callconv(.C) void,
            .vertex3dv => *const fn (_v: [*c]const GLdouble) callconv(.C) void,
            .vertex3f => *const fn (_x: GLfloat, _y: GLfloat, _z: GLfloat) callconv(.C) void,
            .vertex3fv => *const fn (_v: [*c]const GLfloat) callconv(.C) void,
            .vertex3i => *const fn (_x: GLint, _y: GLint, _z: GLint) callconv(.C) void,
            .vertex3iv => *const fn (_v: [*c]const GLint) callconv(.C) void,
            .vertex3s => *const fn (_x: GLshort, _y: GLshort, _z: GLshort) callconv(.C) void,
            .vertex3sv => *const fn (_v: [*c]const GLshort) callconv(.C) void,
            .vertex4d => *const fn (_x: GLdouble, _y: GLdouble, _z: GLdouble, _w: GLdouble) callconv(.C) void,
            .vertex4dv => *const fn (_v: [*c]const GLdouble) callconv(.C) void,
            .vertex4f => *const fn (_x: GLfloat, _y: GLfloat, _z: GLfloat, _w: GLfloat) callconv(.C) void,
            .vertex4fv => *const fn (_v: [*c]const GLfloat) callconv(.C) void,
            .vertex4i => *const fn (_x: GLint, _y: GLint, _z: GLint, _w: GLint) callconv(.C) void,
            .vertex4iv => *const fn (_v: [*c]const GLint) callconv(.C) void,
            .vertex4s => *const fn (_x: GLshort, _y: GLshort, _z: GLshort, _w: GLshort) callconv(.C) void,
            .vertex4sv => *const fn (_v: [*c]const GLshort) callconv(.C) void,
            .clipPlane => *const fn (_plane: GLenum, _equation: [*c]const GLdouble) callconv(.C) void,
            .colorMaterial => *const fn (_face: GLenum, _mode: GLenum) callconv(.C) void,
            .fogf => *const fn (_pname: GLenum, _param: GLfloat) callconv(.C) void,
            .fogfv => *const fn (_pname: GLenum, _params: [*c]const GLfloat) callconv(.C) void,
            .fogi => *const fn (_pname: GLenum, _param: GLint) callconv(.C) void,
            .fogiv => *const fn (_pname: GLenum, _params: [*c]const GLint) callconv(.C) void,
            .lightf => *const fn (_light: GLenum, _pname: GLenum, _param: GLfloat) callconv(.C) void,
            .lightfv => *const fn (_light: GLenum, _pname: GLenum, _params: [*c]const GLfloat) callconv(.C) void,
            .lighti => *const fn (_light: GLenum, _pname: GLenum, _param: GLint) callconv(.C) void,
            .lightiv => *const fn (_light: GLenum, _pname: GLenum, _params: [*c]const GLint) callconv(.C) void,
            .lightModelf => *const fn (_pname: GLenum, _param: GLfloat) callconv(.C) void,
            .lightModelfv => *const fn (_pname: GLenum, _params: [*c]const GLfloat) callconv(.C) void,
            .lightModeli => *const fn (_pname: GLenum, _param: GLint) callconv(.C) void,
            .lightModeliv => *const fn (_pname: GLenum, _params: [*c]const GLint) callconv(.C) void,
            .lineStipple => *const fn (_factor: GLint, _pattern: GLushort) callconv(.C) void,
            .materialf => *const fn (_face: GLenum, _pname: GLenum, _param: GLfloat) callconv(.C) void,
            .materialfv => *const fn (_face: GLenum, _pname: GLenum, _params: [*c]const GLfloat) callconv(.C) void,
            .materiali => *const fn (_face: GLenum, _pname: GLenum, _param: GLint) callconv(.C) void,
            .materialiv => *const fn (_face: GLenum, _pname: GLenum, _params: [*c]const GLint) callconv(.C) void,
            .polygonStipple => *const fn (_mask: ?[*:0]const GLubyte) callconv(.C) void,
            .shadeModel => *const fn (_mode: GLenum) callconv(.C) void,
            .texEnvf => *const fn (_target: GLenum, _pname: GLenum, _param: GLfloat) callconv(.C) void,
            .texEnvfv => *const fn (_target: GLenum, _pname: GLenum, _params: [*c]const GLfloat) callconv(.C) void,
            .texEnvi => *const fn (_target: GLenum, _pname: GLenum, _param: GLint) callconv(.C) void,
            .texEnviv => *const fn (_target: GLenum, _pname: GLenum, _params: [*c]const GLint) callconv(.C) void,
            .texGend => *const fn (_coord: GLenum, _pname: GLenum, _param: GLdouble) callconv(.C) void,
            .texGendv => *const fn (_coord: GLenum, _pname: GLenum, _params: [*c]const GLdouble) callconv(.C) void,
            .texGenf => *const fn (_coord: GLenum, _pname: GLenum, _param: GLfloat) callconv(.C) void,
            .texGenfv => *const fn (_coord: GLenum, _pname: GLenum, _params: [*c]const GLfloat) callconv(.C) void,
            .texGeni => *const fn (_coord: GLenum, _pname: GLenum, _param: GLint) callconv(.C) void,
            .texGeniv => *const fn (_coord: GLenum, _pname: GLenum, _params: [*c]const GLint) callconv(.C) void,
            .feedbackBuffer => *const fn (_size: GLsizei, _type: GLenum, _buffer: [*c]GLfloat) callconv(.C) void,
            .selectBuffer => *const fn (_size: GLsizei, _buffer: [*c]GLuint) callconv(.C) void,
            .renderMode => *const fn (_mode: GLenum) callconv(.C) GLint,
            .initNames => *const fn () callconv(.C) void,
            .loadName => *const fn (_name: GLuint) callconv(.C) void,
            .passThrough => *const fn (_token: GLfloat) callconv(.C) void,
            .popName => *const fn () callconv(.C) void,
            .pushName => *const fn (_name: GLuint) callconv(.C) void,
            .clearAccum => *const fn (_red: GLfloat, _green: GLfloat, _blue: GLfloat, _alpha: GLfloat) callconv(.C) void,
            .clearIndex => *const fn (_c: GLfloat) callconv(.C) void,
            .indexMask => *const fn (_mask: GLuint) callconv(.C) void,
            .accum => *const fn (_op: GLenum, _value: GLfloat) callconv(.C) void,
            .popAttrib => *const fn () callconv(.C) void,
            .pushAttrib => *const fn (_mask: GLbitfield) callconv(.C) void,
            .map1d => *const fn (_target: GLenum, _u1: GLdouble, _u2: GLdouble, _stride: GLint, _order: GLint, _points: [*c]const GLdouble) callconv(.C) void,
            .map1f => *const fn (_target: GLenum, _u1: GLfloat, _u2: GLfloat, _stride: GLint, _order: GLint, _points: [*c]const GLfloat) callconv(.C) void,
            .map2d => *const fn (_target: GLenum, _u1: GLdouble, _u2: GLdouble, _ustride: GLint, _uorder: GLint, _v1: GLdouble, _v2: GLdouble, _vstride: GLint, _vorder: GLint, _points: [*c]const GLdouble) callconv(.C) void,
            .map2f => *const fn (_target: GLenum, _u1: GLfloat, _u2: GLfloat, _ustride: GLint, _uorder: GLint, _v1: GLfloat, _v2: GLfloat, _vstride: GLint, _vorder: GLint, _points: [*c]const GLfloat) callconv(.C) void,
            .mapGrid1d => *const fn (_un: GLint, _u1: GLdouble, _u2: GLdouble) callconv(.C) void,
            .mapGrid1f => *const fn (_un: GLint, _u1: GLfloat, _u2: GLfloat) callconv(.C) void,
            .mapGrid2d => *const fn (_un: GLint, _u1: GLdouble, _u2: GLdouble, _vn: GLint, _v1: GLdouble, _v2: GLdouble) callconv(.C) void,
            .mapGrid2f => *const fn (_un: GLint, _u1: GLfloat, _u2: GLfloat, _vn: GLint, _v1: GLfloat, _v2: GLfloat) callconv(.C) void,
            .evalCoord1d => *const fn (_u: GLdouble) callconv(.C) void,
            .evalCoord1dv => *const fn (_u: [*c]const GLdouble) callconv(.C) void,
            .evalCoord1f => *const fn (_u: GLfloat) callconv(.C) void,
            .evalCoord1fv => *const fn (_u: [*c]const GLfloat) callconv(.C) void,
            .evalCoord2d => *const fn (_u: GLdouble, _v: GLdouble) callconv(.C) void,
            .evalCoord2dv => *const fn (_u: [*c]const GLdouble) callconv(.C) void,
            .evalCoord2f => *const fn (_u: GLfloat, _v: GLfloat) callconv(.C) void,
            .evalCoord2fv => *const fn (_u: [*c]const GLfloat) callconv(.C) void,
            .evalMesh1 => *const fn (_mode: GLenum, _i1: GLint, _i2: GLint) callconv(.C) void,
            .evalPoint1 => *const fn (_i: GLint) callconv(.C) void,
            .evalMesh2 => *const fn (_mode: GLenum, _i1: GLint, _i2: GLint, _j1: GLint, _j2: GLint) callconv(.C) void,
            .evalPoint2 => *const fn (_i: GLint, _j: GLint) callconv(.C) void,
            .alphaFunc => *const fn (_func: GLenum, _ref: GLfloat) callconv(.C) void,
            .pixelZoom => *const fn (_xfactor: GLfloat, _yfactor: GLfloat) callconv(.C) void,
            .pixelTransferf => *const fn (_pname: GLenum, _param: GLfloat) callconv(.C) void,
            .pixelTransferi => *const fn (_pname: GLenum, _param: GLint) callconv(.C) void,
            .pixelMapfv => *const fn (_map: GLenum, _mapsize: GLsizei, _values: [*c]const GLfloat) callconv(.C) void,
            .pixelMapuiv => *const fn (_map: GLenum, _mapsize: GLsizei, _values: [*c]const GLuint) callconv(.C) void,
            .pixelMapusv => *const fn (_map: GLenum, _mapsize: GLsizei, _values: [*c]const GLushort) callconv(.C) void,
            .copyPixels => *const fn (_x: GLint, _y: GLint, _width: GLsizei, _height: GLsizei, _type: GLenum) callconv(.C) void,
            .drawPixels => *const fn (_width: GLsizei, _height: GLsizei, _format: GLenum, _type: GLenum, _pixels: ?*const anyopaque) callconv(.C) void,
            .getClipPlane => *const fn (_plane: GLenum, _equation: [*c]GLdouble) callconv(.C) void,
            .getLightfv => *const fn (_light: GLenum, _pname: GLenum, _params: [*c]GLfloat) callconv(.C) void,
            .getLightiv => *const fn (_light: GLenum, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .getMapdv => *const fn (_target: GLenum, _query: GLenum, _v: [*c]GLdouble) callconv(.C) void,
            .getMapfv => *const fn (_target: GLenum, _query: GLenum, _v: [*c]GLfloat) callconv(.C) void,
            .getMapiv => *const fn (_target: GLenum, _query: GLenum, _v: [*c]GLint) callconv(.C) void,
            .getMaterialfv => *const fn (_face: GLenum, _pname: GLenum, _params: [*c]GLfloat) callconv(.C) void,
            .getMaterialiv => *const fn (_face: GLenum, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .getPixelMapfv => *const fn (_map: GLenum, _values: [*c]GLfloat) callconv(.C) void,
            .getPixelMapuiv => *const fn (_map: GLenum, _values: [*c]GLuint) callconv(.C) void,
            .getPixelMapusv => *const fn (_map: GLenum, _values: [*c]GLushort) callconv(.C) void,
            .getPolygonStipple => *const fn (_mask: [*c]GLubyte) callconv(.C) void,
            .getTexEnvfv => *const fn (_target: GLenum, _pname: GLenum, _params: [*c]GLfloat) callconv(.C) void,
            .getTexEnviv => *const fn (_target: GLenum, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .getTexGendv => *const fn (_coord: GLenum, _pname: GLenum, _params: [*c]GLdouble) callconv(.C) void,
            .getTexGenfv => *const fn (_coord: GLenum, _pname: GLenum, _params: [*c]GLfloat) callconv(.C) void,
            .getTexGeniv => *const fn (_coord: GLenum, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .isList => *const fn (_list: GLuint) callconv(.C) GLboolean,
            .frustum => *const fn (_left: GLdouble, _right: GLdouble, _bottom: GLdouble, _top: GLdouble, _zNear: GLdouble, _zFar: GLdouble) callconv(.C) void,
            .loadIdentity => *const fn () callconv(.C) void,
            .loadMatrixf => *const fn (_m: [*c]const GLfloat) callconv(.C) void,
            .loadMatrixd => *const fn (_m: [*c]const GLdouble) callconv(.C) void,
            .matrixMode => *const fn (_mode: GLenum) callconv(.C) void,
            .multMatrixf => *const fn (_m: [*c]const GLfloat) callconv(.C) void,
            .multMatrixd => *const fn (_m: [*c]const GLdouble) callconv(.C) void,
            .ortho => *const fn (_left: GLdouble, _right: GLdouble, _bottom: GLdouble, _top: GLdouble, _zNear: GLdouble, _zFar: GLdouble) callconv(.C) void,
            .popMatrix => *const fn () callconv(.C) void,
            .pushMatrix => *const fn () callconv(.C) void,
            .rotated => *const fn (_angle: GLdouble, _x: GLdouble, _y: GLdouble, _z: GLdouble) callconv(.C) void,
            .rotatef => *const fn (_angle: GLfloat, _x: GLfloat, _y: GLfloat, _z: GLfloat) callconv(.C) void,
            .scaled => *const fn (_x: GLdouble, _y: GLdouble, _z: GLdouble) callconv(.C) void,
            .scalef => *const fn (_x: GLfloat, _y: GLfloat, _z: GLfloat) callconv(.C) void,
            .translated => *const fn (_x: GLdouble, _y: GLdouble, _z: GLdouble) callconv(.C) void,
            .translatef => *const fn (_x: GLfloat, _y: GLfloat, _z: GLfloat) callconv(.C) void,
            .drawArrays => *const fn (_mode: GLenum, _first: GLint, _count: GLsizei) callconv(.C) void,
            .drawElements => *const fn (_mode: GLenum, _count: GLsizei, _type: GLenum, _indices: ?*const anyopaque) callconv(.C) void,
            .getPointerv => *const fn (_pname: GLenum, _params: ?*?*anyopaque) callconv(.C) void,
            .polygonOffset => *const fn (_factor: GLfloat, _units: GLfloat) callconv(.C) void,
            .copyTexImage1D => *const fn (_target: GLenum, _level: GLint, _internalformat: GLenum, _x: GLint, _y: GLint, _width: GLsizei, _border: GLint) callconv(.C) void,
            .copyTexImage2D => *const fn (_target: GLenum, _level: GLint, _internalformat: GLenum, _x: GLint, _y: GLint, _width: GLsizei, _height: GLsizei, _border: GLint) callconv(.C) void,
            .copyTexSubImage1D => *const fn (_target: GLenum, _level: GLint, _xoffset: GLint, _x: GLint, _y: GLint, _width: GLsizei) callconv(.C) void,
            .copyTexSubImage2D => *const fn (_target: GLenum, _level: GLint, _xoffset: GLint, _yoffset: GLint, _x: GLint, _y: GLint, _width: GLsizei, _height: GLsizei) callconv(.C) void,
            .texSubImage1D => *const fn (_target: GLenum, _level: GLint, _xoffset: GLint, _width: GLsizei, _format: GLenum, _type: GLenum, _pixels: ?*const anyopaque) callconv(.C) void,
            .texSubImage2D => *const fn (_target: GLenum, _level: GLint, _xoffset: GLint, _yoffset: GLint, _width: GLsizei, _height: GLsizei, _format: GLenum, _type: GLenum, _pixels: ?*const anyopaque) callconv(.C) void,
            .bindTexture => *const fn (_target: GLenum, _texture: GLuint) callconv(.C) void,
            .deleteTextures => *const fn (_n: GLsizei, _textures: [*c]const GLuint) callconv(.C) void,
            .genTextures => *const fn (_n: GLsizei, _textures: [*c]GLuint) callconv(.C) void,
            .isTexture => *const fn (_texture: GLuint) callconv(.C) GLboolean,
            .arrayElement => *const fn (_i: GLint) callconv(.C) void,
            .colorPointer => *const fn (_size: GLint, _type: GLenum, _stride: GLsizei, _pointer: ?*const anyopaque) callconv(.C) void,
            .disableClientState => *const fn (_array: GLenum) callconv(.C) void,
            .edgeFlagPointer => *const fn (_stride: GLsizei, _pointer: ?*const anyopaque) callconv(.C) void,
            .enableClientState => *const fn (_array: GLenum) callconv(.C) void,
            .indexPointer => *const fn (_type: GLenum, _stride: GLsizei, _pointer: ?*const anyopaque) callconv(.C) void,
            .interleavedArrays => *const fn (_format: GLenum, _stride: GLsizei, _pointer: ?*const anyopaque) callconv(.C) void,
            .normalPointer => *const fn (_type: GLenum, _stride: GLsizei, _pointer: ?*const anyopaque) callconv(.C) void,
            .texCoordPointer => *const fn (_size: GLint, _type: GLenum, _stride: GLsizei, _pointer: ?*const anyopaque) callconv(.C) void,
            .vertexPointer => *const fn (_size: GLint, _type: GLenum, _stride: GLsizei, _pointer: ?*const anyopaque) callconv(.C) void,
            .areTexturesResident => *const fn (_n: GLsizei, _textures: [*c]const GLuint, _residences: [*c]GLboolean) callconv(.C) GLboolean,
            .prioritizeTextures => *const fn (_n: GLsizei, _textures: [*c]const GLuint, _priorities: [*c]const GLfloat) callconv(.C) void,
            .indexub => *const fn (_c: GLubyte) callconv(.C) void,
            .indexubv => *const fn (_c: ?[*:0]const GLubyte) callconv(.C) void,
            .popClientAttrib => *const fn () callconv(.C) void,
            .pushClientAttrib => *const fn (_mask: GLbitfield) callconv(.C) void,
            .drawRangeElements => *const fn (_mode: GLenum, _start: GLuint, _end: GLuint, _count: GLsizei, _type: GLenum, _indices: ?*const anyopaque) callconv(.C) void,
            .texImage3D => *const fn (_target: GLenum, _level: GLint, _internalformat: GLint, _width: GLsizei, _height: GLsizei, _depth: GLsizei, _border: GLint, _format: GLenum, _type: GLenum, _pixels: ?*const anyopaque) callconv(.C) void,
            .texSubImage3D => *const fn (_target: GLenum, _level: GLint, _xoffset: GLint, _yoffset: GLint, _zoffset: GLint, _width: GLsizei, _height: GLsizei, _depth: GLsizei, _format: GLenum, _type: GLenum, _pixels: ?*const anyopaque) callconv(.C) void,
            .copyTexSubImage3D => *const fn (_target: GLenum, _level: GLint, _xoffset: GLint, _yoffset: GLint, _zoffset: GLint, _x: GLint, _y: GLint, _width: GLsizei, _height: GLsizei) callconv(.C) void,
            .activeTexture => *const fn (_texture: GLenum) callconv(.C) void,
            .sampleCoverage => *const fn (_value: GLfloat, _invert: GLboolean) callconv(.C) void,
            .compressedTexImage3D => *const fn (_target: GLenum, _level: GLint, _internalformat: GLenum, _width: GLsizei, _height: GLsizei, _depth: GLsizei, _border: GLint, _imageSize: GLsizei, _data: ?*const anyopaque) callconv(.C) void,
            .compressedTexImage2D => *const fn (_target: GLenum, _level: GLint, _internalformat: GLenum, _width: GLsizei, _height: GLsizei, _border: GLint, _imageSize: GLsizei, _data: ?*const anyopaque) callconv(.C) void,
            .compressedTexImage1D => *const fn (_target: GLenum, _level: GLint, _internalformat: GLenum, _width: GLsizei, _border: GLint, _imageSize: GLsizei, _data: ?*const anyopaque) callconv(.C) void,
            .compressedTexSubImage3D => *const fn (_target: GLenum, _level: GLint, _xoffset: GLint, _yoffset: GLint, _zoffset: GLint, _width: GLsizei, _height: GLsizei, _depth: GLsizei, _format: GLenum, _imageSize: GLsizei, _data: ?*const anyopaque) callconv(.C) void,
            .compressedTexSubImage2D => *const fn (_target: GLenum, _level: GLint, _xoffset: GLint, _yoffset: GLint, _width: GLsizei, _height: GLsizei, _format: GLenum, _imageSize: GLsizei, _data: ?*const anyopaque) callconv(.C) void,
            .compressedTexSubImage1D => *const fn (_target: GLenum, _level: GLint, _xoffset: GLint, _width: GLsizei, _format: GLenum, _imageSize: GLsizei, _data: ?*const anyopaque) callconv(.C) void,
            .getCompressedTexImage => *const fn (_target: GLenum, _level: GLint, _img: ?*anyopaque) callconv(.C) void,
            .clientActiveTexture => *const fn (_texture: GLenum) callconv(.C) void,
            .multiTexCoord1d => *const fn (_target: GLenum, _s: GLdouble) callconv(.C) void,
            .multiTexCoord1dv => *const fn (_target: GLenum, _v: [*c]const GLdouble) callconv(.C) void,
            .multiTexCoord1f => *const fn (_target: GLenum, _s: GLfloat) callconv(.C) void,
            .multiTexCoord1fv => *const fn (_target: GLenum, _v: [*c]const GLfloat) callconv(.C) void,
            .multiTexCoord1i => *const fn (_target: GLenum, _s: GLint) callconv(.C) void,
            .multiTexCoord1iv => *const fn (_target: GLenum, _v: [*c]const GLint) callconv(.C) void,
            .multiTexCoord1s => *const fn (_target: GLenum, _s: GLshort) callconv(.C) void,
            .multiTexCoord1sv => *const fn (_target: GLenum, _v: [*c]const GLshort) callconv(.C) void,
            .multiTexCoord2d => *const fn (_target: GLenum, _s: GLdouble, _t: GLdouble) callconv(.C) void,
            .multiTexCoord2dv => *const fn (_target: GLenum, _v: [*c]const GLdouble) callconv(.C) void,
            .multiTexCoord2f => *const fn (_target: GLenum, _s: GLfloat, _t: GLfloat) callconv(.C) void,
            .multiTexCoord2fv => *const fn (_target: GLenum, _v: [*c]const GLfloat) callconv(.C) void,
            .multiTexCoord2i => *const fn (_target: GLenum, _s: GLint, _t: GLint) callconv(.C) void,
            .multiTexCoord2iv => *const fn (_target: GLenum, _v: [*c]const GLint) callconv(.C) void,
            .multiTexCoord2s => *const fn (_target: GLenum, _s: GLshort, _t: GLshort) callconv(.C) void,
            .multiTexCoord2sv => *const fn (_target: GLenum, _v: [*c]const GLshort) callconv(.C) void,
            .multiTexCoord3d => *const fn (_target: GLenum, _s: GLdouble, _t: GLdouble, _r: GLdouble) callconv(.C) void,
            .multiTexCoord3dv => *const fn (_target: GLenum, _v: [*c]const GLdouble) callconv(.C) void,
            .multiTexCoord3f => *const fn (_target: GLenum, _s: GLfloat, _t: GLfloat, _r: GLfloat) callconv(.C) void,
            .multiTexCoord3fv => *const fn (_target: GLenum, _v: [*c]const GLfloat) callconv(.C) void,
            .multiTexCoord3i => *const fn (_target: GLenum, _s: GLint, _t: GLint, _r: GLint) callconv(.C) void,
            .multiTexCoord3iv => *const fn (_target: GLenum, _v: [*c]const GLint) callconv(.C) void,
            .multiTexCoord3s => *const fn (_target: GLenum, _s: GLshort, _t: GLshort, _r: GLshort) callconv(.C) void,
            .multiTexCoord3sv => *const fn (_target: GLenum, _v: [*c]const GLshort) callconv(.C) void,
            .multiTexCoord4d => *const fn (_target: GLenum, _s: GLdouble, _t: GLdouble, _r: GLdouble, _q: GLdouble) callconv(.C) void,
            .multiTexCoord4dv => *const fn (_target: GLenum, _v: [*c]const GLdouble) callconv(.C) void,
            .multiTexCoord4f => *const fn (_target: GLenum, _s: GLfloat, _t: GLfloat, _r: GLfloat, _q: GLfloat) callconv(.C) void,
            .multiTexCoord4fv => *const fn (_target: GLenum, _v: [*c]const GLfloat) callconv(.C) void,
            .multiTexCoord4i => *const fn (_target: GLenum, _s: GLint, _t: GLint, _r: GLint, _q: GLint) callconv(.C) void,
            .multiTexCoord4iv => *const fn (_target: GLenum, _v: [*c]const GLint) callconv(.C) void,
            .multiTexCoord4s => *const fn (_target: GLenum, _s: GLshort, _t: GLshort, _r: GLshort, _q: GLshort) callconv(.C) void,
            .multiTexCoord4sv => *const fn (_target: GLenum, _v: [*c]const GLshort) callconv(.C) void,
            .loadTransposeMatrixf => *const fn (_m: [*c]const GLfloat) callconv(.C) void,
            .loadTransposeMatrixd => *const fn (_m: [*c]const GLdouble) callconv(.C) void,
            .multTransposeMatrixf => *const fn (_m: [*c]const GLfloat) callconv(.C) void,
            .multTransposeMatrixd => *const fn (_m: [*c]const GLdouble) callconv(.C) void,
            .blendFuncSeparate => *const fn (_sfactorRGB: GLenum, _dfactorRGB: GLenum, _sfactorAlpha: GLenum, _dfactorAlpha: GLenum) callconv(.C) void,
            .multiDrawArrays => *const fn (_mode: GLenum, _first: [*c]const GLint, _count: [*c]const GLsizei, _drawcount: GLsizei) callconv(.C) void,
            .multiDrawElements => *const fn (_mode: GLenum, _count: [*c]const GLsizei, _type: GLenum, _indices: [*c]const ?*const anyopaque, _drawcount: GLsizei) callconv(.C) void,
            .pointParameterf => *const fn (_pname: GLenum, _param: GLfloat) callconv(.C) void,
            .pointParameterfv => *const fn (_pname: GLenum, _params: [*c]const GLfloat) callconv(.C) void,
            .pointParameteri => *const fn (_pname: GLenum, _param: GLint) callconv(.C) void,
            .pointParameteriv => *const fn (_pname: GLenum, _params: [*c]const GLint) callconv(.C) void,
            .fogCoordf => *const fn (_coord: GLfloat) callconv(.C) void,
            .fogCoordfv => *const fn (_coord: [*c]const GLfloat) callconv(.C) void,
            .fogCoordd => *const fn (_coord: GLdouble) callconv(.C) void,
            .fogCoorddv => *const fn (_coord: [*c]const GLdouble) callconv(.C) void,
            .fogCoordPointer => *const fn (_type: GLenum, _stride: GLsizei, _pointer: ?*const anyopaque) callconv(.C) void,
            .secondaryColor3b => *const fn (_red: GLbyte, _green: GLbyte, _blue: GLbyte) callconv(.C) void,
            .secondaryColor3bv => *const fn (_v: [*c]const GLbyte) callconv(.C) void,
            .secondaryColor3d => *const fn (_red: GLdouble, _green: GLdouble, _blue: GLdouble) callconv(.C) void,
            .secondaryColor3dv => *const fn (_v: [*c]const GLdouble) callconv(.C) void,
            .secondaryColor3f => *const fn (_red: GLfloat, _green: GLfloat, _blue: GLfloat) callconv(.C) void,
            .secondaryColor3fv => *const fn (_v: [*c]const GLfloat) callconv(.C) void,
            .secondaryColor3i => *const fn (_red: GLint, _green: GLint, _blue: GLint) callconv(.C) void,
            .secondaryColor3iv => *const fn (_v: [*c]const GLint) callconv(.C) void,
            .secondaryColor3s => *const fn (_red: GLshort, _green: GLshort, _blue: GLshort) callconv(.C) void,
            .secondaryColor3sv => *const fn (_v: [*c]const GLshort) callconv(.C) void,
            .secondaryColor3ub => *const fn (_red: GLubyte, _green: GLubyte, _blue: GLubyte) callconv(.C) void,
            .secondaryColor3ubv => *const fn (_v: ?[*:0]const GLubyte) callconv(.C) void,
            .secondaryColor3ui => *const fn (_red: GLuint, _green: GLuint, _blue: GLuint) callconv(.C) void,
            .secondaryColor3uiv => *const fn (_v: [*c]const GLuint) callconv(.C) void,
            .secondaryColor3us => *const fn (_red: GLushort, _green: GLushort, _blue: GLushort) callconv(.C) void,
            .secondaryColor3usv => *const fn (_v: [*c]const GLushort) callconv(.C) void,
            .secondaryColorPointer => *const fn (_size: GLint, _type: GLenum, _stride: GLsizei, _pointer: ?*const anyopaque) callconv(.C) void,
            .windowPos2d => *const fn (_x: GLdouble, _y: GLdouble) callconv(.C) void,
            .windowPos2dv => *const fn (_v: [*c]const GLdouble) callconv(.C) void,
            .windowPos2f => *const fn (_x: GLfloat, _y: GLfloat) callconv(.C) void,
            .windowPos2fv => *const fn (_v: [*c]const GLfloat) callconv(.C) void,
            .windowPos2i => *const fn (_x: GLint, _y: GLint) callconv(.C) void,
            .windowPos2iv => *const fn (_v: [*c]const GLint) callconv(.C) void,
            .windowPos2s => *const fn (_x: GLshort, _y: GLshort) callconv(.C) void,
            .windowPos2sv => *const fn (_v: [*c]const GLshort) callconv(.C) void,
            .windowPos3d => *const fn (_x: GLdouble, _y: GLdouble, _z: GLdouble) callconv(.C) void,
            .windowPos3dv => *const fn (_v: [*c]const GLdouble) callconv(.C) void,
            .windowPos3f => *const fn (_x: GLfloat, _y: GLfloat, _z: GLfloat) callconv(.C) void,
            .windowPos3fv => *const fn (_v: [*c]const GLfloat) callconv(.C) void,
            .windowPos3i => *const fn (_x: GLint, _y: GLint, _z: GLint) callconv(.C) void,
            .windowPos3iv => *const fn (_v: [*c]const GLint) callconv(.C) void,
            .windowPos3s => *const fn (_x: GLshort, _y: GLshort, _z: GLshort) callconv(.C) void,
            .windowPos3sv => *const fn (_v: [*c]const GLshort) callconv(.C) void,
            .blendColor => *const fn (_red: GLfloat, _green: GLfloat, _blue: GLfloat, _alpha: GLfloat) callconv(.C) void,
            .blendEquation => *const fn (_mode: GLenum) callconv(.C) void,
            .genQueries => *const fn (_n: GLsizei, _ids: [*c]GLuint) callconv(.C) void,
            .deleteQueries => *const fn (_n: GLsizei, _ids: [*c]const GLuint) callconv(.C) void,
            .isQuery => *const fn (_id: GLuint) callconv(.C) GLboolean,
            .beginQuery => *const fn (_target: GLenum, _id: GLuint) callconv(.C) void,
            .endQuery => *const fn (_target: GLenum) callconv(.C) void,
            .getQueryiv => *const fn (_target: GLenum, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .getQueryObjectiv => *const fn (_id: GLuint, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .getQueryObjectuiv => *const fn (_id: GLuint, _pname: GLenum, _params: [*c]GLuint) callconv(.C) void,
            .bindBuffer => *const fn (_target: GLenum, _buffer: GLuint) callconv(.C) void,
            .deleteBuffers => *const fn (_n: GLsizei, _buffers: [*c]const GLuint) callconv(.C) void,
            .genBuffers => *const fn (_n: GLsizei, _buffers: [*c]GLuint) callconv(.C) void,
            .isBuffer => *const fn (_buffer: GLuint) callconv(.C) GLboolean,
            .bufferData => *const fn (_target: GLenum, _size: GLsizeiptr, _data: ?*const anyopaque, _usage: GLenum) callconv(.C) void,
            .bufferSubData => *const fn (_target: GLenum, _offset: GLintptr, _size: GLsizeiptr, _data: ?*const anyopaque) callconv(.C) void,
            .getBufferSubData => *const fn (_target: GLenum, _offset: GLintptr, _size: GLsizeiptr, _data: ?*anyopaque) callconv(.C) void,
            .mapBuffer => *const fn (_target: GLenum, _access: GLenum) callconv(.C) ?*anyopaque,
            .unmapBuffer => *const fn (_target: GLenum) callconv(.C) GLboolean,
            .getBufferParameteriv => *const fn (_target: GLenum, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .getBufferPointerv => *const fn (_target: GLenum, _pname: GLenum, _params: ?*?*anyopaque) callconv(.C) void,
            .blendEquationSeparate => *const fn (_modeRGB: GLenum, _modeAlpha: GLenum) callconv(.C) void,
            .drawBuffers => *const fn (_n: GLsizei, _bufs: [*c]const GLenum) callconv(.C) void,
            .stencilOpSeparate => *const fn (_face: GLenum, _sfail: GLenum, _dpfail: GLenum, _dppass: GLenum) callconv(.C) void,
            .stencilFuncSeparate => *const fn (_face: GLenum, _func: GLenum, _ref: GLint, _mask: GLuint) callconv(.C) void,
            .stencilMaskSeparate => *const fn (_face: GLenum, _mask: GLuint) callconv(.C) void,
            .attachShader => *const fn (_program: GLuint, _shader: GLuint) callconv(.C) void,
            .bindAttribLocation => *const fn (_program: GLuint, _index: GLuint, _name: [*c]const GLchar) callconv(.C) void,
            .compileShader => *const fn (_shader: GLuint) callconv(.C) void,
            .createProgram => *const fn () callconv(.C) GLuint,
            .createShader => *const fn (_type: GLenum) callconv(.C) GLuint,
            .deleteProgram => *const fn (_program: GLuint) callconv(.C) void,
            .deleteShader => *const fn (_shader: GLuint) callconv(.C) void,
            .detachShader => *const fn (_program: GLuint, _shader: GLuint) callconv(.C) void,
            .disableVertexAttribArray => *const fn (_index: GLuint) callconv(.C) void,
            .enableVertexAttribArray => *const fn (_index: GLuint) callconv(.C) void,
            .getActiveAttrib => *const fn (_program: GLuint, _index: GLuint, _bufSize: GLsizei, _length: [*c]GLsizei, _size: [*c]GLint, _type: [*c]GLenum, _name: [*c]GLchar) callconv(.C) void,
            .getActiveUniform => *const fn (_program: GLuint, _index: GLuint, _bufSize: GLsizei, _length: [*c]GLsizei, _size: [*c]GLint, _type: [*c]GLenum, _name: [*c]GLchar) callconv(.C) void,
            .getAttachedShaders => *const fn (_program: GLuint, _maxCount: GLsizei, _count: [*c]GLsizei, _shaders: [*c]GLuint) callconv(.C) void,
            .getAttribLocation => *const fn (_program: GLuint, _name: [*c]const GLchar) callconv(.C) GLint,
            .getProgramiv => *const fn (_program: GLuint, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .getProgramInfoLog => *const fn (_program: GLuint, _bufSize: GLsizei, _length: [*c]GLsizei, _infoLog: [*c]GLchar) callconv(.C) void,
            .getShaderiv => *const fn (_shader: GLuint, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .getShaderInfoLog => *const fn (_shader: GLuint, _bufSize: GLsizei, _length: [*c]GLsizei, _infoLog: [*c]GLchar) callconv(.C) void,
            .getShaderSource => *const fn (_shader: GLuint, _bufSize: GLsizei, _length: [*c]GLsizei, _source: [*c]GLchar) callconv(.C) void,
            .getUniformLocation => *const fn (_program: GLuint, _name: [*c]const GLchar) callconv(.C) GLint,
            .getUniformfv => *const fn (_program: GLuint, _location: GLint, _params: [*c]GLfloat) callconv(.C) void,
            .getUniformiv => *const fn (_program: GLuint, _location: GLint, _params: [*c]GLint) callconv(.C) void,
            .getVertexAttribdv => *const fn (_index: GLuint, _pname: GLenum, _params: [*c]GLdouble) callconv(.C) void,
            .getVertexAttribfv => *const fn (_index: GLuint, _pname: GLenum, _params: [*c]GLfloat) callconv(.C) void,
            .getVertexAttribiv => *const fn (_index: GLuint, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .getVertexAttribPointerv => *const fn (_index: GLuint, _pname: GLenum, _pointer: ?*?*anyopaque) callconv(.C) void,
            .isProgram => *const fn (_program: GLuint) callconv(.C) GLboolean,
            .isShader => *const fn (_shader: GLuint) callconv(.C) GLboolean,
            .linkProgram => *const fn (_program: GLuint) callconv(.C) void,
            .shaderSource => *const fn (_shader: GLuint, _count: GLsizei, _string: [*c]const [*c]const GLchar, _length: [*c]const GLint) callconv(.C) void,
            .useProgram => *const fn (_program: GLuint) callconv(.C) void,
            .uniform1f => *const fn (_location: GLint, _v0: GLfloat) callconv(.C) void,
            .uniform2f => *const fn (_location: GLint, _v0: GLfloat, _v1: GLfloat) callconv(.C) void,
            .uniform3f => *const fn (_location: GLint, _v0: GLfloat, _v1: GLfloat, _v2: GLfloat) callconv(.C) void,
            .uniform4f => *const fn (_location: GLint, _v0: GLfloat, _v1: GLfloat, _v2: GLfloat, _v3: GLfloat) callconv(.C) void,
            .uniform1i => *const fn (_location: GLint, _v0: GLint) callconv(.C) void,
            .uniform2i => *const fn (_location: GLint, _v0: GLint, _v1: GLint) callconv(.C) void,
            .uniform3i => *const fn (_location: GLint, _v0: GLint, _v1: GLint, _v2: GLint) callconv(.C) void,
            .uniform4i => *const fn (_location: GLint, _v0: GLint, _v1: GLint, _v2: GLint, _v3: GLint) callconv(.C) void,
            .uniform1fv => *const fn (_location: GLint, _count: GLsizei, _value: [*c]const GLfloat) callconv(.C) void,
            .uniform2fv => *const fn (_location: GLint, _count: GLsizei, _value: [*c]const GLfloat) callconv(.C) void,
            .uniform3fv => *const fn (_location: GLint, _count: GLsizei, _value: [*c]const GLfloat) callconv(.C) void,
            .uniform4fv => *const fn (_location: GLint, _count: GLsizei, _value: [*c]const GLfloat) callconv(.C) void,
            .uniform1iv => *const fn (_location: GLint, _count: GLsizei, _value: [*c]const GLint) callconv(.C) void,
            .uniform2iv => *const fn (_location: GLint, _count: GLsizei, _value: [*c]const GLint) callconv(.C) void,
            .uniform3iv => *const fn (_location: GLint, _count: GLsizei, _value: [*c]const GLint) callconv(.C) void,
            .uniform4iv => *const fn (_location: GLint, _count: GLsizei, _value: [*c]const GLint) callconv(.C) void,
            .uniformMatrix2fv => *const fn (_location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) callconv(.C) void,
            .uniformMatrix3fv => *const fn (_location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) callconv(.C) void,
            .uniformMatrix4fv => *const fn (_location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) callconv(.C) void,
            .validateProgram => *const fn (_program: GLuint) callconv(.C) void,
            .vertexAttrib1d => *const fn (_index: GLuint, _x: GLdouble) callconv(.C) void,
            .vertexAttrib1dv => *const fn (_index: GLuint, _v: [*c]const GLdouble) callconv(.C) void,
            .vertexAttrib1f => *const fn (_index: GLuint, _x: GLfloat) callconv(.C) void,
            .vertexAttrib1fv => *const fn (_index: GLuint, _v: [*c]const GLfloat) callconv(.C) void,
            .vertexAttrib1s => *const fn (_index: GLuint, _x: GLshort) callconv(.C) void,
            .vertexAttrib1sv => *const fn (_index: GLuint, _v: [*c]const GLshort) callconv(.C) void,
            .vertexAttrib2d => *const fn (_index: GLuint, _x: GLdouble, _y: GLdouble) callconv(.C) void,
            .vertexAttrib2dv => *const fn (_index: GLuint, _v: [*c]const GLdouble) callconv(.C) void,
            .vertexAttrib2f => *const fn (_index: GLuint, _x: GLfloat, _y: GLfloat) callconv(.C) void,
            .vertexAttrib2fv => *const fn (_index: GLuint, _v: [*c]const GLfloat) callconv(.C) void,
            .vertexAttrib2s => *const fn (_index: GLuint, _x: GLshort, _y: GLshort) callconv(.C) void,
            .vertexAttrib2sv => *const fn (_index: GLuint, _v: [*c]const GLshort) callconv(.C) void,
            .vertexAttrib3d => *const fn (_index: GLuint, _x: GLdouble, _y: GLdouble, _z: GLdouble) callconv(.C) void,
            .vertexAttrib3dv => *const fn (_index: GLuint, _v: [*c]const GLdouble) callconv(.C) void,
            .vertexAttrib3f => *const fn (_index: GLuint, _x: GLfloat, _y: GLfloat, _z: GLfloat) callconv(.C) void,
            .vertexAttrib3fv => *const fn (_index: GLuint, _v: [*c]const GLfloat) callconv(.C) void,
            .vertexAttrib3s => *const fn (_index: GLuint, _x: GLshort, _y: GLshort, _z: GLshort) callconv(.C) void,
            .vertexAttrib3sv => *const fn (_index: GLuint, _v: [*c]const GLshort) callconv(.C) void,
            .vertexAttrib4Nbv => *const fn (_index: GLuint, _v: [*c]const GLbyte) callconv(.C) void,
            .vertexAttrib4Niv => *const fn (_index: GLuint, _v: [*c]const GLint) callconv(.C) void,
            .vertexAttrib4Nsv => *const fn (_index: GLuint, _v: [*c]const GLshort) callconv(.C) void,
            .vertexAttrib4Nub => *const fn (_index: GLuint, _x: GLubyte, _y: GLubyte, _z: GLubyte, _w: GLubyte) callconv(.C) void,
            .vertexAttrib4Nubv => *const fn (_index: GLuint, _v: ?[*:0]const GLubyte) callconv(.C) void,
            .vertexAttrib4Nuiv => *const fn (_index: GLuint, _v: [*c]const GLuint) callconv(.C) void,
            .vertexAttrib4Nusv => *const fn (_index: GLuint, _v: [*c]const GLushort) callconv(.C) void,
            .vertexAttrib4bv => *const fn (_index: GLuint, _v: [*c]const GLbyte) callconv(.C) void,
            .vertexAttrib4d => *const fn (_index: GLuint, _x: GLdouble, _y: GLdouble, _z: GLdouble, _w: GLdouble) callconv(.C) void,
            .vertexAttrib4dv => *const fn (_index: GLuint, _v: [*c]const GLdouble) callconv(.C) void,
            .vertexAttrib4f => *const fn (_index: GLuint, _x: GLfloat, _y: GLfloat, _z: GLfloat, _w: GLfloat) callconv(.C) void,
            .vertexAttrib4fv => *const fn (_index: GLuint, _v: [*c]const GLfloat) callconv(.C) void,
            .vertexAttrib4iv => *const fn (_index: GLuint, _v: [*c]const GLint) callconv(.C) void,
            .vertexAttrib4s => *const fn (_index: GLuint, _x: GLshort, _y: GLshort, _z: GLshort, _w: GLshort) callconv(.C) void,
            .vertexAttrib4sv => *const fn (_index: GLuint, _v: [*c]const GLshort) callconv(.C) void,
            .vertexAttrib4ubv => *const fn (_index: GLuint, _v: ?[*:0]const GLubyte) callconv(.C) void,
            .vertexAttrib4uiv => *const fn (_index: GLuint, _v: [*c]const GLuint) callconv(.C) void,
            .vertexAttrib4usv => *const fn (_index: GLuint, _v: [*c]const GLushort) callconv(.C) void,
            .vertexAttribPointer => *const fn (_index: GLuint, _size: GLint, _type: GLenum, _normalized: GLboolean, _stride: GLsizei, _pointer: ?*const anyopaque) callconv(.C) void,
            .uniformMatrix2x3fv => *const fn (_location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) callconv(.C) void,
            .uniformMatrix3x2fv => *const fn (_location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) callconv(.C) void,
            .uniformMatrix2x4fv => *const fn (_location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) callconv(.C) void,
            .uniformMatrix4x2fv => *const fn (_location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) callconv(.C) void,
            .uniformMatrix3x4fv => *const fn (_location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) callconv(.C) void,
            .uniformMatrix4x3fv => *const fn (_location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) callconv(.C) void,
            .colorMaski => *const fn (_index: GLuint, _r: GLboolean, _g: GLboolean, _b: GLboolean, _a: GLboolean) callconv(.C) void,
            .getBooleani_v => *const fn (_target: GLenum, _index: GLuint, _data: [*c]GLboolean) callconv(.C) void,
            .getIntegeri_v => *const fn (_target: GLenum, _index: GLuint, _data: [*c]GLint) callconv(.C) void,
            .enablei => *const fn (_target: GLenum, _index: GLuint) callconv(.C) void,
            .disablei => *const fn (_target: GLenum, _index: GLuint) callconv(.C) void,
            .isEnabledi => *const fn (_target: GLenum, _index: GLuint) callconv(.C) GLboolean,
            .beginTransformFeedback => *const fn (_primitiveMode: GLenum) callconv(.C) void,
            .endTransformFeedback => *const fn () callconv(.C) void,
            .bindBufferRange => *const fn (_target: GLenum, _index: GLuint, _buffer: GLuint, _offset: GLintptr, _size: GLsizeiptr) callconv(.C) void,
            .bindBufferBase => *const fn (_target: GLenum, _index: GLuint, _buffer: GLuint) callconv(.C) void,
            .transformFeedbackVaryings => *const fn (_program: GLuint, _count: GLsizei, _varyings: [*c]const [*c]const GLchar, _bufferMode: GLenum) callconv(.C) void,
            .getTransformFeedbackVarying => *const fn (_program: GLuint, _index: GLuint, _bufSize: GLsizei, _length: [*c]GLsizei, _size: [*c]GLsizei, _type: [*c]GLenum, _name: [*c]GLchar) callconv(.C) void,
            .clampColor => *const fn (_target: GLenum, _clamp: GLenum) callconv(.C) void,
            .beginConditionalRender => *const fn (_id: GLuint, _mode: GLenum) callconv(.C) void,
            .endConditionalRender => *const fn () callconv(.C) void,
            .vertexAttribIPointer => *const fn (_index: GLuint, _size: GLint, _type: GLenum, _stride: GLsizei, _pointer: ?*const anyopaque) callconv(.C) void,
            .getVertexAttribIiv => *const fn (_index: GLuint, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .getVertexAttribIuiv => *const fn (_index: GLuint, _pname: GLenum, _params: [*c]GLuint) callconv(.C) void,
            .vertexAttribI1i => *const fn (_index: GLuint, _x: GLint) callconv(.C) void,
            .vertexAttribI2i => *const fn (_index: GLuint, _x: GLint, _y: GLint) callconv(.C) void,
            .vertexAttribI3i => *const fn (_index: GLuint, _x: GLint, _y: GLint, _z: GLint) callconv(.C) void,
            .vertexAttribI4i => *const fn (_index: GLuint, _x: GLint, _y: GLint, _z: GLint, _w: GLint) callconv(.C) void,
            .vertexAttribI1ui => *const fn (_index: GLuint, _x: GLuint) callconv(.C) void,
            .vertexAttribI2ui => *const fn (_index: GLuint, _x: GLuint, _y: GLuint) callconv(.C) void,
            .vertexAttribI3ui => *const fn (_index: GLuint, _x: GLuint, _y: GLuint, _z: GLuint) callconv(.C) void,
            .vertexAttribI4ui => *const fn (_index: GLuint, _x: GLuint, _y: GLuint, _z: GLuint, _w: GLuint) callconv(.C) void,
            .vertexAttribI1iv => *const fn (_index: GLuint, _v: [*c]const GLint) callconv(.C) void,
            .vertexAttribI2iv => *const fn (_index: GLuint, _v: [*c]const GLint) callconv(.C) void,
            .vertexAttribI3iv => *const fn (_index: GLuint, _v: [*c]const GLint) callconv(.C) void,
            .vertexAttribI4iv => *const fn (_index: GLuint, _v: [*c]const GLint) callconv(.C) void,
            .vertexAttribI1uiv => *const fn (_index: GLuint, _v: [*c]const GLuint) callconv(.C) void,
            .vertexAttribI2uiv => *const fn (_index: GLuint, _v: [*c]const GLuint) callconv(.C) void,
            .vertexAttribI3uiv => *const fn (_index: GLuint, _v: [*c]const GLuint) callconv(.C) void,
            .vertexAttribI4uiv => *const fn (_index: GLuint, _v: [*c]const GLuint) callconv(.C) void,
            .vertexAttribI4bv => *const fn (_index: GLuint, _v: [*c]const GLbyte) callconv(.C) void,
            .vertexAttribI4sv => *const fn (_index: GLuint, _v: [*c]const GLshort) callconv(.C) void,
            .vertexAttribI4ubv => *const fn (_index: GLuint, _v: ?[*:0]const GLubyte) callconv(.C) void,
            .vertexAttribI4usv => *const fn (_index: GLuint, _v: [*c]const GLushort) callconv(.C) void,
            .getUniformuiv => *const fn (_program: GLuint, _location: GLint, _params: [*c]GLuint) callconv(.C) void,
            .bindFragDataLocation => *const fn (_program: GLuint, _color: GLuint, _name: [*c]const GLchar) callconv(.C) void,
            .getFragDataLocation => *const fn (_program: GLuint, _name: [*c]const GLchar) callconv(.C) GLint,
            .uniform1ui => *const fn (_location: GLint, _v0: GLuint) callconv(.C) void,
            .uniform2ui => *const fn (_location: GLint, _v0: GLuint, _v1: GLuint) callconv(.C) void,
            .uniform3ui => *const fn (_location: GLint, _v0: GLuint, _v1: GLuint, _v2: GLuint) callconv(.C) void,
            .uniform4ui => *const fn (_location: GLint, _v0: GLuint, _v1: GLuint, _v2: GLuint, _v3: GLuint) callconv(.C) void,
            .uniform1uiv => *const fn (_location: GLint, _count: GLsizei, _value: [*c]const GLuint) callconv(.C) void,
            .uniform2uiv => *const fn (_location: GLint, _count: GLsizei, _value: [*c]const GLuint) callconv(.C) void,
            .uniform3uiv => *const fn (_location: GLint, _count: GLsizei, _value: [*c]const GLuint) callconv(.C) void,
            .uniform4uiv => *const fn (_location: GLint, _count: GLsizei, _value: [*c]const GLuint) callconv(.C) void,
            .texParameterIiv => *const fn (_target: GLenum, _pname: GLenum, _params: [*c]const GLint) callconv(.C) void,
            .texParameterIuiv => *const fn (_target: GLenum, _pname: GLenum, _params: [*c]const GLuint) callconv(.C) void,
            .getTexParameterIiv => *const fn (_target: GLenum, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .getTexParameterIuiv => *const fn (_target: GLenum, _pname: GLenum, _params: [*c]GLuint) callconv(.C) void,
            .clearBufferiv => *const fn (_buffer: GLenum, _drawbuffer: GLint, _value: [*c]const GLint) callconv(.C) void,
            .clearBufferuiv => *const fn (_buffer: GLenum, _drawbuffer: GLint, _value: [*c]const GLuint) callconv(.C) void,
            .clearBufferfv => *const fn (_buffer: GLenum, _drawbuffer: GLint, _value: [*c]const GLfloat) callconv(.C) void,
            .clearBufferfi => *const fn (_buffer: GLenum, _drawbuffer: GLint, _depth: GLfloat, _stencil: GLint) callconv(.C) void,
            .getStringi => *const fn (_name: GLenum, _index: GLuint) callconv(.C) ?[*:0]const GLubyte,
            .isRenderbuffer => *const fn (_renderbuffer: GLuint) callconv(.C) GLboolean,
            .bindRenderbuffer => *const fn (_target: GLenum, _renderbuffer: GLuint) callconv(.C) void,
            .deleteRenderbuffers => *const fn (_n: GLsizei, _renderbuffers: [*c]const GLuint) callconv(.C) void,
            .genRenderbuffers => *const fn (_n: GLsizei, _renderbuffers: [*c]GLuint) callconv(.C) void,
            .renderbufferStorage => *const fn (_target: GLenum, _internalformat: GLenum, _width: GLsizei, _height: GLsizei) callconv(.C) void,
            .getRenderbufferParameteriv => *const fn (_target: GLenum, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .isFramebuffer => *const fn (_framebuffer: GLuint) callconv(.C) GLboolean,
            .bindFramebuffer => *const fn (_target: GLenum, _framebuffer: GLuint) callconv(.C) void,
            .deleteFramebuffers => *const fn (_n: GLsizei, _framebuffers: [*c]const GLuint) callconv(.C) void,
            .genFramebuffers => *const fn (_n: GLsizei, _framebuffers: [*c]GLuint) callconv(.C) void,
            .checkFramebufferStatus => *const fn (_target: GLenum) callconv(.C) GLenum,
            .framebufferTexture1D => *const fn (_target: GLenum, _attachment: GLenum, _textarget: GLenum, _texture: GLuint, _level: GLint) callconv(.C) void,
            .framebufferTexture2D => *const fn (_target: GLenum, _attachment: GLenum, _textarget: GLenum, _texture: GLuint, _level: GLint) callconv(.C) void,
            .framebufferTexture3D => *const fn (_target: GLenum, _attachment: GLenum, _textarget: GLenum, _texture: GLuint, _level: GLint, _zoffset: GLint) callconv(.C) void,
            .framebufferRenderbuffer => *const fn (_target: GLenum, _attachment: GLenum, _renderbuffertarget: GLenum, _renderbuffer: GLuint) callconv(.C) void,
            .getFramebufferAttachmentParameteriv => *const fn (_target: GLenum, _attachment: GLenum, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .generateMipmap => *const fn (_target: GLenum) callconv(.C) void,
            .blitFramebuffer => *const fn (_srcX0: GLint, _srcY0: GLint, _srcX1: GLint, _srcY1: GLint, _dstX0: GLint, _dstY0: GLint, _dstX1: GLint, _dstY1: GLint, _mask: GLbitfield, _filter: GLenum) callconv(.C) void,
            .renderbufferStorageMultisample => *const fn (_target: GLenum, _samples: GLsizei, _internalformat: GLenum, _width: GLsizei, _height: GLsizei) callconv(.C) void,
            .framebufferTextureLayer => *const fn (_target: GLenum, _attachment: GLenum, _texture: GLuint, _level: GLint, _layer: GLint) callconv(.C) void,
            .mapBufferRange => *const fn (_target: GLenum, _offset: GLintptr, _length: GLsizeiptr, _access: GLbitfield) callconv(.C) ?*anyopaque,
            .flushMappedBufferRange => *const fn (_target: GLenum, _offset: GLintptr, _length: GLsizeiptr) callconv(.C) void,
            .bindVertexArray => *const fn (_array: GLuint) callconv(.C) void,
            .deleteVertexArrays => *const fn (_n: GLsizei, _arrays: [*c]const GLuint) callconv(.C) void,
            .genVertexArrays => *const fn (_n: GLsizei, _arrays: [*c]GLuint) callconv(.C) void,
            .isVertexArray => *const fn (_array: GLuint) callconv(.C) GLboolean,
            .drawArraysInstanced => *const fn (_mode: GLenum, _first: GLint, _count: GLsizei, _instancecount: GLsizei) callconv(.C) void,
            .drawElementsInstanced => *const fn (_mode: GLenum, _count: GLsizei, _type: GLenum, _indices: ?*const anyopaque, _instancecount: GLsizei) callconv(.C) void,
            .texBuffer => *const fn (_target: GLenum, _internalformat: GLenum, _buffer: GLuint) callconv(.C) void,
            .primitiveRestartIndex => *const fn (_index: GLuint) callconv(.C) void,
            .copyBufferSubData => *const fn (_readTarget: GLenum, _writeTarget: GLenum, _readOffset: GLintptr, _writeOffset: GLintptr, _size: GLsizeiptr) callconv(.C) void,
            .getUniformIndices => *const fn (_program: GLuint, _uniformCount: GLsizei, _uniformNames: [*c]const [*c]const GLchar, _uniformIndices: [*c]GLuint) callconv(.C) void,
            .getActiveUniformsiv => *const fn (_program: GLuint, _uniformCount: GLsizei, _uniformIndices: [*c]const GLuint, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .getActiveUniformName => *const fn (_program: GLuint, _uniformIndex: GLuint, _bufSize: GLsizei, _length: [*c]GLsizei, _uniformName: [*c]GLchar) callconv(.C) void,
            .getUniformBlockIndex => *const fn (_program: GLuint, _uniformBlockName: [*c]const GLchar) callconv(.C) GLuint,
            .getActiveUniformBlockiv => *const fn (_program: GLuint, _uniformBlockIndex: GLuint, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .getActiveUniformBlockName => *const fn (_program: GLuint, _uniformBlockIndex: GLuint, _bufSize: GLsizei, _length: [*c]GLsizei, _uniformBlockName: [*c]GLchar) callconv(.C) void,
            .uniformBlockBinding => *const fn (_program: GLuint, _uniformBlockIndex: GLuint, _uniformBlockBinding: GLuint) callconv(.C) void,
            .drawElementsBaseVertex => *const fn (_mode: GLenum, _count: GLsizei, _type: GLenum, _indices: ?*const anyopaque, _basevertex: GLint) callconv(.C) void,
            .drawRangeElementsBaseVertex => *const fn (_mode: GLenum, _start: GLuint, _end: GLuint, _count: GLsizei, _type: GLenum, _indices: ?*const anyopaque, _basevertex: GLint) callconv(.C) void,
            .drawElementsInstancedBaseVertex => *const fn (_mode: GLenum, _count: GLsizei, _type: GLenum, _indices: ?*const anyopaque, _instancecount: GLsizei, _basevertex: GLint) callconv(.C) void,
            .multiDrawElementsBaseVertex => *const fn (_mode: GLenum, _count: [*c]const GLsizei, _type: GLenum, _indices: [*c]const ?*const anyopaque, _drawcount: GLsizei, _basevertex: [*c]const GLint) callconv(.C) void,
            .provokingVertex => *const fn (_mode: GLenum) callconv(.C) void,
            .fenceSync => *const fn (_condition: GLenum, _flags: GLbitfield) callconv(.C) GLsync,
            .isSync => *const fn (_sync: GLsync) callconv(.C) GLboolean,
            .deleteSync => *const fn (_sync: GLsync) callconv(.C) void,
            .clientWaitSync => *const fn (_sync: GLsync, _flags: GLbitfield, _timeout: GLuint64) callconv(.C) GLenum,
            .waitSync => *const fn (_sync: GLsync, _flags: GLbitfield, _timeout: GLuint64) callconv(.C) void,
            .getInteger64v => *const fn (_pname: GLenum, _data: [*c]GLint64) callconv(.C) void,
            .getSynciv => *const fn (_sync: GLsync, _pname: GLenum, _count: GLsizei, _length: [*c]GLsizei, _values: [*c]GLint) callconv(.C) void,
            .getInteger64i_v => *const fn (_target: GLenum, _index: GLuint, _data: [*c]GLint64) callconv(.C) void,
            .getBufferParameteri64v => *const fn (_target: GLenum, _pname: GLenum, _params: [*c]GLint64) callconv(.C) void,
            .framebufferTexture => *const fn (_target: GLenum, _attachment: GLenum, _texture: GLuint, _level: GLint) callconv(.C) void,
            .texImage2DMultisample => *const fn (_target: GLenum, _samples: GLsizei, _internalformat: GLenum, _width: GLsizei, _height: GLsizei, _fixedsamplelocations: GLboolean) callconv(.C) void,
            .texImage3DMultisample => *const fn (_target: GLenum, _samples: GLsizei, _internalformat: GLenum, _width: GLsizei, _height: GLsizei, _depth: GLsizei, _fixedsamplelocations: GLboolean) callconv(.C) void,
            .getMultisamplefv => *const fn (_pname: GLenum, _index: GLuint, _val: [*c]GLfloat) callconv(.C) void,
            .sampleMaski => *const fn (_maskNumber: GLuint, _mask: GLbitfield) callconv(.C) void,
            .bindFragDataLocationIndexed => *const fn (_program: GLuint, _colorNumber: GLuint, _index: GLuint, _name: [*c]const GLchar) callconv(.C) void,
            .getFragDataIndex => *const fn (_program: GLuint, _name: [*c]const GLchar) callconv(.C) GLint,
            .genSamplers => *const fn (_count: GLsizei, _samplers: [*c]GLuint) callconv(.C) void,
            .deleteSamplers => *const fn (_count: GLsizei, _samplers: [*c]const GLuint) callconv(.C) void,
            .isSampler => *const fn (_sampler: GLuint) callconv(.C) GLboolean,
            .bindSampler => *const fn (_unit: GLuint, _sampler: GLuint) callconv(.C) void,
            .samplerParameteri => *const fn (_sampler: GLuint, _pname: GLenum, _param: GLint) callconv(.C) void,
            .samplerParameteriv => *const fn (_sampler: GLuint, _pname: GLenum, _param: [*c]const GLint) callconv(.C) void,
            .samplerParameterf => *const fn (_sampler: GLuint, _pname: GLenum, _param: GLfloat) callconv(.C) void,
            .samplerParameterfv => *const fn (_sampler: GLuint, _pname: GLenum, _param: [*c]const GLfloat) callconv(.C) void,
            .samplerParameterIiv => *const fn (_sampler: GLuint, _pname: GLenum, _param: [*c]const GLint) callconv(.C) void,
            .samplerParameterIuiv => *const fn (_sampler: GLuint, _pname: GLenum, _param: [*c]const GLuint) callconv(.C) void,
            .getSamplerParameteriv => *const fn (_sampler: GLuint, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .getSamplerParameterIiv => *const fn (_sampler: GLuint, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .getSamplerParameterfv => *const fn (_sampler: GLuint, _pname: GLenum, _params: [*c]GLfloat) callconv(.C) void,
            .getSamplerParameterIuiv => *const fn (_sampler: GLuint, _pname: GLenum, _params: [*c]GLuint) callconv(.C) void,
            .queryCounter => *const fn (_id: GLuint, _target: GLenum) callconv(.C) void,
            .getQueryObjecti64v => *const fn (_id: GLuint, _pname: GLenum, _params: [*c]GLint64) callconv(.C) void,
            .getQueryObjectui64v => *const fn (_id: GLuint, _pname: GLenum, _params: [*c]GLuint64) callconv(.C) void,
            .vertexAttribDivisor => *const fn (_index: GLuint, _divisor: GLuint) callconv(.C) void,
            .vertexAttribP1ui => *const fn (_index: GLuint, _type: GLenum, _normalized: GLboolean, _value: GLuint) callconv(.C) void,
            .vertexAttribP1uiv => *const fn (_index: GLuint, _type: GLenum, _normalized: GLboolean, _value: [*c]const GLuint) callconv(.C) void,
            .vertexAttribP2ui => *const fn (_index: GLuint, _type: GLenum, _normalized: GLboolean, _value: GLuint) callconv(.C) void,
            .vertexAttribP2uiv => *const fn (_index: GLuint, _type: GLenum, _normalized: GLboolean, _value: [*c]const GLuint) callconv(.C) void,
            .vertexAttribP3ui => *const fn (_index: GLuint, _type: GLenum, _normalized: GLboolean, _value: GLuint) callconv(.C) void,
            .vertexAttribP3uiv => *const fn (_index: GLuint, _type: GLenum, _normalized: GLboolean, _value: [*c]const GLuint) callconv(.C) void,
            .vertexAttribP4ui => *const fn (_index: GLuint, _type: GLenum, _normalized: GLboolean, _value: GLuint) callconv(.C) void,
            .vertexAttribP4uiv => *const fn (_index: GLuint, _type: GLenum, _normalized: GLboolean, _value: [*c]const GLuint) callconv(.C) void,
            .vertexP2ui => *const fn (_type: GLenum, _value: GLuint) callconv(.C) void,
            .vertexP2uiv => *const fn (_type: GLenum, _value: [*c]const GLuint) callconv(.C) void,
            .vertexP3ui => *const fn (_type: GLenum, _value: GLuint) callconv(.C) void,
            .vertexP3uiv => *const fn (_type: GLenum, _value: [*c]const GLuint) callconv(.C) void,
            .vertexP4ui => *const fn (_type: GLenum, _value: GLuint) callconv(.C) void,
            .vertexP4uiv => *const fn (_type: GLenum, _value: [*c]const GLuint) callconv(.C) void,
            .texCoordP1ui => *const fn (_type: GLenum, _coords: GLuint) callconv(.C) void,
            .texCoordP1uiv => *const fn (_type: GLenum, _coords: [*c]const GLuint) callconv(.C) void,
            .texCoordP2ui => *const fn (_type: GLenum, _coords: GLuint) callconv(.C) void,
            .texCoordP2uiv => *const fn (_type: GLenum, _coords: [*c]const GLuint) callconv(.C) void,
            .texCoordP3ui => *const fn (_type: GLenum, _coords: GLuint) callconv(.C) void,
            .texCoordP3uiv => *const fn (_type: GLenum, _coords: [*c]const GLuint) callconv(.C) void,
            .texCoordP4ui => *const fn (_type: GLenum, _coords: GLuint) callconv(.C) void,
            .texCoordP4uiv => *const fn (_type: GLenum, _coords: [*c]const GLuint) callconv(.C) void,
            .multiTexCoordP1ui => *const fn (_texture: GLenum, _type: GLenum, _coords: GLuint) callconv(.C) void,
            .multiTexCoordP1uiv => *const fn (_texture: GLenum, _type: GLenum, _coords: [*c]const GLuint) callconv(.C) void,
            .multiTexCoordP2ui => *const fn (_texture: GLenum, _type: GLenum, _coords: GLuint) callconv(.C) void,
            .multiTexCoordP2uiv => *const fn (_texture: GLenum, _type: GLenum, _coords: [*c]const GLuint) callconv(.C) void,
            .multiTexCoordP3ui => *const fn (_texture: GLenum, _type: GLenum, _coords: GLuint) callconv(.C) void,
            .multiTexCoordP3uiv => *const fn (_texture: GLenum, _type: GLenum, _coords: [*c]const GLuint) callconv(.C) void,
            .multiTexCoordP4ui => *const fn (_texture: GLenum, _type: GLenum, _coords: GLuint) callconv(.C) void,
            .multiTexCoordP4uiv => *const fn (_texture: GLenum, _type: GLenum, _coords: [*c]const GLuint) callconv(.C) void,
            .normalP3ui => *const fn (_type: GLenum, _coords: GLuint) callconv(.C) void,
            .normalP3uiv => *const fn (_type: GLenum, _coords: [*c]const GLuint) callconv(.C) void,
            .colorP3ui => *const fn (_type: GLenum, _color: GLuint) callconv(.C) void,
            .colorP3uiv => *const fn (_type: GLenum, _color: [*c]const GLuint) callconv(.C) void,
            .colorP4ui => *const fn (_type: GLenum, _color: GLuint) callconv(.C) void,
            .colorP4uiv => *const fn (_type: GLenum, _color: [*c]const GLuint) callconv(.C) void,
            .secondaryColorP3ui => *const fn (_type: GLenum, _color: GLuint) callconv(.C) void,
            .secondaryColorP3uiv => *const fn (_type: GLenum, _color: [*c]const GLuint) callconv(.C) void,
            .minSampleShading => *const fn (_value: GLfloat) callconv(.C) void,
            .blendEquationi => *const fn (_buf: GLuint, _mode: GLenum) callconv(.C) void,
            .blendEquationSeparatei => *const fn (_buf: GLuint, _modeRGB: GLenum, _modeAlpha: GLenum) callconv(.C) void,
            .blendFunci => *const fn (_buf: GLuint, _src: GLenum, _dst: GLenum) callconv(.C) void,
            .blendFuncSeparatei => *const fn (_buf: GLuint, _srcRGB: GLenum, _dstRGB: GLenum, _srcAlpha: GLenum, _dstAlpha: GLenum) callconv(.C) void,
            .drawArraysIndirect => *const fn (_mode: GLenum, _indirect: ?*const anyopaque) callconv(.C) void,
            .drawElementsIndirect => *const fn (_mode: GLenum, _type: GLenum, _indirect: ?*const anyopaque) callconv(.C) void,
            .uniform1d => *const fn (_location: GLint, _x: GLdouble) callconv(.C) void,
            .uniform2d => *const fn (_location: GLint, _x: GLdouble, _y: GLdouble) callconv(.C) void,
            .uniform3d => *const fn (_location: GLint, _x: GLdouble, _y: GLdouble, _z: GLdouble) callconv(.C) void,
            .uniform4d => *const fn (_location: GLint, _x: GLdouble, _y: GLdouble, _z: GLdouble, _w: GLdouble) callconv(.C) void,
            .uniform1dv => *const fn (_location: GLint, _count: GLsizei, _value: [*c]const GLdouble) callconv(.C) void,
            .uniform2dv => *const fn (_location: GLint, _count: GLsizei, _value: [*c]const GLdouble) callconv(.C) void,
            .uniform3dv => *const fn (_location: GLint, _count: GLsizei, _value: [*c]const GLdouble) callconv(.C) void,
            .uniform4dv => *const fn (_location: GLint, _count: GLsizei, _value: [*c]const GLdouble) callconv(.C) void,
            .uniformMatrix2dv => *const fn (_location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) callconv(.C) void,
            .uniformMatrix3dv => *const fn (_location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) callconv(.C) void,
            .uniformMatrix4dv => *const fn (_location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) callconv(.C) void,
            .uniformMatrix2x3dv => *const fn (_location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) callconv(.C) void,
            .uniformMatrix2x4dv => *const fn (_location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) callconv(.C) void,
            .uniformMatrix3x2dv => *const fn (_location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) callconv(.C) void,
            .uniformMatrix3x4dv => *const fn (_location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) callconv(.C) void,
            .uniformMatrix4x2dv => *const fn (_location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) callconv(.C) void,
            .uniformMatrix4x3dv => *const fn (_location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) callconv(.C) void,
            .getUniformdv => *const fn (_program: GLuint, _location: GLint, _params: [*c]GLdouble) callconv(.C) void,
            .getSubroutineUniformLocation => *const fn (_program: GLuint, _shadertype: GLenum, _name: [*c]const GLchar) callconv(.C) GLint,
            .getSubroutineIndex => *const fn (_program: GLuint, _shadertype: GLenum, _name: [*c]const GLchar) callconv(.C) GLuint,
            .getActiveSubroutineUniformiv => *const fn (_program: GLuint, _shadertype: GLenum, _index: GLuint, _pname: GLenum, _values: [*c]GLint) callconv(.C) void,
            .getActiveSubroutineUniformName => *const fn (_program: GLuint, _shadertype: GLenum, _index: GLuint, _bufSize: GLsizei, _length: [*c]GLsizei, _name: [*c]GLchar) callconv(.C) void,
            .getActiveSubroutineName => *const fn (_program: GLuint, _shadertype: GLenum, _index: GLuint, _bufSize: GLsizei, _length: [*c]GLsizei, _name: [*c]GLchar) callconv(.C) void,
            .uniformSubroutinesuiv => *const fn (_shadertype: GLenum, _count: GLsizei, _indices: [*c]const GLuint) callconv(.C) void,
            .getUniformSubroutineuiv => *const fn (_shadertype: GLenum, _location: GLint, _params: [*c]GLuint) callconv(.C) void,
            .getProgramStageiv => *const fn (_program: GLuint, _shadertype: GLenum, _pname: GLenum, _values: [*c]GLint) callconv(.C) void,
            .patchParameteri => *const fn (_pname: GLenum, _value: GLint) callconv(.C) void,
            .patchParameterfv => *const fn (_pname: GLenum, _values: [*c]const GLfloat) callconv(.C) void,
            .bindTransformFeedback => *const fn (_target: GLenum, _id: GLuint) callconv(.C) void,
            .deleteTransformFeedbacks => *const fn (_n: GLsizei, _ids: [*c]const GLuint) callconv(.C) void,
            .genTransformFeedbacks => *const fn (_n: GLsizei, _ids: [*c]GLuint) callconv(.C) void,
            .isTransformFeedback => *const fn (_id: GLuint) callconv(.C) GLboolean,
            .pauseTransformFeedback => *const fn () callconv(.C) void,
            .resumeTransformFeedback => *const fn () callconv(.C) void,
            .drawTransformFeedback => *const fn (_mode: GLenum, _id: GLuint) callconv(.C) void,
            .drawTransformFeedbackStream => *const fn (_mode: GLenum, _id: GLuint, _stream: GLuint) callconv(.C) void,
            .beginQueryIndexed => *const fn (_target: GLenum, _index: GLuint, _id: GLuint) callconv(.C) void,
            .endQueryIndexed => *const fn (_target: GLenum, _index: GLuint) callconv(.C) void,
            .getQueryIndexediv => *const fn (_target: GLenum, _index: GLuint, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .releaseShaderCompiler => *const fn () callconv(.C) void,
            .shaderBinary => *const fn (_count: GLsizei, _shaders: [*c]const GLuint, _binaryFormat: GLenum, _binary: ?*const anyopaque, _length: GLsizei) callconv(.C) void,
            .getShaderPrecisionFormat => *const fn (_shadertype: GLenum, _precisiontype: GLenum, _range: [*c]GLint, _precision: [*c]GLint) callconv(.C) void,
            .depthRangef => *const fn (_n: GLfloat, _f: GLfloat) callconv(.C) void,
            .clearDepthf => *const fn (_d: GLfloat) callconv(.C) void,
            .getProgramBinary => *const fn (_program: GLuint, _bufSize: GLsizei, _length: [*c]GLsizei, _binaryFormat: [*c]GLenum, _binary: ?*anyopaque) callconv(.C) void,
            .programBinary => *const fn (_program: GLuint, _binaryFormat: GLenum, _binary: ?*const anyopaque, _length: GLsizei) callconv(.C) void,
            .programParameteri => *const fn (_program: GLuint, _pname: GLenum, _value: GLint) callconv(.C) void,
            .useProgramStages => *const fn (_pipeline: GLuint, _stages: GLbitfield, _program: GLuint) callconv(.C) void,
            .activeShaderProgram => *const fn (_pipeline: GLuint, _program: GLuint) callconv(.C) void,
            .createShaderProgramv => *const fn (_type: GLenum, _count: GLsizei, _strings: [*c]const [*c]const GLchar) callconv(.C) GLuint,
            .bindProgramPipeline => *const fn (_pipeline: GLuint) callconv(.C) void,
            .deleteProgramPipelines => *const fn (_n: GLsizei, _pipelines: [*c]const GLuint) callconv(.C) void,
            .genProgramPipelines => *const fn (_n: GLsizei, _pipelines: [*c]GLuint) callconv(.C) void,
            .isProgramPipeline => *const fn (_pipeline: GLuint) callconv(.C) GLboolean,
            .getProgramPipelineiv => *const fn (_pipeline: GLuint, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .programUniform1i => *const fn (_program: GLuint, _location: GLint, _v0: GLint) callconv(.C) void,
            .programUniform1iv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLint) callconv(.C) void,
            .programUniform1f => *const fn (_program: GLuint, _location: GLint, _v0: GLfloat) callconv(.C) void,
            .programUniform1fv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLfloat) callconv(.C) void,
            .programUniform1d => *const fn (_program: GLuint, _location: GLint, _v0: GLdouble) callconv(.C) void,
            .programUniform1dv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLdouble) callconv(.C) void,
            .programUniform1ui => *const fn (_program: GLuint, _location: GLint, _v0: GLuint) callconv(.C) void,
            .programUniform1uiv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLuint) callconv(.C) void,
            .programUniform2i => *const fn (_program: GLuint, _location: GLint, _v0: GLint, _v1: GLint) callconv(.C) void,
            .programUniform2iv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLint) callconv(.C) void,
            .programUniform2f => *const fn (_program: GLuint, _location: GLint, _v0: GLfloat, _v1: GLfloat) callconv(.C) void,
            .programUniform2fv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLfloat) callconv(.C) void,
            .programUniform2d => *const fn (_program: GLuint, _location: GLint, _v0: GLdouble, _v1: GLdouble) callconv(.C) void,
            .programUniform2dv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLdouble) callconv(.C) void,
            .programUniform2ui => *const fn (_program: GLuint, _location: GLint, _v0: GLuint, _v1: GLuint) callconv(.C) void,
            .programUniform2uiv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLuint) callconv(.C) void,
            .programUniform3i => *const fn (_program: GLuint, _location: GLint, _v0: GLint, _v1: GLint, _v2: GLint) callconv(.C) void,
            .programUniform3iv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLint) callconv(.C) void,
            .programUniform3f => *const fn (_program: GLuint, _location: GLint, _v0: GLfloat, _v1: GLfloat, _v2: GLfloat) callconv(.C) void,
            .programUniform3fv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLfloat) callconv(.C) void,
            .programUniform3d => *const fn (_program: GLuint, _location: GLint, _v0: GLdouble, _v1: GLdouble, _v2: GLdouble) callconv(.C) void,
            .programUniform3dv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLdouble) callconv(.C) void,
            .programUniform3ui => *const fn (_program: GLuint, _location: GLint, _v0: GLuint, _v1: GLuint, _v2: GLuint) callconv(.C) void,
            .programUniform3uiv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLuint) callconv(.C) void,
            .programUniform4i => *const fn (_program: GLuint, _location: GLint, _v0: GLint, _v1: GLint, _v2: GLint, _v3: GLint) callconv(.C) void,
            .programUniform4iv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLint) callconv(.C) void,
            .programUniform4f => *const fn (_program: GLuint, _location: GLint, _v0: GLfloat, _v1: GLfloat, _v2: GLfloat, _v3: GLfloat) callconv(.C) void,
            .programUniform4fv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLfloat) callconv(.C) void,
            .programUniform4d => *const fn (_program: GLuint, _location: GLint, _v0: GLdouble, _v1: GLdouble, _v2: GLdouble, _v3: GLdouble) callconv(.C) void,
            .programUniform4dv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLdouble) callconv(.C) void,
            .programUniform4ui => *const fn (_program: GLuint, _location: GLint, _v0: GLuint, _v1: GLuint, _v2: GLuint, _v3: GLuint) callconv(.C) void,
            .programUniform4uiv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLuint) callconv(.C) void,
            .programUniformMatrix2fv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) callconv(.C) void,
            .programUniformMatrix3fv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) callconv(.C) void,
            .programUniformMatrix4fv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) callconv(.C) void,
            .programUniformMatrix2dv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) callconv(.C) void,
            .programUniformMatrix3dv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) callconv(.C) void,
            .programUniformMatrix4dv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) callconv(.C) void,
            .programUniformMatrix2x3fv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) callconv(.C) void,
            .programUniformMatrix3x2fv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) callconv(.C) void,
            .programUniformMatrix2x4fv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) callconv(.C) void,
            .programUniformMatrix4x2fv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) callconv(.C) void,
            .programUniformMatrix3x4fv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) callconv(.C) void,
            .programUniformMatrix4x3fv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) callconv(.C) void,
            .programUniformMatrix2x3dv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) callconv(.C) void,
            .programUniformMatrix3x2dv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) callconv(.C) void,
            .programUniformMatrix2x4dv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) callconv(.C) void,
            .programUniformMatrix4x2dv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) callconv(.C) void,
            .programUniformMatrix3x4dv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) callconv(.C) void,
            .programUniformMatrix4x3dv => *const fn (_program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) callconv(.C) void,
            .validateProgramPipeline => *const fn (_pipeline: GLuint) callconv(.C) void,
            .getProgramPipelineInfoLog => *const fn (_pipeline: GLuint, _bufSize: GLsizei, _length: [*c]GLsizei, _infoLog: [*c]GLchar) callconv(.C) void,
            .vertexAttribL1d => *const fn (_index: GLuint, _x: GLdouble) callconv(.C) void,
            .vertexAttribL2d => *const fn (_index: GLuint, _x: GLdouble, _y: GLdouble) callconv(.C) void,
            .vertexAttribL3d => *const fn (_index: GLuint, _x: GLdouble, _y: GLdouble, _z: GLdouble) callconv(.C) void,
            .vertexAttribL4d => *const fn (_index: GLuint, _x: GLdouble, _y: GLdouble, _z: GLdouble, _w: GLdouble) callconv(.C) void,
            .vertexAttribL1dv => *const fn (_index: GLuint, _v: [*c]const GLdouble) callconv(.C) void,
            .vertexAttribL2dv => *const fn (_index: GLuint, _v: [*c]const GLdouble) callconv(.C) void,
            .vertexAttribL3dv => *const fn (_index: GLuint, _v: [*c]const GLdouble) callconv(.C) void,
            .vertexAttribL4dv => *const fn (_index: GLuint, _v: [*c]const GLdouble) callconv(.C) void,
            .vertexAttribLPointer => *const fn (_index: GLuint, _size: GLint, _type: GLenum, _stride: GLsizei, _pointer: ?*const anyopaque) callconv(.C) void,
            .getVertexAttribLdv => *const fn (_index: GLuint, _pname: GLenum, _params: [*c]GLdouble) callconv(.C) void,
            .viewportArrayv => *const fn (_first: GLuint, _count: GLsizei, _v: [*c]const GLfloat) callconv(.C) void,
            .viewportIndexedf => *const fn (_index: GLuint, _x: GLfloat, _y: GLfloat, _w: GLfloat, _h: GLfloat) callconv(.C) void,
            .viewportIndexedfv => *const fn (_index: GLuint, _v: [*c]const GLfloat) callconv(.C) void,
            .scissorArrayv => *const fn (_first: GLuint, _count: GLsizei, _v: [*c]const GLint) callconv(.C) void,
            .scissorIndexed => *const fn (_index: GLuint, _left: GLint, _bottom: GLint, _width: GLsizei, _height: GLsizei) callconv(.C) void,
            .scissorIndexedv => *const fn (_index: GLuint, _v: [*c]const GLint) callconv(.C) void,
            .depthRangeArrayv => *const fn (_first: GLuint, _count: GLsizei, _v: [*c]const GLdouble) callconv(.C) void,
            .depthRangeIndexed => *const fn (_index: GLuint, _n: GLdouble, _f: GLdouble) callconv(.C) void,
            .getFloati_v => *const fn (_target: GLenum, _index: GLuint, _data: [*c]GLfloat) callconv(.C) void,
            .getDoublei_v => *const fn (_target: GLenum, _index: GLuint, _data: [*c]GLdouble) callconv(.C) void,
            .drawArraysInstancedBaseInstance => *const fn (_mode: GLenum, _first: GLint, _count: GLsizei, _instancecount: GLsizei, _baseinstance: GLuint) callconv(.C) void,
            .drawElementsInstancedBaseInstance => *const fn (_mode: GLenum, _count: GLsizei, _type: GLenum, _indices: ?*const anyopaque, _instancecount: GLsizei, _baseinstance: GLuint) callconv(.C) void,
            .drawElementsInstancedBaseVertexBaseInstance => *const fn (_mode: GLenum, _count: GLsizei, _type: GLenum, _indices: ?*const anyopaque, _instancecount: GLsizei, _basevertex: GLint, _baseinstance: GLuint) callconv(.C) void,
            .getInternalformativ => *const fn (_target: GLenum, _internalformat: GLenum, _pname: GLenum, _count: GLsizei, _params: [*c]GLint) callconv(.C) void,
            .getActiveAtomicCounterBufferiv => *const fn (_program: GLuint, _bufferIndex: GLuint, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .bindImageTexture => *const fn (_unit: GLuint, _texture: GLuint, _level: GLint, _layered: GLboolean, _layer: GLint, _access: GLenum, _format: GLenum) callconv(.C) void,
            .memoryBarrier => *const fn (_barriers: GLbitfield) callconv(.C) void,
            .texStorage1D => *const fn (_target: GLenum, _levels: GLsizei, _internalformat: GLenum, _width: GLsizei) callconv(.C) void,
            .texStorage2D => *const fn (_target: GLenum, _levels: GLsizei, _internalformat: GLenum, _width: GLsizei, _height: GLsizei) callconv(.C) void,
            .texStorage3D => *const fn (_target: GLenum, _levels: GLsizei, _internalformat: GLenum, _width: GLsizei, _height: GLsizei, _depth: GLsizei) callconv(.C) void,
            .drawTransformFeedbackInstanced => *const fn (_mode: GLenum, _id: GLuint, _instancecount: GLsizei) callconv(.C) void,
            .drawTransformFeedbackStreamInstanced => *const fn (_mode: GLenum, _id: GLuint, _stream: GLuint, _instancecount: GLsizei) callconv(.C) void,
            .clearBufferData => *const fn (_target: GLenum, _internalformat: GLenum, _format: GLenum, _type: GLenum, _data: ?*const anyopaque) callconv(.C) void,
            .clearBufferSubData => *const fn (_target: GLenum, _internalformat: GLenum, _offset: GLintptr, _size: GLsizeiptr, _format: GLenum, _type: GLenum, _data: ?*const anyopaque) callconv(.C) void,
            .dispatchCompute => *const fn (_num_groups_x: GLuint, _num_groups_y: GLuint, _num_groups_z: GLuint) callconv(.C) void,
            .dispatchComputeIndirect => *const fn (_indirect: GLintptr) callconv(.C) void,
            .copyImageSubData => *const fn (_srcName: GLuint, _srcTarget: GLenum, _srcLevel: GLint, _srcX: GLint, _srcY: GLint, _srcZ: GLint, _dstName: GLuint, _dstTarget: GLenum, _dstLevel: GLint, _dstX: GLint, _dstY: GLint, _dstZ: GLint, _srcWidth: GLsizei, _srcHeight: GLsizei, _srcDepth: GLsizei) callconv(.C) void,
            .framebufferParameteri => *const fn (_target: GLenum, _pname: GLenum, _param: GLint) callconv(.C) void,
            .getFramebufferParameteriv => *const fn (_target: GLenum, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .getInternalformati64v => *const fn (_target: GLenum, _internalformat: GLenum, _pname: GLenum, _count: GLsizei, _params: [*c]GLint64) callconv(.C) void,
            .invalidateTexSubImage => *const fn (_texture: GLuint, _level: GLint, _xoffset: GLint, _yoffset: GLint, _zoffset: GLint, _width: GLsizei, _height: GLsizei, _depth: GLsizei) callconv(.C) void,
            .invalidateTexImage => *const fn (_texture: GLuint, _level: GLint) callconv(.C) void,
            .invalidateBufferSubData => *const fn (_buffer: GLuint, _offset: GLintptr, _length: GLsizeiptr) callconv(.C) void,
            .invalidateBufferData => *const fn (_buffer: GLuint) callconv(.C) void,
            .invalidateFramebuffer => *const fn (_target: GLenum, _numAttachments: GLsizei, _attachments: [*c]const GLenum) callconv(.C) void,
            .invalidateSubFramebuffer => *const fn (_target: GLenum, _numAttachments: GLsizei, _attachments: [*c]const GLenum, _x: GLint, _y: GLint, _width: GLsizei, _height: GLsizei) callconv(.C) void,
            .multiDrawArraysIndirect => *const fn (_mode: GLenum, _indirect: ?*const anyopaque, _drawcount: GLsizei, _stride: GLsizei) callconv(.C) void,
            .multiDrawElementsIndirect => *const fn (_mode: GLenum, _type: GLenum, _indirect: ?*const anyopaque, _drawcount: GLsizei, _stride: GLsizei) callconv(.C) void,
            .getProgramInterfaceiv => *const fn (_program: GLuint, _programInterface: GLenum, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .getProgramResourceIndex => *const fn (_program: GLuint, _programInterface: GLenum, _name: [*c]const GLchar) callconv(.C) GLuint,
            .getProgramResourceName => *const fn (_program: GLuint, _programInterface: GLenum, _index: GLuint, _bufSize: GLsizei, _length: [*c]GLsizei, _name: [*c]GLchar) callconv(.C) void,
            .getProgramResourceiv => *const fn (_program: GLuint, _programInterface: GLenum, _index: GLuint, _propCount: GLsizei, _props: [*c]const GLenum, _count: GLsizei, _length: [*c]GLsizei, _params: [*c]GLint) callconv(.C) void,
            .getProgramResourceLocation => *const fn (_program: GLuint, _programInterface: GLenum, _name: [*c]const GLchar) callconv(.C) GLint,
            .getProgramResourceLocationIndex => *const fn (_program: GLuint, _programInterface: GLenum, _name: [*c]const GLchar) callconv(.C) GLint,
            .shaderStorageBlockBinding => *const fn (_program: GLuint, _storageBlockIndex: GLuint, _storageBlockBinding: GLuint) callconv(.C) void,
            .texBufferRange => *const fn (_target: GLenum, _internalformat: GLenum, _buffer: GLuint, _offset: GLintptr, _size: GLsizeiptr) callconv(.C) void,
            .texStorage2DMultisample => *const fn (_target: GLenum, _samples: GLsizei, _internalformat: GLenum, _width: GLsizei, _height: GLsizei, _fixedsamplelocations: GLboolean) callconv(.C) void,
            .texStorage3DMultisample => *const fn (_target: GLenum, _samples: GLsizei, _internalformat: GLenum, _width: GLsizei, _height: GLsizei, _depth: GLsizei, _fixedsamplelocations: GLboolean) callconv(.C) void,
            .textureView => *const fn (_texture: GLuint, _target: GLenum, _origtexture: GLuint, _internalformat: GLenum, _minlevel: GLuint, _numlevels: GLuint, _minlayer: GLuint, _numlayers: GLuint) callconv(.C) void,
            .bindVertexBuffer => *const fn (_bindingindex: GLuint, _buffer: GLuint, _offset: GLintptr, _stride: GLsizei) callconv(.C) void,
            .vertexAttribFormat => *const fn (_attribindex: GLuint, _size: GLint, _type: GLenum, _normalized: GLboolean, _relativeoffset: GLuint) callconv(.C) void,
            .vertexAttribIFormat => *const fn (_attribindex: GLuint, _size: GLint, _type: GLenum, _relativeoffset: GLuint) callconv(.C) void,
            .vertexAttribLFormat => *const fn (_attribindex: GLuint, _size: GLint, _type: GLenum, _relativeoffset: GLuint) callconv(.C) void,
            .vertexAttribBinding => *const fn (_attribindex: GLuint, _bindingindex: GLuint) callconv(.C) void,
            .vertexBindingDivisor => *const fn (_bindingindex: GLuint, _divisor: GLuint) callconv(.C) void,
            .debugMessageControl => *const fn (_source: GLenum, _type: GLenum, _severity: GLenum, _count: GLsizei, _ids: [*c]const GLuint, _enabled: GLboolean) callconv(.C) void,
            .debugMessageInsert => *const fn (_source: GLenum, _type: GLenum, _id: GLuint, _severity: GLenum, _length: GLsizei, _buf: [*c]const GLchar) callconv(.C) void,
            .debugMessageCallback => *const fn (_callback: GLDEBUGPROC, _userParam: ?*const anyopaque) callconv(.C) void,
            .getDebugMessageLog => *const fn (_count: GLuint, _bufSize: GLsizei, _sources: [*c]GLenum, _types: [*c]GLenum, _ids: [*c]GLuint, _severities: [*c]GLenum, _lengths: [*c]GLsizei, _messageLog: [*c]GLchar) callconv(.C) GLuint,
            .pushDebugGroup => *const fn (_source: GLenum, _id: GLuint, _length: GLsizei, _message: [*c]const GLchar) callconv(.C) void,
            .popDebugGroup => *const fn () callconv(.C) void,
            .objectLabel => *const fn (_identifier: GLenum, _name: GLuint, _length: GLsizei, _label: [*c]const GLchar) callconv(.C) void,
            .getObjectLabel => *const fn (_identifier: GLenum, _name: GLuint, _bufSize: GLsizei, _length: [*c]GLsizei, _label: [*c]GLchar) callconv(.C) void,
            .objectPtrLabel => *const fn (_ptr: ?*const anyopaque, _length: GLsizei, _label: [*c]const GLchar) callconv(.C) void,
            .getObjectPtrLabel => *const fn (_ptr: ?*const anyopaque, _bufSize: GLsizei, _length: [*c]GLsizei, _label: [*c]GLchar) callconv(.C) void,
            .bufferStorage => *const fn (_target: GLenum, _size: GLsizeiptr, _data: ?*const anyopaque, _flags: GLbitfield) callconv(.C) void,
            .clearTexImage => *const fn (_texture: GLuint, _level: GLint, _format: GLenum, _type: GLenum, _data: ?*const anyopaque) callconv(.C) void,
            .clearTexSubImage => *const fn (_texture: GLuint, _level: GLint, _xoffset: GLint, _yoffset: GLint, _zoffset: GLint, _width: GLsizei, _height: GLsizei, _depth: GLsizei, _format: GLenum, _type: GLenum, _data: ?*const anyopaque) callconv(.C) void,
            .bindBuffersBase => *const fn (_target: GLenum, _first: GLuint, _count: GLsizei, _buffers: [*c]const GLuint) callconv(.C) void,
            .bindBuffersRange => *const fn (_target: GLenum, _first: GLuint, _count: GLsizei, _buffers: [*c]const GLuint, _offsets: [*c]const GLintptr, _sizes: [*c]const GLsizeiptr) callconv(.C) void,
            .bindTextures => *const fn (_first: GLuint, _count: GLsizei, _textures: [*c]const GLuint) callconv(.C) void,
            .bindSamplers => *const fn (_first: GLuint, _count: GLsizei, _samplers: [*c]const GLuint) callconv(.C) void,
            .bindImageTextures => *const fn (_first: GLuint, _count: GLsizei, _textures: [*c]const GLuint) callconv(.C) void,
            .bindVertexBuffers => *const fn (_first: GLuint, _count: GLsizei, _buffers: [*c]const GLuint, _offsets: [*c]const GLintptr, _strides: [*c]const GLsizei) callconv(.C) void,
            .clipControl => *const fn (_origin: GLenum, _depth: GLenum) callconv(.C) void,
            .createTransformFeedbacks => *const fn (_n: GLsizei, _ids: [*c]GLuint) callconv(.C) void,
            .transformFeedbackBufferBase => *const fn (_xfb: GLuint, _index: GLuint, _buffer: GLuint) callconv(.C) void,
            .transformFeedbackBufferRange => *const fn (_xfb: GLuint, _index: GLuint, _buffer: GLuint, _offset: GLintptr, _size: GLsizeiptr) callconv(.C) void,
            .getTransformFeedbackiv => *const fn (_xfb: GLuint, _pname: GLenum, _param: [*c]GLint) callconv(.C) void,
            .getTransformFeedbacki_v => *const fn (_xfb: GLuint, _pname: GLenum, _index: GLuint, _param: [*c]GLint) callconv(.C) void,
            .getTransformFeedbacki64_v => *const fn (_xfb: GLuint, _pname: GLenum, _index: GLuint, _param: [*c]GLint64) callconv(.C) void,
            .createBuffers => *const fn (_n: GLsizei, _buffers: [*c]GLuint) callconv(.C) void,
            .namedBufferStorage => *const fn (_buffer: GLuint, _size: GLsizeiptr, _data: ?*const anyopaque, _flags: GLbitfield) callconv(.C) void,
            .namedBufferData => *const fn (_buffer: GLuint, _size: GLsizeiptr, _data: ?*const anyopaque, _usage: GLenum) callconv(.C) void,
            .namedBufferSubData => *const fn (_buffer: GLuint, _offset: GLintptr, _size: GLsizeiptr, _data: ?*const anyopaque) callconv(.C) void,
            .copyNamedBufferSubData => *const fn (_readBuffer: GLuint, _writeBuffer: GLuint, _readOffset: GLintptr, _writeOffset: GLintptr, _size: GLsizeiptr) callconv(.C) void,
            .clearNamedBufferData => *const fn (_buffer: GLuint, _internalformat: GLenum, _format: GLenum, _type: GLenum, _data: ?*const anyopaque) callconv(.C) void,
            .clearNamedBufferSubData => *const fn (_buffer: GLuint, _internalformat: GLenum, _offset: GLintptr, _size: GLsizeiptr, _format: GLenum, _type: GLenum, _data: ?*const anyopaque) callconv(.C) void,
            .mapNamedBuffer => *const fn (_buffer: GLuint, _access: GLenum) callconv(.C) ?*anyopaque,
            .mapNamedBufferRange => *const fn (_buffer: GLuint, _offset: GLintptr, _length: GLsizeiptr, _access: GLbitfield) callconv(.C) ?*anyopaque,
            .unmapNamedBuffer => *const fn (_buffer: GLuint) callconv(.C) GLboolean,
            .flushMappedNamedBufferRange => *const fn (_buffer: GLuint, _offset: GLintptr, _length: GLsizeiptr) callconv(.C) void,
            .getNamedBufferParameteriv => *const fn (_buffer: GLuint, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .getNamedBufferParameteri64v => *const fn (_buffer: GLuint, _pname: GLenum, _params: [*c]GLint64) callconv(.C) void,
            .getNamedBufferPointerv => *const fn (_buffer: GLuint, _pname: GLenum, _params: ?*?*anyopaque) callconv(.C) void,
            .getNamedBufferSubData => *const fn (_buffer: GLuint, _offset: GLintptr, _size: GLsizeiptr, _data: ?*anyopaque) callconv(.C) void,
            .createFramebuffers => *const fn (_n: GLsizei, _framebuffers: [*c]GLuint) callconv(.C) void,
            .namedFramebufferRenderbuffer => *const fn (_framebuffer: GLuint, _attachment: GLenum, _renderbuffertarget: GLenum, _renderbuffer: GLuint) callconv(.C) void,
            .namedFramebufferParameteri => *const fn (_framebuffer: GLuint, _pname: GLenum, _param: GLint) callconv(.C) void,
            .namedFramebufferTexture => *const fn (_framebuffer: GLuint, _attachment: GLenum, _texture: GLuint, _level: GLint) callconv(.C) void,
            .namedFramebufferTextureLayer => *const fn (_framebuffer: GLuint, _attachment: GLenum, _texture: GLuint, _level: GLint, _layer: GLint) callconv(.C) void,
            .namedFramebufferDrawBuffer => *const fn (_framebuffer: GLuint, _buf: GLenum) callconv(.C) void,
            .namedFramebufferDrawBuffers => *const fn (_framebuffer: GLuint, _n: GLsizei, _bufs: [*c]const GLenum) callconv(.C) void,
            .namedFramebufferReadBuffer => *const fn (_framebuffer: GLuint, _src: GLenum) callconv(.C) void,
            .invalidateNamedFramebufferData => *const fn (_framebuffer: GLuint, _numAttachments: GLsizei, _attachments: [*c]const GLenum) callconv(.C) void,
            .invalidateNamedFramebufferSubData => *const fn (_framebuffer: GLuint, _numAttachments: GLsizei, _attachments: [*c]const GLenum, _x: GLint, _y: GLint, _width: GLsizei, _height: GLsizei) callconv(.C) void,
            .clearNamedFramebufferiv => *const fn (_framebuffer: GLuint, _buffer: GLenum, _drawbuffer: GLint, _value: [*c]const GLint) callconv(.C) void,
            .clearNamedFramebufferuiv => *const fn (_framebuffer: GLuint, _buffer: GLenum, _drawbuffer: GLint, _value: [*c]const GLuint) callconv(.C) void,
            .clearNamedFramebufferfv => *const fn (_framebuffer: GLuint, _buffer: GLenum, _drawbuffer: GLint, _value: [*c]const GLfloat) callconv(.C) void,
            .clearNamedFramebufferfi => *const fn (_framebuffer: GLuint, _buffer: GLenum, _drawbuffer: GLint, _depth: GLfloat, _stencil: GLint) callconv(.C) void,
            .blitNamedFramebuffer => *const fn (_readFramebuffer: GLuint, _drawFramebuffer: GLuint, _srcX0: GLint, _srcY0: GLint, _srcX1: GLint, _srcY1: GLint, _dstX0: GLint, _dstY0: GLint, _dstX1: GLint, _dstY1: GLint, _mask: GLbitfield, _filter: GLenum) callconv(.C) void,
            .checkNamedFramebufferStatus => *const fn (_framebuffer: GLuint, _target: GLenum) callconv(.C) GLenum,
            .getNamedFramebufferParameteriv => *const fn (_framebuffer: GLuint, _pname: GLenum, _param: [*c]GLint) callconv(.C) void,
            .getNamedFramebufferAttachmentParameteriv => *const fn (_framebuffer: GLuint, _attachment: GLenum, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .createRenderbuffers => *const fn (_n: GLsizei, _renderbuffers: [*c]GLuint) callconv(.C) void,
            .namedRenderbufferStorage => *const fn (_renderbuffer: GLuint, _internalformat: GLenum, _width: GLsizei, _height: GLsizei) callconv(.C) void,
            .namedRenderbufferStorageMultisample => *const fn (_renderbuffer: GLuint, _samples: GLsizei, _internalformat: GLenum, _width: GLsizei, _height: GLsizei) callconv(.C) void,
            .getNamedRenderbufferParameteriv => *const fn (_renderbuffer: GLuint, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .createTextures => *const fn (_target: GLenum, _n: GLsizei, _textures: [*c]GLuint) callconv(.C) void,
            .textureBuffer => *const fn (_texture: GLuint, _internalformat: GLenum, _buffer: GLuint) callconv(.C) void,
            .textureBufferRange => *const fn (_texture: GLuint, _internalformat: GLenum, _buffer: GLuint, _offset: GLintptr, _size: GLsizeiptr) callconv(.C) void,
            .textureStorage1D => *const fn (_texture: GLuint, _levels: GLsizei, _internalformat: GLenum, _width: GLsizei) callconv(.C) void,
            .textureStorage2D => *const fn (_texture: GLuint, _levels: GLsizei, _internalformat: GLenum, _width: GLsizei, _height: GLsizei) callconv(.C) void,
            .textureStorage3D => *const fn (_texture: GLuint, _levels: GLsizei, _internalformat: GLenum, _width: GLsizei, _height: GLsizei, _depth: GLsizei) callconv(.C) void,
            .textureStorage2DMultisample => *const fn (_texture: GLuint, _samples: GLsizei, _internalformat: GLenum, _width: GLsizei, _height: GLsizei, _fixedsamplelocations: GLboolean) callconv(.C) void,
            .textureStorage3DMultisample => *const fn (_texture: GLuint, _samples: GLsizei, _internalformat: GLenum, _width: GLsizei, _height: GLsizei, _depth: GLsizei, _fixedsamplelocations: GLboolean) callconv(.C) void,
            .textureSubImage1D => *const fn (_texture: GLuint, _level: GLint, _xoffset: GLint, _width: GLsizei, _format: GLenum, _type: GLenum, _pixels: ?*const anyopaque) callconv(.C) void,
            .textureSubImage2D => *const fn (_texture: GLuint, _level: GLint, _xoffset: GLint, _yoffset: GLint, _width: GLsizei, _height: GLsizei, _format: GLenum, _type: GLenum, _pixels: ?*const anyopaque) callconv(.C) void,
            .textureSubImage3D => *const fn (_texture: GLuint, _level: GLint, _xoffset: GLint, _yoffset: GLint, _zoffset: GLint, _width: GLsizei, _height: GLsizei, _depth: GLsizei, _format: GLenum, _type: GLenum, _pixels: ?*const anyopaque) callconv(.C) void,
            .compressedTextureSubImage1D => *const fn (_texture: GLuint, _level: GLint, _xoffset: GLint, _width: GLsizei, _format: GLenum, _imageSize: GLsizei, _data: ?*const anyopaque) callconv(.C) void,
            .compressedTextureSubImage2D => *const fn (_texture: GLuint, _level: GLint, _xoffset: GLint, _yoffset: GLint, _width: GLsizei, _height: GLsizei, _format: GLenum, _imageSize: GLsizei, _data: ?*const anyopaque) callconv(.C) void,
            .compressedTextureSubImage3D => *const fn (_texture: GLuint, _level: GLint, _xoffset: GLint, _yoffset: GLint, _zoffset: GLint, _width: GLsizei, _height: GLsizei, _depth: GLsizei, _format: GLenum, _imageSize: GLsizei, _data: ?*const anyopaque) callconv(.C) void,
            .copyTextureSubImage1D => *const fn (_texture: GLuint, _level: GLint, _xoffset: GLint, _x: GLint, _y: GLint, _width: GLsizei) callconv(.C) void,
            .copyTextureSubImage2D => *const fn (_texture: GLuint, _level: GLint, _xoffset: GLint, _yoffset: GLint, _x: GLint, _y: GLint, _width: GLsizei, _height: GLsizei) callconv(.C) void,
            .copyTextureSubImage3D => *const fn (_texture: GLuint, _level: GLint, _xoffset: GLint, _yoffset: GLint, _zoffset: GLint, _x: GLint, _y: GLint, _width: GLsizei, _height: GLsizei) callconv(.C) void,
            .textureParameterf => *const fn (_texture: GLuint, _pname: GLenum, _param: GLfloat) callconv(.C) void,
            .textureParameterfv => *const fn (_texture: GLuint, _pname: GLenum, _param: [*c]const GLfloat) callconv(.C) void,
            .textureParameteri => *const fn (_texture: GLuint, _pname: GLenum, _param: GLint) callconv(.C) void,
            .textureParameterIiv => *const fn (_texture: GLuint, _pname: GLenum, _params: [*c]const GLint) callconv(.C) void,
            .textureParameterIuiv => *const fn (_texture: GLuint, _pname: GLenum, _params: [*c]const GLuint) callconv(.C) void,
            .textureParameteriv => *const fn (_texture: GLuint, _pname: GLenum, _param: [*c]const GLint) callconv(.C) void,
            .generateTextureMipmap => *const fn (_texture: GLuint) callconv(.C) void,
            .bindTextureUnit => *const fn (_unit: GLuint, _texture: GLuint) callconv(.C) void,
            .getTextureImage => *const fn (_texture: GLuint, _level: GLint, _format: GLenum, _type: GLenum, _bufSize: GLsizei, _pixels: ?*anyopaque) callconv(.C) void,
            .getCompressedTextureImage => *const fn (_texture: GLuint, _level: GLint, _bufSize: GLsizei, _pixels: ?*anyopaque) callconv(.C) void,
            .getTextureLevelParameterfv => *const fn (_texture: GLuint, _level: GLint, _pname: GLenum, _params: [*c]GLfloat) callconv(.C) void,
            .getTextureLevelParameteriv => *const fn (_texture: GLuint, _level: GLint, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .getTextureParameterfv => *const fn (_texture: GLuint, _pname: GLenum, _params: [*c]GLfloat) callconv(.C) void,
            .getTextureParameterIiv => *const fn (_texture: GLuint, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .getTextureParameterIuiv => *const fn (_texture: GLuint, _pname: GLenum, _params: [*c]GLuint) callconv(.C) void,
            .getTextureParameteriv => *const fn (_texture: GLuint, _pname: GLenum, _params: [*c]GLint) callconv(.C) void,
            .createVertexArrays => *const fn (_n: GLsizei, _arrays: [*c]GLuint) callconv(.C) void,
            .disableVertexArrayAttrib => *const fn (_vaobj: GLuint, _index: GLuint) callconv(.C) void,
            .enableVertexArrayAttrib => *const fn (_vaobj: GLuint, _index: GLuint) callconv(.C) void,
            .vertexArrayElementBuffer => *const fn (_vaobj: GLuint, _buffer: GLuint) callconv(.C) void,
            .vertexArrayVertexBuffer => *const fn (_vaobj: GLuint, _bindingindex: GLuint, _buffer: GLuint, _offset: GLintptr, _stride: GLsizei) callconv(.C) void,
            .vertexArrayVertexBuffers => *const fn (_vaobj: GLuint, _first: GLuint, _count: GLsizei, _buffers: [*c]const GLuint, _offsets: [*c]const GLintptr, _strides: [*c]const GLsizei) callconv(.C) void,
            .vertexArrayAttribBinding => *const fn (_vaobj: GLuint, _attribindex: GLuint, _bindingindex: GLuint) callconv(.C) void,
            .vertexArrayAttribFormat => *const fn (_vaobj: GLuint, _attribindex: GLuint, _size: GLint, _type: GLenum, _normalized: GLboolean, _relativeoffset: GLuint) callconv(.C) void,
            .vertexArrayAttribIFormat => *const fn (_vaobj: GLuint, _attribindex: GLuint, _size: GLint, _type: GLenum, _relativeoffset: GLuint) callconv(.C) void,
            .vertexArrayAttribLFormat => *const fn (_vaobj: GLuint, _attribindex: GLuint, _size: GLint, _type: GLenum, _relativeoffset: GLuint) callconv(.C) void,
            .vertexArrayBindingDivisor => *const fn (_vaobj: GLuint, _bindingindex: GLuint, _divisor: GLuint) callconv(.C) void,
            .getVertexArrayiv => *const fn (_vaobj: GLuint, _pname: GLenum, _param: [*c]GLint) callconv(.C) void,
            .getVertexArrayIndexediv => *const fn (_vaobj: GLuint, _index: GLuint, _pname: GLenum, _param: [*c]GLint) callconv(.C) void,
            .getVertexArrayIndexed64iv => *const fn (_vaobj: GLuint, _index: GLuint, _pname: GLenum, _param: [*c]GLint64) callconv(.C) void,
            .createSamplers => *const fn (_n: GLsizei, _samplers: [*c]GLuint) callconv(.C) void,
            .createProgramPipelines => *const fn (_n: GLsizei, _pipelines: [*c]GLuint) callconv(.C) void,
            .createQueries => *const fn (_target: GLenum, _n: GLsizei, _ids: [*c]GLuint) callconv(.C) void,
            .getQueryBufferObjecti64v => *const fn (_id: GLuint, _buffer: GLuint, _pname: GLenum, _offset: GLintptr) callconv(.C) void,
            .getQueryBufferObjectiv => *const fn (_id: GLuint, _buffer: GLuint, _pname: GLenum, _offset: GLintptr) callconv(.C) void,
            .getQueryBufferObjectui64v => *const fn (_id: GLuint, _buffer: GLuint, _pname: GLenum, _offset: GLintptr) callconv(.C) void,
            .getQueryBufferObjectuiv => *const fn (_id: GLuint, _buffer: GLuint, _pname: GLenum, _offset: GLintptr) callconv(.C) void,
            .memoryBarrierByRegion => *const fn (_barriers: GLbitfield) callconv(.C) void,
            .getTextureSubImage => *const fn (_texture: GLuint, _level: GLint, _xoffset: GLint, _yoffset: GLint, _zoffset: GLint, _width: GLsizei, _height: GLsizei, _depth: GLsizei, _format: GLenum, _type: GLenum, _bufSize: GLsizei, _pixels: ?*anyopaque) callconv(.C) void,
            .getCompressedTextureSubImage => *const fn (_texture: GLuint, _level: GLint, _xoffset: GLint, _yoffset: GLint, _zoffset: GLint, _width: GLsizei, _height: GLsizei, _depth: GLsizei, _bufSize: GLsizei, _pixels: ?*anyopaque) callconv(.C) void,
            .getGraphicsResetStatus => *const fn () callconv(.C) GLenum,
            .getnCompressedTexImage => *const fn (_target: GLenum, _lod: GLint, _bufSize: GLsizei, _pixels: ?*anyopaque) callconv(.C) void,
            .getnTexImage => *const fn (_target: GLenum, _level: GLint, _format: GLenum, _type: GLenum, _bufSize: GLsizei, _pixels: ?*anyopaque) callconv(.C) void,
            .getnUniformdv => *const fn (_program: GLuint, _location: GLint, _bufSize: GLsizei, _params: [*c]GLdouble) callconv(.C) void,
            .getnUniformfv => *const fn (_program: GLuint, _location: GLint, _bufSize: GLsizei, _params: [*c]GLfloat) callconv(.C) void,
            .getnUniformiv => *const fn (_program: GLuint, _location: GLint, _bufSize: GLsizei, _params: [*c]GLint) callconv(.C) void,
            .getnUniformuiv => *const fn (_program: GLuint, _location: GLint, _bufSize: GLsizei, _params: [*c]GLuint) callconv(.C) void,
            .readnPixels => *const fn (_x: GLint, _y: GLint, _width: GLsizei, _height: GLsizei, _format: GLenum, _type: GLenum, _bufSize: GLsizei, _data: ?*anyopaque) callconv(.C) void,
            .getnMapdv => *const fn (_target: GLenum, _query: GLenum, _bufSize: GLsizei, _v: [*c]GLdouble) callconv(.C) void,
            .getnMapfv => *const fn (_target: GLenum, _query: GLenum, _bufSize: GLsizei, _v: [*c]GLfloat) callconv(.C) void,
            .getnMapiv => *const fn (_target: GLenum, _query: GLenum, _bufSize: GLsizei, _v: [*c]GLint) callconv(.C) void,
            .getnPixelMapfv => *const fn (_map: GLenum, _bufSize: GLsizei, _values: [*c]GLfloat) callconv(.C) void,
            .getnPixelMapuiv => *const fn (_map: GLenum, _bufSize: GLsizei, _values: [*c]GLuint) callconv(.C) void,
            .getnPixelMapusv => *const fn (_map: GLenum, _bufSize: GLsizei, _values: [*c]GLushort) callconv(.C) void,
            .getnPolygonStipple => *const fn (_bufSize: GLsizei, _pattern: [*c]GLubyte) callconv(.C) void,
            .getnColorTable => *const fn (_target: GLenum, _format: GLenum, _type: GLenum, _bufSize: GLsizei, _table: ?*anyopaque) callconv(.C) void,
            .getnConvolutionFilter => *const fn (_target: GLenum, _format: GLenum, _type: GLenum, _bufSize: GLsizei, _image: ?*anyopaque) callconv(.C) void,
            .getnSeparableFilter => *const fn (_target: GLenum, _format: GLenum, _type: GLenum, _rowBufSize: GLsizei, _row: ?*anyopaque, _columnBufSize: GLsizei, _column: ?*anyopaque, _span: ?*anyopaque) callconv(.C) void,
            .getnHistogram => *const fn (_target: GLenum, _reset: GLboolean, _format: GLenum, _type: GLenum, _bufSize: GLsizei, _values: ?*anyopaque) callconv(.C) void,
            .getnMinmax => *const fn (_target: GLenum, _reset: GLboolean, _format: GLenum, _type: GLenum, _bufSize: GLsizei, _values: ?*anyopaque) callconv(.C) void,
            .textureBarrier => *const fn () callconv(.C) void,
            .specializeShader => *const fn (_shader: GLuint, _pEntryPoint: [*c]const GLchar, _numSpecializationConstants: GLuint, _pConstantIndex: [*c]const GLuint, _pConstantValue: [*c]const GLuint) callconv(.C) void,
            .multiDrawArraysIndirectCount => *const fn (_mode: GLenum, _indirect: ?*const anyopaque, _drawcount: GLintptr, _maxdrawcount: GLsizei, _stride: GLsizei) callconv(.C) void,
            .multiDrawElementsIndirectCount => *const fn (_mode: GLenum, _type: GLenum, _indirect: ?*const anyopaque, _drawcount: GLintptr, _maxdrawcount: GLsizei, _stride: GLsizei) callconv(.C) void,
            .polygonOffsetClamp => *const fn (_factor: GLfloat, _units: GLfloat, _clamp: GLfloat) callconv(.C) void,
            .clipPlanef => *const fn (_p: GLenum, _eqn: [*c]const GLfloat) callconv(.C) void,
            .frustumf => *const fn (_l: GLfloat, _r: GLfloat, _b: GLfloat, _t: GLfloat, _n: GLfloat, _f: GLfloat) callconv(.C) void,
            .getClipPlanef => *const fn (_plane: GLenum, _equation: [*c]GLfloat) callconv(.C) void,
            .orthof => *const fn (_l: GLfloat, _r: GLfloat, _b: GLfloat, _t: GLfloat, _n: GLfloat, _f: GLfloat) callconv(.C) void,
            .alphaFuncx => *const fn (_func: GLenum, _ref: GLfixed) callconv(.C) void,
            .clearColorx => *const fn (_red: GLfixed, _green: GLfixed, _blue: GLfixed, _alpha: GLfixed) callconv(.C) void,
            .clearDepthx => *const fn (_depth: GLfixed) callconv(.C) void,
            .clipPlanex => *const fn (_plane: GLenum, _equation: [*c]const GLfixed) callconv(.C) void,
            .color4x => *const fn (_red: GLfixed, _green: GLfixed, _blue: GLfixed, _alpha: GLfixed) callconv(.C) void,
            .depthRangex => *const fn (_n: GLfixed, _f: GLfixed) callconv(.C) void,
            .fogx => *const fn (_pname: GLenum, _param: GLfixed) callconv(.C) void,
            .fogxv => *const fn (_pname: GLenum, _param: [*c]const GLfixed) callconv(.C) void,
            .frustumx => *const fn (_l: GLfixed, _r: GLfixed, _b: GLfixed, _t: GLfixed, _n: GLfixed, _f: GLfixed) callconv(.C) void,
            .getClipPlanex => *const fn (_plane: GLenum, _equation: [*c]GLfixed) callconv(.C) void,
            .getFixedv => *const fn (_pname: GLenum, _params: [*c]GLfixed) callconv(.C) void,
            .getLightxv => *const fn (_light: GLenum, _pname: GLenum, _params: [*c]GLfixed) callconv(.C) void,
            .getMaterialxv => *const fn (_face: GLenum, _pname: GLenum, _params: [*c]GLfixed) callconv(.C) void,
            .getTexEnvxv => *const fn (_target: GLenum, _pname: GLenum, _params: [*c]GLfixed) callconv(.C) void,
            .getTexParameterxv => *const fn (_target: GLenum, _pname: GLenum, _params: [*c]GLfixed) callconv(.C) void,
            .lightModelx => *const fn (_pname: GLenum, _param: GLfixed) callconv(.C) void,
            .lightModelxv => *const fn (_pname: GLenum, _param: [*c]const GLfixed) callconv(.C) void,
            .lightx => *const fn (_light: GLenum, _pname: GLenum, _param: GLfixed) callconv(.C) void,
            .lightxv => *const fn (_light: GLenum, _pname: GLenum, _params: [*c]const GLfixed) callconv(.C) void,
            .lineWidthx => *const fn (_width: GLfixed) callconv(.C) void,
            .loadMatrixx => *const fn (_m: [*c]const GLfixed) callconv(.C) void,
            .materialx => *const fn (_face: GLenum, _pname: GLenum, _param: GLfixed) callconv(.C) void,
            .materialxv => *const fn (_face: GLenum, _pname: GLenum, _param: [*c]const GLfixed) callconv(.C) void,
            .multMatrixx => *const fn (_m: [*c]const GLfixed) callconv(.C) void,
            .multiTexCoord4x => *const fn (_texture: GLenum, _s: GLfixed, _t: GLfixed, _r: GLfixed, _q: GLfixed) callconv(.C) void,
            .normal3x => *const fn (_nx: GLfixed, _ny: GLfixed, _nz: GLfixed) callconv(.C) void,
            .orthox => *const fn (_l: GLfixed, _r: GLfixed, _b: GLfixed, _t: GLfixed, _n: GLfixed, _f: GLfixed) callconv(.C) void,
            .pointParameterx => *const fn (_pname: GLenum, _param: GLfixed) callconv(.C) void,
            .pointParameterxv => *const fn (_pname: GLenum, _params: [*c]const GLfixed) callconv(.C) void,
            .pointSizex => *const fn (_size: GLfixed) callconv(.C) void,
            .polygonOffsetx => *const fn (_factor: GLfixed, _units: GLfixed) callconv(.C) void,
            .rotatex => *const fn (_angle: GLfixed, _x: GLfixed, _y: GLfixed, _z: GLfixed) callconv(.C) void,
            .sampleCoveragex => *const fn (_value: GLclampx, _invert: GLboolean) callconv(.C) void,
            .scalex => *const fn (_x: GLfixed, _y: GLfixed, _z: GLfixed) callconv(.C) void,
            .texEnvx => *const fn (_target: GLenum, _pname: GLenum, _param: GLfixed) callconv(.C) void,
            .texEnvxv => *const fn (_target: GLenum, _pname: GLenum, _params: [*c]const GLfixed) callconv(.C) void,
            .texParameterx => *const fn (_target: GLenum, _pname: GLenum, _param: GLfixed) callconv(.C) void,
            .texParameterxv => *const fn (_target: GLenum, _pname: GLenum, _params: [*c]const GLfixed) callconv(.C) void,
            .translatex => *const fn (_x: GLfixed, _y: GLfixed, _z: GLfixed) callconv(.C) void,
            .blendBarrier => *const fn () callconv(.C) void,
            .primitiveBoundingBox => *const fn (_minX: GLfloat, _minY: GLfloat, _minZ: GLfloat, _minW: GLfloat, _maxX: GLfloat, _maxY: GLfloat, _maxZ: GLfloat, _maxW: GLfloat) callconv(.C) void,
        };
    }
    pub fn cmdName(tag: std.meta.FieldEnum(CommandFlags)) [:0]const u8 {
        return switch (tag) {
            .cullFace => "glCullFace",
            .frontFace => "glFrontFace",
            .hint => "glHint",
            .lineWidth => "glLineWidth",
            .pointSize => "glPointSize",
            .polygonMode => "glPolygonMode",
            .scissor => "glScissor",
            .texParameterf => "glTexParameterf",
            .texParameterfv => "glTexParameterfv",
            .texParameteri => "glTexParameteri",
            .texParameteriv => "glTexParameteriv",
            .texImage1D => "glTexImage1D",
            .texImage2D => "glTexImage2D",
            .drawBuffer => "glDrawBuffer",
            .clear => "glClear",
            .clearColor => "glClearColor",
            .clearStencil => "glClearStencil",
            .clearDepth => "glClearDepth",
            .stencilMask => "glStencilMask",
            .colorMask => "glColorMask",
            .depthMask => "glDepthMask",
            .disable => "glDisable",
            .enable => "glEnable",
            .finish => "glFinish",
            .flush => "glFlush",
            .blendFunc => "glBlendFunc",
            .logicOp => "glLogicOp",
            .stencilFunc => "glStencilFunc",
            .stencilOp => "glStencilOp",
            .depthFunc => "glDepthFunc",
            .pixelStoref => "glPixelStoref",
            .pixelStorei => "glPixelStorei",
            .readBuffer => "glReadBuffer",
            .readPixels => "glReadPixels",
            .getBooleanv => "glGetBooleanv",
            .getDoublev => "glGetDoublev",
            .getError => "glGetError",
            .getFloatv => "glGetFloatv",
            .getIntegerv => "glGetIntegerv",
            .getString => "glGetString",
            .getTexImage => "glGetTexImage",
            .getTexParameterfv => "glGetTexParameterfv",
            .getTexParameteriv => "glGetTexParameteriv",
            .getTexLevelParameterfv => "glGetTexLevelParameterfv",
            .getTexLevelParameteriv => "glGetTexLevelParameteriv",
            .isEnabled => "glIsEnabled",
            .depthRange => "glDepthRange",
            .viewport => "glViewport",
            .newList => "glNewList",
            .endList => "glEndList",
            .callList => "glCallList",
            .callLists => "glCallLists",
            .deleteLists => "glDeleteLists",
            .genLists => "glGenLists",
            .listBase => "glListBase",
            .begin => "glBegin",
            .bitmap => "glBitmap",
            .color3b => "glColor3b",
            .color3bv => "glColor3bv",
            .color3d => "glColor3d",
            .color3dv => "glColor3dv",
            .color3f => "glColor3f",
            .color3fv => "glColor3fv",
            .color3i => "glColor3i",
            .color3iv => "glColor3iv",
            .color3s => "glColor3s",
            .color3sv => "glColor3sv",
            .color3ub => "glColor3ub",
            .color3ubv => "glColor3ubv",
            .color3ui => "glColor3ui",
            .color3uiv => "glColor3uiv",
            .color3us => "glColor3us",
            .color3usv => "glColor3usv",
            .color4b => "glColor4b",
            .color4bv => "glColor4bv",
            .color4d => "glColor4d",
            .color4dv => "glColor4dv",
            .color4f => "glColor4f",
            .color4fv => "glColor4fv",
            .color4i => "glColor4i",
            .color4iv => "glColor4iv",
            .color4s => "glColor4s",
            .color4sv => "glColor4sv",
            .color4ub => "glColor4ub",
            .color4ubv => "glColor4ubv",
            .color4ui => "glColor4ui",
            .color4uiv => "glColor4uiv",
            .color4us => "glColor4us",
            .color4usv => "glColor4usv",
            .edgeFlag => "glEdgeFlag",
            .edgeFlagv => "glEdgeFlagv",
            .end => "glEnd",
            .indexd => "glIndexd",
            .indexdv => "glIndexdv",
            .indexf => "glIndexf",
            .indexfv => "glIndexfv",
            .indexi => "glIndexi",
            .indexiv => "glIndexiv",
            .indexs => "glIndexs",
            .indexsv => "glIndexsv",
            .normal3b => "glNormal3b",
            .normal3bv => "glNormal3bv",
            .normal3d => "glNormal3d",
            .normal3dv => "glNormal3dv",
            .normal3f => "glNormal3f",
            .normal3fv => "glNormal3fv",
            .normal3i => "glNormal3i",
            .normal3iv => "glNormal3iv",
            .normal3s => "glNormal3s",
            .normal3sv => "glNormal3sv",
            .rasterPos2d => "glRasterPos2d",
            .rasterPos2dv => "glRasterPos2dv",
            .rasterPos2f => "glRasterPos2f",
            .rasterPos2fv => "glRasterPos2fv",
            .rasterPos2i => "glRasterPos2i",
            .rasterPos2iv => "glRasterPos2iv",
            .rasterPos2s => "glRasterPos2s",
            .rasterPos2sv => "glRasterPos2sv",
            .rasterPos3d => "glRasterPos3d",
            .rasterPos3dv => "glRasterPos3dv",
            .rasterPos3f => "glRasterPos3f",
            .rasterPos3fv => "glRasterPos3fv",
            .rasterPos3i => "glRasterPos3i",
            .rasterPos3iv => "glRasterPos3iv",
            .rasterPos3s => "glRasterPos3s",
            .rasterPos3sv => "glRasterPos3sv",
            .rasterPos4d => "glRasterPos4d",
            .rasterPos4dv => "glRasterPos4dv",
            .rasterPos4f => "glRasterPos4f",
            .rasterPos4fv => "glRasterPos4fv",
            .rasterPos4i => "glRasterPos4i",
            .rasterPos4iv => "glRasterPos4iv",
            .rasterPos4s => "glRasterPos4s",
            .rasterPos4sv => "glRasterPos4sv",
            .rectd => "glRectd",
            .rectdv => "glRectdv",
            .rectf => "glRectf",
            .rectfv => "glRectfv",
            .recti => "glRecti",
            .rectiv => "glRectiv",
            .rects => "glRects",
            .rectsv => "glRectsv",
            .texCoord1d => "glTexCoord1d",
            .texCoord1dv => "glTexCoord1dv",
            .texCoord1f => "glTexCoord1f",
            .texCoord1fv => "glTexCoord1fv",
            .texCoord1i => "glTexCoord1i",
            .texCoord1iv => "glTexCoord1iv",
            .texCoord1s => "glTexCoord1s",
            .texCoord1sv => "glTexCoord1sv",
            .texCoord2d => "glTexCoord2d",
            .texCoord2dv => "glTexCoord2dv",
            .texCoord2f => "glTexCoord2f",
            .texCoord2fv => "glTexCoord2fv",
            .texCoord2i => "glTexCoord2i",
            .texCoord2iv => "glTexCoord2iv",
            .texCoord2s => "glTexCoord2s",
            .texCoord2sv => "glTexCoord2sv",
            .texCoord3d => "glTexCoord3d",
            .texCoord3dv => "glTexCoord3dv",
            .texCoord3f => "glTexCoord3f",
            .texCoord3fv => "glTexCoord3fv",
            .texCoord3i => "glTexCoord3i",
            .texCoord3iv => "glTexCoord3iv",
            .texCoord3s => "glTexCoord3s",
            .texCoord3sv => "glTexCoord3sv",
            .texCoord4d => "glTexCoord4d",
            .texCoord4dv => "glTexCoord4dv",
            .texCoord4f => "glTexCoord4f",
            .texCoord4fv => "glTexCoord4fv",
            .texCoord4i => "glTexCoord4i",
            .texCoord4iv => "glTexCoord4iv",
            .texCoord4s => "glTexCoord4s",
            .texCoord4sv => "glTexCoord4sv",
            .vertex2d => "glVertex2d",
            .vertex2dv => "glVertex2dv",
            .vertex2f => "glVertex2f",
            .vertex2fv => "glVertex2fv",
            .vertex2i => "glVertex2i",
            .vertex2iv => "glVertex2iv",
            .vertex2s => "glVertex2s",
            .vertex2sv => "glVertex2sv",
            .vertex3d => "glVertex3d",
            .vertex3dv => "glVertex3dv",
            .vertex3f => "glVertex3f",
            .vertex3fv => "glVertex3fv",
            .vertex3i => "glVertex3i",
            .vertex3iv => "glVertex3iv",
            .vertex3s => "glVertex3s",
            .vertex3sv => "glVertex3sv",
            .vertex4d => "glVertex4d",
            .vertex4dv => "glVertex4dv",
            .vertex4f => "glVertex4f",
            .vertex4fv => "glVertex4fv",
            .vertex4i => "glVertex4i",
            .vertex4iv => "glVertex4iv",
            .vertex4s => "glVertex4s",
            .vertex4sv => "glVertex4sv",
            .clipPlane => "glClipPlane",
            .colorMaterial => "glColorMaterial",
            .fogf => "glFogf",
            .fogfv => "glFogfv",
            .fogi => "glFogi",
            .fogiv => "glFogiv",
            .lightf => "glLightf",
            .lightfv => "glLightfv",
            .lighti => "glLighti",
            .lightiv => "glLightiv",
            .lightModelf => "glLightModelf",
            .lightModelfv => "glLightModelfv",
            .lightModeli => "glLightModeli",
            .lightModeliv => "glLightModeliv",
            .lineStipple => "glLineStipple",
            .materialf => "glMaterialf",
            .materialfv => "glMaterialfv",
            .materiali => "glMateriali",
            .materialiv => "glMaterialiv",
            .polygonStipple => "glPolygonStipple",
            .shadeModel => "glShadeModel",
            .texEnvf => "glTexEnvf",
            .texEnvfv => "glTexEnvfv",
            .texEnvi => "glTexEnvi",
            .texEnviv => "glTexEnviv",
            .texGend => "glTexGend",
            .texGendv => "glTexGendv",
            .texGenf => "glTexGenf",
            .texGenfv => "glTexGenfv",
            .texGeni => "glTexGeni",
            .texGeniv => "glTexGeniv",
            .feedbackBuffer => "glFeedbackBuffer",
            .selectBuffer => "glSelectBuffer",
            .renderMode => "glRenderMode",
            .initNames => "glInitNames",
            .loadName => "glLoadName",
            .passThrough => "glPassThrough",
            .popName => "glPopName",
            .pushName => "glPushName",
            .clearAccum => "glClearAccum",
            .clearIndex => "glClearIndex",
            .indexMask => "glIndexMask",
            .accum => "glAccum",
            .popAttrib => "glPopAttrib",
            .pushAttrib => "glPushAttrib",
            .map1d => "glMap1d",
            .map1f => "glMap1f",
            .map2d => "glMap2d",
            .map2f => "glMap2f",
            .mapGrid1d => "glMapGrid1d",
            .mapGrid1f => "glMapGrid1f",
            .mapGrid2d => "glMapGrid2d",
            .mapGrid2f => "glMapGrid2f",
            .evalCoord1d => "glEvalCoord1d",
            .evalCoord1dv => "glEvalCoord1dv",
            .evalCoord1f => "glEvalCoord1f",
            .evalCoord1fv => "glEvalCoord1fv",
            .evalCoord2d => "glEvalCoord2d",
            .evalCoord2dv => "glEvalCoord2dv",
            .evalCoord2f => "glEvalCoord2f",
            .evalCoord2fv => "glEvalCoord2fv",
            .evalMesh1 => "glEvalMesh1",
            .evalPoint1 => "glEvalPoint1",
            .evalMesh2 => "glEvalMesh2",
            .evalPoint2 => "glEvalPoint2",
            .alphaFunc => "glAlphaFunc",
            .pixelZoom => "glPixelZoom",
            .pixelTransferf => "glPixelTransferf",
            .pixelTransferi => "glPixelTransferi",
            .pixelMapfv => "glPixelMapfv",
            .pixelMapuiv => "glPixelMapuiv",
            .pixelMapusv => "glPixelMapusv",
            .copyPixels => "glCopyPixels",
            .drawPixels => "glDrawPixels",
            .getClipPlane => "glGetClipPlane",
            .getLightfv => "glGetLightfv",
            .getLightiv => "glGetLightiv",
            .getMapdv => "glGetMapdv",
            .getMapfv => "glGetMapfv",
            .getMapiv => "glGetMapiv",
            .getMaterialfv => "glGetMaterialfv",
            .getMaterialiv => "glGetMaterialiv",
            .getPixelMapfv => "glGetPixelMapfv",
            .getPixelMapuiv => "glGetPixelMapuiv",
            .getPixelMapusv => "glGetPixelMapusv",
            .getPolygonStipple => "glGetPolygonStipple",
            .getTexEnvfv => "glGetTexEnvfv",
            .getTexEnviv => "glGetTexEnviv",
            .getTexGendv => "glGetTexGendv",
            .getTexGenfv => "glGetTexGenfv",
            .getTexGeniv => "glGetTexGeniv",
            .isList => "glIsList",
            .frustum => "glFrustum",
            .loadIdentity => "glLoadIdentity",
            .loadMatrixf => "glLoadMatrixf",
            .loadMatrixd => "glLoadMatrixd",
            .matrixMode => "glMatrixMode",
            .multMatrixf => "glMultMatrixf",
            .multMatrixd => "glMultMatrixd",
            .ortho => "glOrtho",
            .popMatrix => "glPopMatrix",
            .pushMatrix => "glPushMatrix",
            .rotated => "glRotated",
            .rotatef => "glRotatef",
            .scaled => "glScaled",
            .scalef => "glScalef",
            .translated => "glTranslated",
            .translatef => "glTranslatef",
            .drawArrays => "glDrawArrays",
            .drawElements => "glDrawElements",
            .getPointerv => "glGetPointerv",
            .polygonOffset => "glPolygonOffset",
            .copyTexImage1D => "glCopyTexImage1D",
            .copyTexImage2D => "glCopyTexImage2D",
            .copyTexSubImage1D => "glCopyTexSubImage1D",
            .copyTexSubImage2D => "glCopyTexSubImage2D",
            .texSubImage1D => "glTexSubImage1D",
            .texSubImage2D => "glTexSubImage2D",
            .bindTexture => "glBindTexture",
            .deleteTextures => "glDeleteTextures",
            .genTextures => "glGenTextures",
            .isTexture => "glIsTexture",
            .arrayElement => "glArrayElement",
            .colorPointer => "glColorPointer",
            .disableClientState => "glDisableClientState",
            .edgeFlagPointer => "glEdgeFlagPointer",
            .enableClientState => "glEnableClientState",
            .indexPointer => "glIndexPointer",
            .interleavedArrays => "glInterleavedArrays",
            .normalPointer => "glNormalPointer",
            .texCoordPointer => "glTexCoordPointer",
            .vertexPointer => "glVertexPointer",
            .areTexturesResident => "glAreTexturesResident",
            .prioritizeTextures => "glPrioritizeTextures",
            .indexub => "glIndexub",
            .indexubv => "glIndexubv",
            .popClientAttrib => "glPopClientAttrib",
            .pushClientAttrib => "glPushClientAttrib",
            .drawRangeElements => "glDrawRangeElements",
            .texImage3D => "glTexImage3D",
            .texSubImage3D => "glTexSubImage3D",
            .copyTexSubImage3D => "glCopyTexSubImage3D",
            .activeTexture => "glActiveTexture",
            .sampleCoverage => "glSampleCoverage",
            .compressedTexImage3D => "glCompressedTexImage3D",
            .compressedTexImage2D => "glCompressedTexImage2D",
            .compressedTexImage1D => "glCompressedTexImage1D",
            .compressedTexSubImage3D => "glCompressedTexSubImage3D",
            .compressedTexSubImage2D => "glCompressedTexSubImage2D",
            .compressedTexSubImage1D => "glCompressedTexSubImage1D",
            .getCompressedTexImage => "glGetCompressedTexImage",
            .clientActiveTexture => "glClientActiveTexture",
            .multiTexCoord1d => "glMultiTexCoord1d",
            .multiTexCoord1dv => "glMultiTexCoord1dv",
            .multiTexCoord1f => "glMultiTexCoord1f",
            .multiTexCoord1fv => "glMultiTexCoord1fv",
            .multiTexCoord1i => "glMultiTexCoord1i",
            .multiTexCoord1iv => "glMultiTexCoord1iv",
            .multiTexCoord1s => "glMultiTexCoord1s",
            .multiTexCoord1sv => "glMultiTexCoord1sv",
            .multiTexCoord2d => "glMultiTexCoord2d",
            .multiTexCoord2dv => "glMultiTexCoord2dv",
            .multiTexCoord2f => "glMultiTexCoord2f",
            .multiTexCoord2fv => "glMultiTexCoord2fv",
            .multiTexCoord2i => "glMultiTexCoord2i",
            .multiTexCoord2iv => "glMultiTexCoord2iv",
            .multiTexCoord2s => "glMultiTexCoord2s",
            .multiTexCoord2sv => "glMultiTexCoord2sv",
            .multiTexCoord3d => "glMultiTexCoord3d",
            .multiTexCoord3dv => "glMultiTexCoord3dv",
            .multiTexCoord3f => "glMultiTexCoord3f",
            .multiTexCoord3fv => "glMultiTexCoord3fv",
            .multiTexCoord3i => "glMultiTexCoord3i",
            .multiTexCoord3iv => "glMultiTexCoord3iv",
            .multiTexCoord3s => "glMultiTexCoord3s",
            .multiTexCoord3sv => "glMultiTexCoord3sv",
            .multiTexCoord4d => "glMultiTexCoord4d",
            .multiTexCoord4dv => "glMultiTexCoord4dv",
            .multiTexCoord4f => "glMultiTexCoord4f",
            .multiTexCoord4fv => "glMultiTexCoord4fv",
            .multiTexCoord4i => "glMultiTexCoord4i",
            .multiTexCoord4iv => "glMultiTexCoord4iv",
            .multiTexCoord4s => "glMultiTexCoord4s",
            .multiTexCoord4sv => "glMultiTexCoord4sv",
            .loadTransposeMatrixf => "glLoadTransposeMatrixf",
            .loadTransposeMatrixd => "glLoadTransposeMatrixd",
            .multTransposeMatrixf => "glMultTransposeMatrixf",
            .multTransposeMatrixd => "glMultTransposeMatrixd",
            .blendFuncSeparate => "glBlendFuncSeparate",
            .multiDrawArrays => "glMultiDrawArrays",
            .multiDrawElements => "glMultiDrawElements",
            .pointParameterf => "glPointParameterf",
            .pointParameterfv => "glPointParameterfv",
            .pointParameteri => "glPointParameteri",
            .pointParameteriv => "glPointParameteriv",
            .fogCoordf => "glFogCoordf",
            .fogCoordfv => "glFogCoordfv",
            .fogCoordd => "glFogCoordd",
            .fogCoorddv => "glFogCoorddv",
            .fogCoordPointer => "glFogCoordPointer",
            .secondaryColor3b => "glSecondaryColor3b",
            .secondaryColor3bv => "glSecondaryColor3bv",
            .secondaryColor3d => "glSecondaryColor3d",
            .secondaryColor3dv => "glSecondaryColor3dv",
            .secondaryColor3f => "glSecondaryColor3f",
            .secondaryColor3fv => "glSecondaryColor3fv",
            .secondaryColor3i => "glSecondaryColor3i",
            .secondaryColor3iv => "glSecondaryColor3iv",
            .secondaryColor3s => "glSecondaryColor3s",
            .secondaryColor3sv => "glSecondaryColor3sv",
            .secondaryColor3ub => "glSecondaryColor3ub",
            .secondaryColor3ubv => "glSecondaryColor3ubv",
            .secondaryColor3ui => "glSecondaryColor3ui",
            .secondaryColor3uiv => "glSecondaryColor3uiv",
            .secondaryColor3us => "glSecondaryColor3us",
            .secondaryColor3usv => "glSecondaryColor3usv",
            .secondaryColorPointer => "glSecondaryColorPointer",
            .windowPos2d => "glWindowPos2d",
            .windowPos2dv => "glWindowPos2dv",
            .windowPos2f => "glWindowPos2f",
            .windowPos2fv => "glWindowPos2fv",
            .windowPos2i => "glWindowPos2i",
            .windowPos2iv => "glWindowPos2iv",
            .windowPos2s => "glWindowPos2s",
            .windowPos2sv => "glWindowPos2sv",
            .windowPos3d => "glWindowPos3d",
            .windowPos3dv => "glWindowPos3dv",
            .windowPos3f => "glWindowPos3f",
            .windowPos3fv => "glWindowPos3fv",
            .windowPos3i => "glWindowPos3i",
            .windowPos3iv => "glWindowPos3iv",
            .windowPos3s => "glWindowPos3s",
            .windowPos3sv => "glWindowPos3sv",
            .blendColor => "glBlendColor",
            .blendEquation => "glBlendEquation",
            .genQueries => "glGenQueries",
            .deleteQueries => "glDeleteQueries",
            .isQuery => "glIsQuery",
            .beginQuery => "glBeginQuery",
            .endQuery => "glEndQuery",
            .getQueryiv => "glGetQueryiv",
            .getQueryObjectiv => "glGetQueryObjectiv",
            .getQueryObjectuiv => "glGetQueryObjectuiv",
            .bindBuffer => "glBindBuffer",
            .deleteBuffers => "glDeleteBuffers",
            .genBuffers => "glGenBuffers",
            .isBuffer => "glIsBuffer",
            .bufferData => "glBufferData",
            .bufferSubData => "glBufferSubData",
            .getBufferSubData => "glGetBufferSubData",
            .mapBuffer => "glMapBuffer",
            .unmapBuffer => "glUnmapBuffer",
            .getBufferParameteriv => "glGetBufferParameteriv",
            .getBufferPointerv => "glGetBufferPointerv",
            .blendEquationSeparate => "glBlendEquationSeparate",
            .drawBuffers => "glDrawBuffers",
            .stencilOpSeparate => "glStencilOpSeparate",
            .stencilFuncSeparate => "glStencilFuncSeparate",
            .stencilMaskSeparate => "glStencilMaskSeparate",
            .attachShader => "glAttachShader",
            .bindAttribLocation => "glBindAttribLocation",
            .compileShader => "glCompileShader",
            .createProgram => "glCreateProgram",
            .createShader => "glCreateShader",
            .deleteProgram => "glDeleteProgram",
            .deleteShader => "glDeleteShader",
            .detachShader => "glDetachShader",
            .disableVertexAttribArray => "glDisableVertexAttribArray",
            .enableVertexAttribArray => "glEnableVertexAttribArray",
            .getActiveAttrib => "glGetActiveAttrib",
            .getActiveUniform => "glGetActiveUniform",
            .getAttachedShaders => "glGetAttachedShaders",
            .getAttribLocation => "glGetAttribLocation",
            .getProgramiv => "glGetProgramiv",
            .getProgramInfoLog => "glGetProgramInfoLog",
            .getShaderiv => "glGetShaderiv",
            .getShaderInfoLog => "glGetShaderInfoLog",
            .getShaderSource => "glGetShaderSource",
            .getUniformLocation => "glGetUniformLocation",
            .getUniformfv => "glGetUniformfv",
            .getUniformiv => "glGetUniformiv",
            .getVertexAttribdv => "glGetVertexAttribdv",
            .getVertexAttribfv => "glGetVertexAttribfv",
            .getVertexAttribiv => "glGetVertexAttribiv",
            .getVertexAttribPointerv => "glGetVertexAttribPointerv",
            .isProgram => "glIsProgram",
            .isShader => "glIsShader",
            .linkProgram => "glLinkProgram",
            .shaderSource => "glShaderSource",
            .useProgram => "glUseProgram",
            .uniform1f => "glUniform1f",
            .uniform2f => "glUniform2f",
            .uniform3f => "glUniform3f",
            .uniform4f => "glUniform4f",
            .uniform1i => "glUniform1i",
            .uniform2i => "glUniform2i",
            .uniform3i => "glUniform3i",
            .uniform4i => "glUniform4i",
            .uniform1fv => "glUniform1fv",
            .uniform2fv => "glUniform2fv",
            .uniform3fv => "glUniform3fv",
            .uniform4fv => "glUniform4fv",
            .uniform1iv => "glUniform1iv",
            .uniform2iv => "glUniform2iv",
            .uniform3iv => "glUniform3iv",
            .uniform4iv => "glUniform4iv",
            .uniformMatrix2fv => "glUniformMatrix2fv",
            .uniformMatrix3fv => "glUniformMatrix3fv",
            .uniformMatrix4fv => "glUniformMatrix4fv",
            .validateProgram => "glValidateProgram",
            .vertexAttrib1d => "glVertexAttrib1d",
            .vertexAttrib1dv => "glVertexAttrib1dv",
            .vertexAttrib1f => "glVertexAttrib1f",
            .vertexAttrib1fv => "glVertexAttrib1fv",
            .vertexAttrib1s => "glVertexAttrib1s",
            .vertexAttrib1sv => "glVertexAttrib1sv",
            .vertexAttrib2d => "glVertexAttrib2d",
            .vertexAttrib2dv => "glVertexAttrib2dv",
            .vertexAttrib2f => "glVertexAttrib2f",
            .vertexAttrib2fv => "glVertexAttrib2fv",
            .vertexAttrib2s => "glVertexAttrib2s",
            .vertexAttrib2sv => "glVertexAttrib2sv",
            .vertexAttrib3d => "glVertexAttrib3d",
            .vertexAttrib3dv => "glVertexAttrib3dv",
            .vertexAttrib3f => "glVertexAttrib3f",
            .vertexAttrib3fv => "glVertexAttrib3fv",
            .vertexAttrib3s => "glVertexAttrib3s",
            .vertexAttrib3sv => "glVertexAttrib3sv",
            .vertexAttrib4Nbv => "glVertexAttrib4Nbv",
            .vertexAttrib4Niv => "glVertexAttrib4Niv",
            .vertexAttrib4Nsv => "glVertexAttrib4Nsv",
            .vertexAttrib4Nub => "glVertexAttrib4Nub",
            .vertexAttrib4Nubv => "glVertexAttrib4Nubv",
            .vertexAttrib4Nuiv => "glVertexAttrib4Nuiv",
            .vertexAttrib4Nusv => "glVertexAttrib4Nusv",
            .vertexAttrib4bv => "glVertexAttrib4bv",
            .vertexAttrib4d => "glVertexAttrib4d",
            .vertexAttrib4dv => "glVertexAttrib4dv",
            .vertexAttrib4f => "glVertexAttrib4f",
            .vertexAttrib4fv => "glVertexAttrib4fv",
            .vertexAttrib4iv => "glVertexAttrib4iv",
            .vertexAttrib4s => "glVertexAttrib4s",
            .vertexAttrib4sv => "glVertexAttrib4sv",
            .vertexAttrib4ubv => "glVertexAttrib4ubv",
            .vertexAttrib4uiv => "glVertexAttrib4uiv",
            .vertexAttrib4usv => "glVertexAttrib4usv",
            .vertexAttribPointer => "glVertexAttribPointer",
            .uniformMatrix2x3fv => "glUniformMatrix2x3fv",
            .uniformMatrix3x2fv => "glUniformMatrix3x2fv",
            .uniformMatrix2x4fv => "glUniformMatrix2x4fv",
            .uniformMatrix4x2fv => "glUniformMatrix4x2fv",
            .uniformMatrix3x4fv => "glUniformMatrix3x4fv",
            .uniformMatrix4x3fv => "glUniformMatrix4x3fv",
            .colorMaski => "glColorMaski",
            .getBooleani_v => "glGetBooleani_v",
            .getIntegeri_v => "glGetIntegeri_v",
            .enablei => "glEnablei",
            .disablei => "glDisablei",
            .isEnabledi => "glIsEnabledi",
            .beginTransformFeedback => "glBeginTransformFeedback",
            .endTransformFeedback => "glEndTransformFeedback",
            .bindBufferRange => "glBindBufferRange",
            .bindBufferBase => "glBindBufferBase",
            .transformFeedbackVaryings => "glTransformFeedbackVaryings",
            .getTransformFeedbackVarying => "glGetTransformFeedbackVarying",
            .clampColor => "glClampColor",
            .beginConditionalRender => "glBeginConditionalRender",
            .endConditionalRender => "glEndConditionalRender",
            .vertexAttribIPointer => "glVertexAttribIPointer",
            .getVertexAttribIiv => "glGetVertexAttribIiv",
            .getVertexAttribIuiv => "glGetVertexAttribIuiv",
            .vertexAttribI1i => "glVertexAttribI1i",
            .vertexAttribI2i => "glVertexAttribI2i",
            .vertexAttribI3i => "glVertexAttribI3i",
            .vertexAttribI4i => "glVertexAttribI4i",
            .vertexAttribI1ui => "glVertexAttribI1ui",
            .vertexAttribI2ui => "glVertexAttribI2ui",
            .vertexAttribI3ui => "glVertexAttribI3ui",
            .vertexAttribI4ui => "glVertexAttribI4ui",
            .vertexAttribI1iv => "glVertexAttribI1iv",
            .vertexAttribI2iv => "glVertexAttribI2iv",
            .vertexAttribI3iv => "glVertexAttribI3iv",
            .vertexAttribI4iv => "glVertexAttribI4iv",
            .vertexAttribI1uiv => "glVertexAttribI1uiv",
            .vertexAttribI2uiv => "glVertexAttribI2uiv",
            .vertexAttribI3uiv => "glVertexAttribI3uiv",
            .vertexAttribI4uiv => "glVertexAttribI4uiv",
            .vertexAttribI4bv => "glVertexAttribI4bv",
            .vertexAttribI4sv => "glVertexAttribI4sv",
            .vertexAttribI4ubv => "glVertexAttribI4ubv",
            .vertexAttribI4usv => "glVertexAttribI4usv",
            .getUniformuiv => "glGetUniformuiv",
            .bindFragDataLocation => "glBindFragDataLocation",
            .getFragDataLocation => "glGetFragDataLocation",
            .uniform1ui => "glUniform1ui",
            .uniform2ui => "glUniform2ui",
            .uniform3ui => "glUniform3ui",
            .uniform4ui => "glUniform4ui",
            .uniform1uiv => "glUniform1uiv",
            .uniform2uiv => "glUniform2uiv",
            .uniform3uiv => "glUniform3uiv",
            .uniform4uiv => "glUniform4uiv",
            .texParameterIiv => "glTexParameterIiv",
            .texParameterIuiv => "glTexParameterIuiv",
            .getTexParameterIiv => "glGetTexParameterIiv",
            .getTexParameterIuiv => "glGetTexParameterIuiv",
            .clearBufferiv => "glClearBufferiv",
            .clearBufferuiv => "glClearBufferuiv",
            .clearBufferfv => "glClearBufferfv",
            .clearBufferfi => "glClearBufferfi",
            .getStringi => "glGetStringi",
            .isRenderbuffer => "glIsRenderbuffer",
            .bindRenderbuffer => "glBindRenderbuffer",
            .deleteRenderbuffers => "glDeleteRenderbuffers",
            .genRenderbuffers => "glGenRenderbuffers",
            .renderbufferStorage => "glRenderbufferStorage",
            .getRenderbufferParameteriv => "glGetRenderbufferParameteriv",
            .isFramebuffer => "glIsFramebuffer",
            .bindFramebuffer => "glBindFramebuffer",
            .deleteFramebuffers => "glDeleteFramebuffers",
            .genFramebuffers => "glGenFramebuffers",
            .checkFramebufferStatus => "glCheckFramebufferStatus",
            .framebufferTexture1D => "glFramebufferTexture1D",
            .framebufferTexture2D => "glFramebufferTexture2D",
            .framebufferTexture3D => "glFramebufferTexture3D",
            .framebufferRenderbuffer => "glFramebufferRenderbuffer",
            .getFramebufferAttachmentParameteriv => "glGetFramebufferAttachmentParameteriv",
            .generateMipmap => "glGenerateMipmap",
            .blitFramebuffer => "glBlitFramebuffer",
            .renderbufferStorageMultisample => "glRenderbufferStorageMultisample",
            .framebufferTextureLayer => "glFramebufferTextureLayer",
            .mapBufferRange => "glMapBufferRange",
            .flushMappedBufferRange => "glFlushMappedBufferRange",
            .bindVertexArray => "glBindVertexArray",
            .deleteVertexArrays => "glDeleteVertexArrays",
            .genVertexArrays => "glGenVertexArrays",
            .isVertexArray => "glIsVertexArray",
            .drawArraysInstanced => "glDrawArraysInstanced",
            .drawElementsInstanced => "glDrawElementsInstanced",
            .texBuffer => "glTexBuffer",
            .primitiveRestartIndex => "glPrimitiveRestartIndex",
            .copyBufferSubData => "glCopyBufferSubData",
            .getUniformIndices => "glGetUniformIndices",
            .getActiveUniformsiv => "glGetActiveUniformsiv",
            .getActiveUniformName => "glGetActiveUniformName",
            .getUniformBlockIndex => "glGetUniformBlockIndex",
            .getActiveUniformBlockiv => "glGetActiveUniformBlockiv",
            .getActiveUniformBlockName => "glGetActiveUniformBlockName",
            .uniformBlockBinding => "glUniformBlockBinding",
            .drawElementsBaseVertex => "glDrawElementsBaseVertex",
            .drawRangeElementsBaseVertex => "glDrawRangeElementsBaseVertex",
            .drawElementsInstancedBaseVertex => "glDrawElementsInstancedBaseVertex",
            .multiDrawElementsBaseVertex => "glMultiDrawElementsBaseVertex",
            .provokingVertex => "glProvokingVertex",
            .fenceSync => "glFenceSync",
            .isSync => "glIsSync",
            .deleteSync => "glDeleteSync",
            .clientWaitSync => "glClientWaitSync",
            .waitSync => "glWaitSync",
            .getInteger64v => "glGetInteger64v",
            .getSynciv => "glGetSynciv",
            .getInteger64i_v => "glGetInteger64i_v",
            .getBufferParameteri64v => "glGetBufferParameteri64v",
            .framebufferTexture => "glFramebufferTexture",
            .texImage2DMultisample => "glTexImage2DMultisample",
            .texImage3DMultisample => "glTexImage3DMultisample",
            .getMultisamplefv => "glGetMultisamplefv",
            .sampleMaski => "glSampleMaski",
            .bindFragDataLocationIndexed => "glBindFragDataLocationIndexed",
            .getFragDataIndex => "glGetFragDataIndex",
            .genSamplers => "glGenSamplers",
            .deleteSamplers => "glDeleteSamplers",
            .isSampler => "glIsSampler",
            .bindSampler => "glBindSampler",
            .samplerParameteri => "glSamplerParameteri",
            .samplerParameteriv => "glSamplerParameteriv",
            .samplerParameterf => "glSamplerParameterf",
            .samplerParameterfv => "glSamplerParameterfv",
            .samplerParameterIiv => "glSamplerParameterIiv",
            .samplerParameterIuiv => "glSamplerParameterIuiv",
            .getSamplerParameteriv => "glGetSamplerParameteriv",
            .getSamplerParameterIiv => "glGetSamplerParameterIiv",
            .getSamplerParameterfv => "glGetSamplerParameterfv",
            .getSamplerParameterIuiv => "glGetSamplerParameterIuiv",
            .queryCounter => "glQueryCounter",
            .getQueryObjecti64v => "glGetQueryObjecti64v",
            .getQueryObjectui64v => "glGetQueryObjectui64v",
            .vertexAttribDivisor => "glVertexAttribDivisor",
            .vertexAttribP1ui => "glVertexAttribP1ui",
            .vertexAttribP1uiv => "glVertexAttribP1uiv",
            .vertexAttribP2ui => "glVertexAttribP2ui",
            .vertexAttribP2uiv => "glVertexAttribP2uiv",
            .vertexAttribP3ui => "glVertexAttribP3ui",
            .vertexAttribP3uiv => "glVertexAttribP3uiv",
            .vertexAttribP4ui => "glVertexAttribP4ui",
            .vertexAttribP4uiv => "glVertexAttribP4uiv",
            .vertexP2ui => "glVertexP2ui",
            .vertexP2uiv => "glVertexP2uiv",
            .vertexP3ui => "glVertexP3ui",
            .vertexP3uiv => "glVertexP3uiv",
            .vertexP4ui => "glVertexP4ui",
            .vertexP4uiv => "glVertexP4uiv",
            .texCoordP1ui => "glTexCoordP1ui",
            .texCoordP1uiv => "glTexCoordP1uiv",
            .texCoordP2ui => "glTexCoordP2ui",
            .texCoordP2uiv => "glTexCoordP2uiv",
            .texCoordP3ui => "glTexCoordP3ui",
            .texCoordP3uiv => "glTexCoordP3uiv",
            .texCoordP4ui => "glTexCoordP4ui",
            .texCoordP4uiv => "glTexCoordP4uiv",
            .multiTexCoordP1ui => "glMultiTexCoordP1ui",
            .multiTexCoordP1uiv => "glMultiTexCoordP1uiv",
            .multiTexCoordP2ui => "glMultiTexCoordP2ui",
            .multiTexCoordP2uiv => "glMultiTexCoordP2uiv",
            .multiTexCoordP3ui => "glMultiTexCoordP3ui",
            .multiTexCoordP3uiv => "glMultiTexCoordP3uiv",
            .multiTexCoordP4ui => "glMultiTexCoordP4ui",
            .multiTexCoordP4uiv => "glMultiTexCoordP4uiv",
            .normalP3ui => "glNormalP3ui",
            .normalP3uiv => "glNormalP3uiv",
            .colorP3ui => "glColorP3ui",
            .colorP3uiv => "glColorP3uiv",
            .colorP4ui => "glColorP4ui",
            .colorP4uiv => "glColorP4uiv",
            .secondaryColorP3ui => "glSecondaryColorP3ui",
            .secondaryColorP3uiv => "glSecondaryColorP3uiv",
            .minSampleShading => "glMinSampleShading",
            .blendEquationi => "glBlendEquationi",
            .blendEquationSeparatei => "glBlendEquationSeparatei",
            .blendFunci => "glBlendFunci",
            .blendFuncSeparatei => "glBlendFuncSeparatei",
            .drawArraysIndirect => "glDrawArraysIndirect",
            .drawElementsIndirect => "glDrawElementsIndirect",
            .uniform1d => "glUniform1d",
            .uniform2d => "glUniform2d",
            .uniform3d => "glUniform3d",
            .uniform4d => "glUniform4d",
            .uniform1dv => "glUniform1dv",
            .uniform2dv => "glUniform2dv",
            .uniform3dv => "glUniform3dv",
            .uniform4dv => "glUniform4dv",
            .uniformMatrix2dv => "glUniformMatrix2dv",
            .uniformMatrix3dv => "glUniformMatrix3dv",
            .uniformMatrix4dv => "glUniformMatrix4dv",
            .uniformMatrix2x3dv => "glUniformMatrix2x3dv",
            .uniformMatrix2x4dv => "glUniformMatrix2x4dv",
            .uniformMatrix3x2dv => "glUniformMatrix3x2dv",
            .uniformMatrix3x4dv => "glUniformMatrix3x4dv",
            .uniformMatrix4x2dv => "glUniformMatrix4x2dv",
            .uniformMatrix4x3dv => "glUniformMatrix4x3dv",
            .getUniformdv => "glGetUniformdv",
            .getSubroutineUniformLocation => "glGetSubroutineUniformLocation",
            .getSubroutineIndex => "glGetSubroutineIndex",
            .getActiveSubroutineUniformiv => "glGetActiveSubroutineUniformiv",
            .getActiveSubroutineUniformName => "glGetActiveSubroutineUniformName",
            .getActiveSubroutineName => "glGetActiveSubroutineName",
            .uniformSubroutinesuiv => "glUniformSubroutinesuiv",
            .getUniformSubroutineuiv => "glGetUniformSubroutineuiv",
            .getProgramStageiv => "glGetProgramStageiv",
            .patchParameteri => "glPatchParameteri",
            .patchParameterfv => "glPatchParameterfv",
            .bindTransformFeedback => "glBindTransformFeedback",
            .deleteTransformFeedbacks => "glDeleteTransformFeedbacks",
            .genTransformFeedbacks => "glGenTransformFeedbacks",
            .isTransformFeedback => "glIsTransformFeedback",
            .pauseTransformFeedback => "glPauseTransformFeedback",
            .resumeTransformFeedback => "glResumeTransformFeedback",
            .drawTransformFeedback => "glDrawTransformFeedback",
            .drawTransformFeedbackStream => "glDrawTransformFeedbackStream",
            .beginQueryIndexed => "glBeginQueryIndexed",
            .endQueryIndexed => "glEndQueryIndexed",
            .getQueryIndexediv => "glGetQueryIndexediv",
            .releaseShaderCompiler => "glReleaseShaderCompiler",
            .shaderBinary => "glShaderBinary",
            .getShaderPrecisionFormat => "glGetShaderPrecisionFormat",
            .depthRangef => "glDepthRangef",
            .clearDepthf => "glClearDepthf",
            .getProgramBinary => "glGetProgramBinary",
            .programBinary => "glProgramBinary",
            .programParameteri => "glProgramParameteri",
            .useProgramStages => "glUseProgramStages",
            .activeShaderProgram => "glActiveShaderProgram",
            .createShaderProgramv => "glCreateShaderProgramv",
            .bindProgramPipeline => "glBindProgramPipeline",
            .deleteProgramPipelines => "glDeleteProgramPipelines",
            .genProgramPipelines => "glGenProgramPipelines",
            .isProgramPipeline => "glIsProgramPipeline",
            .getProgramPipelineiv => "glGetProgramPipelineiv",
            .programUniform1i => "glProgramUniform1i",
            .programUniform1iv => "glProgramUniform1iv",
            .programUniform1f => "glProgramUniform1f",
            .programUniform1fv => "glProgramUniform1fv",
            .programUniform1d => "glProgramUniform1d",
            .programUniform1dv => "glProgramUniform1dv",
            .programUniform1ui => "glProgramUniform1ui",
            .programUniform1uiv => "glProgramUniform1uiv",
            .programUniform2i => "glProgramUniform2i",
            .programUniform2iv => "glProgramUniform2iv",
            .programUniform2f => "glProgramUniform2f",
            .programUniform2fv => "glProgramUniform2fv",
            .programUniform2d => "glProgramUniform2d",
            .programUniform2dv => "glProgramUniform2dv",
            .programUniform2ui => "glProgramUniform2ui",
            .programUniform2uiv => "glProgramUniform2uiv",
            .programUniform3i => "glProgramUniform3i",
            .programUniform3iv => "glProgramUniform3iv",
            .programUniform3f => "glProgramUniform3f",
            .programUniform3fv => "glProgramUniform3fv",
            .programUniform3d => "glProgramUniform3d",
            .programUniform3dv => "glProgramUniform3dv",
            .programUniform3ui => "glProgramUniform3ui",
            .programUniform3uiv => "glProgramUniform3uiv",
            .programUniform4i => "glProgramUniform4i",
            .programUniform4iv => "glProgramUniform4iv",
            .programUniform4f => "glProgramUniform4f",
            .programUniform4fv => "glProgramUniform4fv",
            .programUniform4d => "glProgramUniform4d",
            .programUniform4dv => "glProgramUniform4dv",
            .programUniform4ui => "glProgramUniform4ui",
            .programUniform4uiv => "glProgramUniform4uiv",
            .programUniformMatrix2fv => "glProgramUniformMatrix2fv",
            .programUniformMatrix3fv => "glProgramUniformMatrix3fv",
            .programUniformMatrix4fv => "glProgramUniformMatrix4fv",
            .programUniformMatrix2dv => "glProgramUniformMatrix2dv",
            .programUniformMatrix3dv => "glProgramUniformMatrix3dv",
            .programUniformMatrix4dv => "glProgramUniformMatrix4dv",
            .programUniformMatrix2x3fv => "glProgramUniformMatrix2x3fv",
            .programUniformMatrix3x2fv => "glProgramUniformMatrix3x2fv",
            .programUniformMatrix2x4fv => "glProgramUniformMatrix2x4fv",
            .programUniformMatrix4x2fv => "glProgramUniformMatrix4x2fv",
            .programUniformMatrix3x4fv => "glProgramUniformMatrix3x4fv",
            .programUniformMatrix4x3fv => "glProgramUniformMatrix4x3fv",
            .programUniformMatrix2x3dv => "glProgramUniformMatrix2x3dv",
            .programUniformMatrix3x2dv => "glProgramUniformMatrix3x2dv",
            .programUniformMatrix2x4dv => "glProgramUniformMatrix2x4dv",
            .programUniformMatrix4x2dv => "glProgramUniformMatrix4x2dv",
            .programUniformMatrix3x4dv => "glProgramUniformMatrix3x4dv",
            .programUniformMatrix4x3dv => "glProgramUniformMatrix4x3dv",
            .validateProgramPipeline => "glValidateProgramPipeline",
            .getProgramPipelineInfoLog => "glGetProgramPipelineInfoLog",
            .vertexAttribL1d => "glVertexAttribL1d",
            .vertexAttribL2d => "glVertexAttribL2d",
            .vertexAttribL3d => "glVertexAttribL3d",
            .vertexAttribL4d => "glVertexAttribL4d",
            .vertexAttribL1dv => "glVertexAttribL1dv",
            .vertexAttribL2dv => "glVertexAttribL2dv",
            .vertexAttribL3dv => "glVertexAttribL3dv",
            .vertexAttribL4dv => "glVertexAttribL4dv",
            .vertexAttribLPointer => "glVertexAttribLPointer",
            .getVertexAttribLdv => "glGetVertexAttribLdv",
            .viewportArrayv => "glViewportArrayv",
            .viewportIndexedf => "glViewportIndexedf",
            .viewportIndexedfv => "glViewportIndexedfv",
            .scissorArrayv => "glScissorArrayv",
            .scissorIndexed => "glScissorIndexed",
            .scissorIndexedv => "glScissorIndexedv",
            .depthRangeArrayv => "glDepthRangeArrayv",
            .depthRangeIndexed => "glDepthRangeIndexed",
            .getFloati_v => "glGetFloati_v",
            .getDoublei_v => "glGetDoublei_v",
            .drawArraysInstancedBaseInstance => "glDrawArraysInstancedBaseInstance",
            .drawElementsInstancedBaseInstance => "glDrawElementsInstancedBaseInstance",
            .drawElementsInstancedBaseVertexBaseInstance => "glDrawElementsInstancedBaseVertexBaseInstance",
            .getInternalformativ => "glGetInternalformativ",
            .getActiveAtomicCounterBufferiv => "glGetActiveAtomicCounterBufferiv",
            .bindImageTexture => "glBindImageTexture",
            .memoryBarrier => "glMemoryBarrier",
            .texStorage1D => "glTexStorage1D",
            .texStorage2D => "glTexStorage2D",
            .texStorage3D => "glTexStorage3D",
            .drawTransformFeedbackInstanced => "glDrawTransformFeedbackInstanced",
            .drawTransformFeedbackStreamInstanced => "glDrawTransformFeedbackStreamInstanced",
            .clearBufferData => "glClearBufferData",
            .clearBufferSubData => "glClearBufferSubData",
            .dispatchCompute => "glDispatchCompute",
            .dispatchComputeIndirect => "glDispatchComputeIndirect",
            .copyImageSubData => "glCopyImageSubData",
            .framebufferParameteri => "glFramebufferParameteri",
            .getFramebufferParameteriv => "glGetFramebufferParameteriv",
            .getInternalformati64v => "glGetInternalformati64v",
            .invalidateTexSubImage => "glInvalidateTexSubImage",
            .invalidateTexImage => "glInvalidateTexImage",
            .invalidateBufferSubData => "glInvalidateBufferSubData",
            .invalidateBufferData => "glInvalidateBufferData",
            .invalidateFramebuffer => "glInvalidateFramebuffer",
            .invalidateSubFramebuffer => "glInvalidateSubFramebuffer",
            .multiDrawArraysIndirect => "glMultiDrawArraysIndirect",
            .multiDrawElementsIndirect => "glMultiDrawElementsIndirect",
            .getProgramInterfaceiv => "glGetProgramInterfaceiv",
            .getProgramResourceIndex => "glGetProgramResourceIndex",
            .getProgramResourceName => "glGetProgramResourceName",
            .getProgramResourceiv => "glGetProgramResourceiv",
            .getProgramResourceLocation => "glGetProgramResourceLocation",
            .getProgramResourceLocationIndex => "glGetProgramResourceLocationIndex",
            .shaderStorageBlockBinding => "glShaderStorageBlockBinding",
            .texBufferRange => "glTexBufferRange",
            .texStorage2DMultisample => "glTexStorage2DMultisample",
            .texStorage3DMultisample => "glTexStorage3DMultisample",
            .textureView => "glTextureView",
            .bindVertexBuffer => "glBindVertexBuffer",
            .vertexAttribFormat => "glVertexAttribFormat",
            .vertexAttribIFormat => "glVertexAttribIFormat",
            .vertexAttribLFormat => "glVertexAttribLFormat",
            .vertexAttribBinding => "glVertexAttribBinding",
            .vertexBindingDivisor => "glVertexBindingDivisor",
            .debugMessageControl => "glDebugMessageControl",
            .debugMessageInsert => "glDebugMessageInsert",
            .debugMessageCallback => "glDebugMessageCallback",
            .getDebugMessageLog => "glGetDebugMessageLog",
            .pushDebugGroup => "glPushDebugGroup",
            .popDebugGroup => "glPopDebugGroup",
            .objectLabel => "glObjectLabel",
            .getObjectLabel => "glGetObjectLabel",
            .objectPtrLabel => "glObjectPtrLabel",
            .getObjectPtrLabel => "glGetObjectPtrLabel",
            .bufferStorage => "glBufferStorage",
            .clearTexImage => "glClearTexImage",
            .clearTexSubImage => "glClearTexSubImage",
            .bindBuffersBase => "glBindBuffersBase",
            .bindBuffersRange => "glBindBuffersRange",
            .bindTextures => "glBindTextures",
            .bindSamplers => "glBindSamplers",
            .bindImageTextures => "glBindImageTextures",
            .bindVertexBuffers => "glBindVertexBuffers",
            .clipControl => "glClipControl",
            .createTransformFeedbacks => "glCreateTransformFeedbacks",
            .transformFeedbackBufferBase => "glTransformFeedbackBufferBase",
            .transformFeedbackBufferRange => "glTransformFeedbackBufferRange",
            .getTransformFeedbackiv => "glGetTransformFeedbackiv",
            .getTransformFeedbacki_v => "glGetTransformFeedbacki_v",
            .getTransformFeedbacki64_v => "glGetTransformFeedbacki64_v",
            .createBuffers => "glCreateBuffers",
            .namedBufferStorage => "glNamedBufferStorage",
            .namedBufferData => "glNamedBufferData",
            .namedBufferSubData => "glNamedBufferSubData",
            .copyNamedBufferSubData => "glCopyNamedBufferSubData",
            .clearNamedBufferData => "glClearNamedBufferData",
            .clearNamedBufferSubData => "glClearNamedBufferSubData",
            .mapNamedBuffer => "glMapNamedBuffer",
            .mapNamedBufferRange => "glMapNamedBufferRange",
            .unmapNamedBuffer => "glUnmapNamedBuffer",
            .flushMappedNamedBufferRange => "glFlushMappedNamedBufferRange",
            .getNamedBufferParameteriv => "glGetNamedBufferParameteriv",
            .getNamedBufferParameteri64v => "glGetNamedBufferParameteri64v",
            .getNamedBufferPointerv => "glGetNamedBufferPointerv",
            .getNamedBufferSubData => "glGetNamedBufferSubData",
            .createFramebuffers => "glCreateFramebuffers",
            .namedFramebufferRenderbuffer => "glNamedFramebufferRenderbuffer",
            .namedFramebufferParameteri => "glNamedFramebufferParameteri",
            .namedFramebufferTexture => "glNamedFramebufferTexture",
            .namedFramebufferTextureLayer => "glNamedFramebufferTextureLayer",
            .namedFramebufferDrawBuffer => "glNamedFramebufferDrawBuffer",
            .namedFramebufferDrawBuffers => "glNamedFramebufferDrawBuffers",
            .namedFramebufferReadBuffer => "glNamedFramebufferReadBuffer",
            .invalidateNamedFramebufferData => "glInvalidateNamedFramebufferData",
            .invalidateNamedFramebufferSubData => "glInvalidateNamedFramebufferSubData",
            .clearNamedFramebufferiv => "glClearNamedFramebufferiv",
            .clearNamedFramebufferuiv => "glClearNamedFramebufferuiv",
            .clearNamedFramebufferfv => "glClearNamedFramebufferfv",
            .clearNamedFramebufferfi => "glClearNamedFramebufferfi",
            .blitNamedFramebuffer => "glBlitNamedFramebuffer",
            .checkNamedFramebufferStatus => "glCheckNamedFramebufferStatus",
            .getNamedFramebufferParameteriv => "glGetNamedFramebufferParameteriv",
            .getNamedFramebufferAttachmentParameteriv => "glGetNamedFramebufferAttachmentParameteriv",
            .createRenderbuffers => "glCreateRenderbuffers",
            .namedRenderbufferStorage => "glNamedRenderbufferStorage",
            .namedRenderbufferStorageMultisample => "glNamedRenderbufferStorageMultisample",
            .getNamedRenderbufferParameteriv => "glGetNamedRenderbufferParameteriv",
            .createTextures => "glCreateTextures",
            .textureBuffer => "glTextureBuffer",
            .textureBufferRange => "glTextureBufferRange",
            .textureStorage1D => "glTextureStorage1D",
            .textureStorage2D => "glTextureStorage2D",
            .textureStorage3D => "glTextureStorage3D",
            .textureStorage2DMultisample => "glTextureStorage2DMultisample",
            .textureStorage3DMultisample => "glTextureStorage3DMultisample",
            .textureSubImage1D => "glTextureSubImage1D",
            .textureSubImage2D => "glTextureSubImage2D",
            .textureSubImage3D => "glTextureSubImage3D",
            .compressedTextureSubImage1D => "glCompressedTextureSubImage1D",
            .compressedTextureSubImage2D => "glCompressedTextureSubImage2D",
            .compressedTextureSubImage3D => "glCompressedTextureSubImage3D",
            .copyTextureSubImage1D => "glCopyTextureSubImage1D",
            .copyTextureSubImage2D => "glCopyTextureSubImage2D",
            .copyTextureSubImage3D => "glCopyTextureSubImage3D",
            .textureParameterf => "glTextureParameterf",
            .textureParameterfv => "glTextureParameterfv",
            .textureParameteri => "glTextureParameteri",
            .textureParameterIiv => "glTextureParameterIiv",
            .textureParameterIuiv => "glTextureParameterIuiv",
            .textureParameteriv => "glTextureParameteriv",
            .generateTextureMipmap => "glGenerateTextureMipmap",
            .bindTextureUnit => "glBindTextureUnit",
            .getTextureImage => "glGetTextureImage",
            .getCompressedTextureImage => "glGetCompressedTextureImage",
            .getTextureLevelParameterfv => "glGetTextureLevelParameterfv",
            .getTextureLevelParameteriv => "glGetTextureLevelParameteriv",
            .getTextureParameterfv => "glGetTextureParameterfv",
            .getTextureParameterIiv => "glGetTextureParameterIiv",
            .getTextureParameterIuiv => "glGetTextureParameterIuiv",
            .getTextureParameteriv => "glGetTextureParameteriv",
            .createVertexArrays => "glCreateVertexArrays",
            .disableVertexArrayAttrib => "glDisableVertexArrayAttrib",
            .enableVertexArrayAttrib => "glEnableVertexArrayAttrib",
            .vertexArrayElementBuffer => "glVertexArrayElementBuffer",
            .vertexArrayVertexBuffer => "glVertexArrayVertexBuffer",
            .vertexArrayVertexBuffers => "glVertexArrayVertexBuffers",
            .vertexArrayAttribBinding => "glVertexArrayAttribBinding",
            .vertexArrayAttribFormat => "glVertexArrayAttribFormat",
            .vertexArrayAttribIFormat => "glVertexArrayAttribIFormat",
            .vertexArrayAttribLFormat => "glVertexArrayAttribLFormat",
            .vertexArrayBindingDivisor => "glVertexArrayBindingDivisor",
            .getVertexArrayiv => "glGetVertexArrayiv",
            .getVertexArrayIndexediv => "glGetVertexArrayIndexediv",
            .getVertexArrayIndexed64iv => "glGetVertexArrayIndexed64iv",
            .createSamplers => "glCreateSamplers",
            .createProgramPipelines => "glCreateProgramPipelines",
            .createQueries => "glCreateQueries",
            .getQueryBufferObjecti64v => "glGetQueryBufferObjecti64v",
            .getQueryBufferObjectiv => "glGetQueryBufferObjectiv",
            .getQueryBufferObjectui64v => "glGetQueryBufferObjectui64v",
            .getQueryBufferObjectuiv => "glGetQueryBufferObjectuiv",
            .memoryBarrierByRegion => "glMemoryBarrierByRegion",
            .getTextureSubImage => "glGetTextureSubImage",
            .getCompressedTextureSubImage => "glGetCompressedTextureSubImage",
            .getGraphicsResetStatus => "glGetGraphicsResetStatus",
            .getnCompressedTexImage => "glGetnCompressedTexImage",
            .getnTexImage => "glGetnTexImage",
            .getnUniformdv => "glGetnUniformdv",
            .getnUniformfv => "glGetnUniformfv",
            .getnUniformiv => "glGetnUniformiv",
            .getnUniformuiv => "glGetnUniformuiv",
            .readnPixels => "glReadnPixels",
            .getnMapdv => "glGetnMapdv",
            .getnMapfv => "glGetnMapfv",
            .getnMapiv => "glGetnMapiv",
            .getnPixelMapfv => "glGetnPixelMapfv",
            .getnPixelMapuiv => "glGetnPixelMapuiv",
            .getnPixelMapusv => "glGetnPixelMapusv",
            .getnPolygonStipple => "glGetnPolygonStipple",
            .getnColorTable => "glGetnColorTable",
            .getnConvolutionFilter => "glGetnConvolutionFilter",
            .getnSeparableFilter => "glGetnSeparableFilter",
            .getnHistogram => "glGetnHistogram",
            .getnMinmax => "glGetnMinmax",
            .textureBarrier => "glTextureBarrier",
            .specializeShader => "glSpecializeShader",
            .multiDrawArraysIndirectCount => "glMultiDrawArraysIndirectCount",
            .multiDrawElementsIndirectCount => "glMultiDrawElementsIndirectCount",
            .polygonOffsetClamp => "glPolygonOffsetClamp",
            .clipPlanef => "glClipPlanef",
            .frustumf => "glFrustumf",
            .getClipPlanef => "glGetClipPlanef",
            .orthof => "glOrthof",
            .alphaFuncx => "glAlphaFuncx",
            .clearColorx => "glClearColorx",
            .clearDepthx => "glClearDepthx",
            .clipPlanex => "glClipPlanex",
            .color4x => "glColor4x",
            .depthRangex => "glDepthRangex",
            .fogx => "glFogx",
            .fogxv => "glFogxv",
            .frustumx => "glFrustumx",
            .getClipPlanex => "glGetClipPlanex",
            .getFixedv => "glGetFixedv",
            .getLightxv => "glGetLightxv",
            .getMaterialxv => "glGetMaterialxv",
            .getTexEnvxv => "glGetTexEnvxv",
            .getTexParameterxv => "glGetTexParameterxv",
            .lightModelx => "glLightModelx",
            .lightModelxv => "glLightModelxv",
            .lightx => "glLightx",
            .lightxv => "glLightxv",
            .lineWidthx => "glLineWidthx",
            .loadMatrixx => "glLoadMatrixx",
            .materialx => "glMaterialx",
            .materialxv => "glMaterialxv",
            .multMatrixx => "glMultMatrixx",
            .multiTexCoord4x => "glMultiTexCoord4x",
            .normal3x => "glNormal3x",
            .orthox => "glOrthox",
            .pointParameterx => "glPointParameterx",
            .pointParameterxv => "glPointParameterxv",
            .pointSizex => "glPointSizex",
            .polygonOffsetx => "glPolygonOffsetx",
            .rotatex => "glRotatex",
            .sampleCoveragex => "glSampleCoveragex",
            .scalex => "glScalex",
            .texEnvx => "glTexEnvx",
            .texEnvxv => "glTexEnvxv",
            .texParameterx => "glTexParameterx",
            .texParameterxv => "glTexParameterxv",
            .translatex => "glTranslatex",
            .blendBarrier => "glBlendBarrier",
            .primitiveBoundingBox => "glPrimitiveBoundingBox",
        };
    }
    pub fn merge(lhs: CommandFlags, rhs: CommandFlags) CommandFlags {
        @setEvalBranchQuota(10_000);
        var result: CommandFlags = .{};
        inline for (@typeInfo(CommandFlags).Struct.fields) |field| {
            @field(result, field.name) = @field(lhs, field.name) or @field(rhs, field.name);
        }
        return result;
    }
    pub fn intersect(lhs: CommandFlags, rhs: CommandFlags) CommandFlags {
        @setEvalBranchQuota(10_000);
        var result: CommandFlags = .{};
        inline for (@typeInfo(CommandFlags).Struct.fields) |field| {
            @field(result, field.name) = @field(lhs, field.name) and @field(rhs, field.name);
        }
        return result;
    }
    pub fn complement(self: CommandFlags) CommandFlags {
        @setEvalBranchQuota(10_000);
        var result: CommandFlags = .{};
        inline for (@typeInfo(CommandFlags).Struct.fields) |field| {
            @field(result, field.name) = !@field(self, field.name);
        }
        return result;
    }
    pub fn subtract(lhs: CommandFlags, rhs: CommandFlags) CommandFlags {
        @setEvalBranchQuota(10_000);
        var result: CommandFlags = .{};
        inline for (@typeInfo(CommandFlags).Struct.fields) |field| {
            @field(result, field.name) = @field(lhs, field.name) and !@field(rhs, field.name);
        }
        return result;
    }
    pub fn contains(lhs: CommandFlags, rhs: CommandFlags) bool {
        @setEvalBranchQuota(10_000);
        inline for (@typeInfo(CommandFlags).Struct.fields) |field| {
            if (!@field(lhs, field.name) and @field(rhs, field.name)) {
                return false;
            }
        }
        return true;
    }
};

pub fn LoaderWrapper(comptime cmds: CommandFlags) type {
    return struct {
        dispatch: Dispatch,

        const Dispatch = blk: {
            @setEvalBranchQuota(10_000);
            const Type = std.builtin.Type;
            const fields_len = fields_len: {
                var fields_len: u32 = 0;
                for (@typeInfo(CommandFlags).Struct.fields) |field| {
                    fields_len += @as(u32, @intCast(@intFromBool(@field(cmds, field.name))));
                }
                break :fields_len fields_len;
            };
            var fields: [fields_len]Type.StructField = undefined;
            var i: usize = 0;
            for (@typeInfo(CommandFlags).Struct.fields) |field| {
                if (@field(cmds, field.name)) {
                    const field_tag = std.enums.nameCast(std.meta.FieldEnum(CommandFlags), field.name);
                    const PfnType = CommandFlags.CmdType(field_tag);
                    fields[i] = .{
                        .name = CommandFlags.cmdName(field_tag),
                        .type = PfnType,
                        .default_value = null,
                        .is_comptime = false,
                        .alignment = @alignOf(PfnType),
                    };
                    i += 1;
                }
            }
            break :blk @Type(.{
                .Struct = .{
                    .layout = .auto,
                    .fields = &fields,
                    .decls = &[_]std.builtin.Type.Declaration{},
                    .is_tuple = false,
                },
            });
        };

        pub fn init() @This() {
            var self: @This() = undefined;
            @memset(std.mem.asBytes(&self), 0);
            return self;
        }

        pub fn load(self: *@This(), loader: anytype) error{CommandLoadFailure}!void {
            const zone = tracy.ZoneN(@src(), "gl.Loader.load");
            defer zone.End();

            inline for (std.meta.fields(Dispatch)) |field| {
                if (loader.getProcAddress(field.name)) |cmd_ptr| {
                    @field(self.dispatch, field.name) = @as(field.type, @ptrCast(cmd_ptr));
                } else {
                    log.err("entry point `{s}` not found", .{field.name});
                    return error.CommandLoadFailure;
                }
            }
        }

        pub inline fn cullFace(self: *const @This(), _mode: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glCullFace");
            defer zone.End();
            const result = self.dispatch.glCullFace(_mode);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn frontFace(self: *const @This(), _mode: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glFrontFace");
            defer zone.End();
            const result = self.dispatch.glFrontFace(_mode);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn hint(self: *const @This(), _target: GLenum, _mode: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glHint");
            defer zone.End();
            const result = self.dispatch.glHint(_target, _mode);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn lineWidth(self: *const @This(), _width: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glLineWidth");
            defer zone.End();
            const result = self.dispatch.glLineWidth(_width);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn pointSize(self: *const @This(), _size: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glPointSize");
            defer zone.End();
            const result = self.dispatch.glPointSize(_size);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn polygonMode(self: *const @This(), _face: GLenum, _mode: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glPolygonMode");
            defer zone.End();
            const result = self.dispatch.glPolygonMode(_face, _mode);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn scissor(self: *const @This(), _x: GLint, _y: GLint, _width: GLsizei, _height: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glScissor");
            defer zone.End();
            const result = self.dispatch.glScissor(_x, _y, _width, _height);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texParameterf(self: *const @This(), _target: GLenum, _pname: GLenum, _param: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexParameterf");
            defer zone.End();
            const result = self.dispatch.glTexParameterf(_target, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texParameterfv(self: *const @This(), _target: GLenum, _pname: GLenum, _params: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexParameterfv");
            defer zone.End();
            const result = self.dispatch.glTexParameterfv(_target, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texParameteri(self: *const @This(), _target: GLenum, _pname: GLenum, _param: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexParameteri");
            defer zone.End();
            const result = self.dispatch.glTexParameteri(_target, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texParameteriv(self: *const @This(), _target: GLenum, _pname: GLenum, _params: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexParameteriv");
            defer zone.End();
            const result = self.dispatch.glTexParameteriv(_target, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texImage1D(self: *const @This(), _target: GLenum, _level: GLint, _internalformat: GLint, _width: GLsizei, _border: GLint, _format: GLenum, _type: GLenum, _pixels: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexImage1D");
            defer zone.End();
            const result = self.dispatch.glTexImage1D(_target, _level, _internalformat, _width, _border, _format, _type, _pixels);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texImage2D(self: *const @This(), _target: GLenum, _level: GLint, _internalformat: GLint, _width: GLsizei, _height: GLsizei, _border: GLint, _format: GLenum, _type: GLenum, _pixels: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexImage2D");
            defer zone.End();
            const result = self.dispatch.glTexImage2D(_target, _level, _internalformat, _width, _height, _border, _format, _type, _pixels);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn drawBuffer(self: *const @This(), _buf: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glDrawBuffer");
            defer zone.End();
            const result = self.dispatch.glDrawBuffer(_buf);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clear(self: *const @This(), _mask: GLbitfield) Error!void {
            const zone = tracy.ZoneN(@src(), "glClear");
            defer zone.End();
            const result = self.dispatch.glClear(_mask);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clearColor(self: *const @This(), _red: GLfloat, _green: GLfloat, _blue: GLfloat, _alpha: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glClearColor");
            defer zone.End();
            const result = self.dispatch.glClearColor(_red, _green, _blue, _alpha);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clearStencil(self: *const @This(), _s: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glClearStencil");
            defer zone.End();
            const result = self.dispatch.glClearStencil(_s);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clearDepth(self: *const @This(), _depth: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glClearDepth");
            defer zone.End();
            const result = self.dispatch.glClearDepth(_depth);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn stencilMask(self: *const @This(), _mask: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glStencilMask");
            defer zone.End();
            const result = self.dispatch.glStencilMask(_mask);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn colorMask(self: *const @This(), _red: GLboolean, _green: GLboolean, _blue: GLboolean, _alpha: GLboolean) Error!void {
            const zone = tracy.ZoneN(@src(), "glColorMask");
            defer zone.End();
            const result = self.dispatch.glColorMask(_red, _green, _blue, _alpha);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn depthMask(self: *const @This(), _flag: GLboolean) Error!void {
            const zone = tracy.ZoneN(@src(), "glDepthMask");
            defer zone.End();
            const result = self.dispatch.glDepthMask(_flag);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn disable(self: *const @This(), _cap: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glDisable");
            defer zone.End();
            const result = self.dispatch.glDisable(_cap);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn enable(self: *const @This(), _cap: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glEnable");
            defer zone.End();
            const result = self.dispatch.glEnable(_cap);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn finish(self: *const @This()) Error!void {
            const zone = tracy.ZoneN(@src(), "glFinish");
            defer zone.End();
            const result = self.dispatch.glFinish();
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn flush(self: *const @This()) Error!void {
            const zone = tracy.ZoneN(@src(), "glFlush");
            defer zone.End();
            const result = self.dispatch.glFlush();
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn blendFunc(self: *const @This(), _sfactor: GLenum, _dfactor: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glBlendFunc");
            defer zone.End();
            const result = self.dispatch.glBlendFunc(_sfactor, _dfactor);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn logicOp(self: *const @This(), _opcode: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glLogicOp");
            defer zone.End();
            const result = self.dispatch.glLogicOp(_opcode);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn stencilFunc(self: *const @This(), _func: GLenum, _ref: GLint, _mask: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glStencilFunc");
            defer zone.End();
            const result = self.dispatch.glStencilFunc(_func, _ref, _mask);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn stencilOp(self: *const @This(), _fail: GLenum, _zfail: GLenum, _zpass: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glStencilOp");
            defer zone.End();
            const result = self.dispatch.glStencilOp(_fail, _zfail, _zpass);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn depthFunc(self: *const @This(), _func: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glDepthFunc");
            defer zone.End();
            const result = self.dispatch.glDepthFunc(_func);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn pixelStoref(self: *const @This(), _pname: GLenum, _param: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glPixelStoref");
            defer zone.End();
            const result = self.dispatch.glPixelStoref(_pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn pixelStorei(self: *const @This(), _pname: GLenum, _param: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glPixelStorei");
            defer zone.End();
            const result = self.dispatch.glPixelStorei(_pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn readBuffer(self: *const @This(), _src: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glReadBuffer");
            defer zone.End();
            const result = self.dispatch.glReadBuffer(_src);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn readPixels(self: *const @This(), _x: GLint, _y: GLint, _width: GLsizei, _height: GLsizei, _format: GLenum, _type: GLenum, _pixels: ?*anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glReadPixels");
            defer zone.End();
            const result = self.dispatch.glReadPixels(_x, _y, _width, _height, _format, _type, _pixels);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getBooleanv(self: *const @This(), _pname: GLenum, _data: [*c]GLboolean) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetBooleanv");
            defer zone.End();
            const result = self.dispatch.glGetBooleanv(_pname, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getDoublev(self: *const @This(), _pname: GLenum, _data: [*c]GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetDoublev");
            defer zone.End();
            const result = self.dispatch.glGetDoublev(_pname, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getError(self: *const @This()) Error!GLenum {
            const zone = tracy.ZoneN(@src(), "glGetError");
            defer zone.End();
            const result = self.dispatch.glGetError();
            return result;
        }
        pub inline fn getFloatv(self: *const @This(), _pname: GLenum, _data: [*c]GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetFloatv");
            defer zone.End();
            const result = self.dispatch.glGetFloatv(_pname, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getIntegerv(self: *const @This(), _pname: GLenum, _data: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetIntegerv");
            defer zone.End();
            const result = self.dispatch.glGetIntegerv(_pname, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getString(self: *const @This(), _name: GLenum) Error!?[*:0]const GLubyte {
            const zone = tracy.ZoneN(@src(), "glGetString");
            defer zone.End();
            const result = self.dispatch.glGetString(_name);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getTexImage(self: *const @This(), _target: GLenum, _level: GLint, _format: GLenum, _type: GLenum, _pixels: ?*anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetTexImage");
            defer zone.End();
            const result = self.dispatch.glGetTexImage(_target, _level, _format, _type, _pixels);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getTexParameterfv(self: *const @This(), _target: GLenum, _pname: GLenum, _params: [*c]GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetTexParameterfv");
            defer zone.End();
            const result = self.dispatch.glGetTexParameterfv(_target, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getTexParameteriv(self: *const @This(), _target: GLenum, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetTexParameteriv");
            defer zone.End();
            const result = self.dispatch.glGetTexParameteriv(_target, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getTexLevelParameterfv(self: *const @This(), _target: GLenum, _level: GLint, _pname: GLenum, _params: [*c]GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetTexLevelParameterfv");
            defer zone.End();
            const result = self.dispatch.glGetTexLevelParameterfv(_target, _level, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getTexLevelParameteriv(self: *const @This(), _target: GLenum, _level: GLint, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetTexLevelParameteriv");
            defer zone.End();
            const result = self.dispatch.glGetTexLevelParameteriv(_target, _level, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn isEnabled(self: *const @This(), _cap: GLenum) Error!GLboolean {
            const zone = tracy.ZoneN(@src(), "glIsEnabled");
            defer zone.End();
            const result = self.dispatch.glIsEnabled(_cap);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn depthRange(self: *const @This(), _n: GLdouble, _f: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glDepthRange");
            defer zone.End();
            const result = self.dispatch.glDepthRange(_n, _f);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn viewport(self: *const @This(), _x: GLint, _y: GLint, _width: GLsizei, _height: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glViewport");
            defer zone.End();
            const result = self.dispatch.glViewport(_x, _y, _width, _height);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn newList(self: *const @This(), _list: GLuint, _mode: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glNewList");
            defer zone.End();
            const result = self.dispatch.glNewList(_list, _mode);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn endList(self: *const @This()) Error!void {
            const zone = tracy.ZoneN(@src(), "glEndList");
            defer zone.End();
            const result = self.dispatch.glEndList();
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn callList(self: *const @This(), _list: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glCallList");
            defer zone.End();
            const result = self.dispatch.glCallList(_list);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn callLists(self: *const @This(), _n: GLsizei, _type: GLenum, _lists: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glCallLists");
            defer zone.End();
            const result = self.dispatch.glCallLists(_n, _type, _lists);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn deleteLists(self: *const @This(), _list: GLuint, _range: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glDeleteLists");
            defer zone.End();
            const result = self.dispatch.glDeleteLists(_list, _range);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn genLists(self: *const @This(), _range: GLsizei) Error!GLuint {
            const zone = tracy.ZoneN(@src(), "glGenLists");
            defer zone.End();
            const result = self.dispatch.glGenLists(_range);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn listBase(self: *const @This(), _base: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glListBase");
            defer zone.End();
            const result = self.dispatch.glListBase(_base);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn begin(self: *const @This(), _mode: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glBegin");
            defer zone.End();
            const result = self.dispatch.glBegin(_mode);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn bitmap(self: *const @This(), _width: GLsizei, _height: GLsizei, _xorig: GLfloat, _yorig: GLfloat, _xmove: GLfloat, _ymove: GLfloat, _bitmap: ?[*:0]const GLubyte) Error!void {
            const zone = tracy.ZoneN(@src(), "glBitmap");
            defer zone.End();
            const result = self.dispatch.glBitmap(_width, _height, _xorig, _yorig, _xmove, _ymove, _bitmap);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color3b(self: *const @This(), _red: GLbyte, _green: GLbyte, _blue: GLbyte) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor3b");
            defer zone.End();
            const result = self.dispatch.glColor3b(_red, _green, _blue);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color3bv(self: *const @This(), _v: [*c]const GLbyte) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor3bv");
            defer zone.End();
            const result = self.dispatch.glColor3bv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color3d(self: *const @This(), _red: GLdouble, _green: GLdouble, _blue: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor3d");
            defer zone.End();
            const result = self.dispatch.glColor3d(_red, _green, _blue);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color3dv(self: *const @This(), _v: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor3dv");
            defer zone.End();
            const result = self.dispatch.glColor3dv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color3f(self: *const @This(), _red: GLfloat, _green: GLfloat, _blue: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor3f");
            defer zone.End();
            const result = self.dispatch.glColor3f(_red, _green, _blue);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color3fv(self: *const @This(), _v: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor3fv");
            defer zone.End();
            const result = self.dispatch.glColor3fv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color3i(self: *const @This(), _red: GLint, _green: GLint, _blue: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor3i");
            defer zone.End();
            const result = self.dispatch.glColor3i(_red, _green, _blue);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color3iv(self: *const @This(), _v: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor3iv");
            defer zone.End();
            const result = self.dispatch.glColor3iv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color3s(self: *const @This(), _red: GLshort, _green: GLshort, _blue: GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor3s");
            defer zone.End();
            const result = self.dispatch.glColor3s(_red, _green, _blue);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color3sv(self: *const @This(), _v: [*c]const GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor3sv");
            defer zone.End();
            const result = self.dispatch.glColor3sv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color3ub(self: *const @This(), _red: GLubyte, _green: GLubyte, _blue: GLubyte) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor3ub");
            defer zone.End();
            const result = self.dispatch.glColor3ub(_red, _green, _blue);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color3ubv(self: *const @This(), _v: ?[*:0]const GLubyte) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor3ubv");
            defer zone.End();
            const result = self.dispatch.glColor3ubv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color3ui(self: *const @This(), _red: GLuint, _green: GLuint, _blue: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor3ui");
            defer zone.End();
            const result = self.dispatch.glColor3ui(_red, _green, _blue);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color3uiv(self: *const @This(), _v: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor3uiv");
            defer zone.End();
            const result = self.dispatch.glColor3uiv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color3us(self: *const @This(), _red: GLushort, _green: GLushort, _blue: GLushort) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor3us");
            defer zone.End();
            const result = self.dispatch.glColor3us(_red, _green, _blue);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color3usv(self: *const @This(), _v: [*c]const GLushort) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor3usv");
            defer zone.End();
            const result = self.dispatch.glColor3usv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color4b(self: *const @This(), _red: GLbyte, _green: GLbyte, _blue: GLbyte, _alpha: GLbyte) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor4b");
            defer zone.End();
            const result = self.dispatch.glColor4b(_red, _green, _blue, _alpha);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color4bv(self: *const @This(), _v: [*c]const GLbyte) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor4bv");
            defer zone.End();
            const result = self.dispatch.glColor4bv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color4d(self: *const @This(), _red: GLdouble, _green: GLdouble, _blue: GLdouble, _alpha: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor4d");
            defer zone.End();
            const result = self.dispatch.glColor4d(_red, _green, _blue, _alpha);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color4dv(self: *const @This(), _v: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor4dv");
            defer zone.End();
            const result = self.dispatch.glColor4dv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color4f(self: *const @This(), _red: GLfloat, _green: GLfloat, _blue: GLfloat, _alpha: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor4f");
            defer zone.End();
            const result = self.dispatch.glColor4f(_red, _green, _blue, _alpha);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color4fv(self: *const @This(), _v: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor4fv");
            defer zone.End();
            const result = self.dispatch.glColor4fv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color4i(self: *const @This(), _red: GLint, _green: GLint, _blue: GLint, _alpha: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor4i");
            defer zone.End();
            const result = self.dispatch.glColor4i(_red, _green, _blue, _alpha);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color4iv(self: *const @This(), _v: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor4iv");
            defer zone.End();
            const result = self.dispatch.glColor4iv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color4s(self: *const @This(), _red: GLshort, _green: GLshort, _blue: GLshort, _alpha: GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor4s");
            defer zone.End();
            const result = self.dispatch.glColor4s(_red, _green, _blue, _alpha);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color4sv(self: *const @This(), _v: [*c]const GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor4sv");
            defer zone.End();
            const result = self.dispatch.glColor4sv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color4ub(self: *const @This(), _red: GLubyte, _green: GLubyte, _blue: GLubyte, _alpha: GLubyte) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor4ub");
            defer zone.End();
            const result = self.dispatch.glColor4ub(_red, _green, _blue, _alpha);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color4ubv(self: *const @This(), _v: ?[*:0]const GLubyte) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor4ubv");
            defer zone.End();
            const result = self.dispatch.glColor4ubv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color4ui(self: *const @This(), _red: GLuint, _green: GLuint, _blue: GLuint, _alpha: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor4ui");
            defer zone.End();
            const result = self.dispatch.glColor4ui(_red, _green, _blue, _alpha);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color4uiv(self: *const @This(), _v: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor4uiv");
            defer zone.End();
            const result = self.dispatch.glColor4uiv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color4us(self: *const @This(), _red: GLushort, _green: GLushort, _blue: GLushort, _alpha: GLushort) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor4us");
            defer zone.End();
            const result = self.dispatch.glColor4us(_red, _green, _blue, _alpha);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color4usv(self: *const @This(), _v: [*c]const GLushort) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor4usv");
            defer zone.End();
            const result = self.dispatch.glColor4usv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn edgeFlag(self: *const @This(), _flag: GLboolean) Error!void {
            const zone = tracy.ZoneN(@src(), "glEdgeFlag");
            defer zone.End();
            const result = self.dispatch.glEdgeFlag(_flag);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn edgeFlagv(self: *const @This(), _flag: [*c]const GLboolean) Error!void {
            const zone = tracy.ZoneN(@src(), "glEdgeFlagv");
            defer zone.End();
            const result = self.dispatch.glEdgeFlagv(_flag);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn end(self: *const @This()) Error!void {
            const zone = tracy.ZoneN(@src(), "glEnd");
            defer zone.End();
            const result = self.dispatch.glEnd();
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn indexd(self: *const @This(), _c: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glIndexd");
            defer zone.End();
            const result = self.dispatch.glIndexd(_c);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn indexdv(self: *const @This(), _c: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glIndexdv");
            defer zone.End();
            const result = self.dispatch.glIndexdv(_c);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn indexf(self: *const @This(), _c: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glIndexf");
            defer zone.End();
            const result = self.dispatch.glIndexf(_c);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn indexfv(self: *const @This(), _c: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glIndexfv");
            defer zone.End();
            const result = self.dispatch.glIndexfv(_c);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn indexi(self: *const @This(), _c: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glIndexi");
            defer zone.End();
            const result = self.dispatch.glIndexi(_c);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn indexiv(self: *const @This(), _c: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glIndexiv");
            defer zone.End();
            const result = self.dispatch.glIndexiv(_c);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn indexs(self: *const @This(), _c: GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glIndexs");
            defer zone.End();
            const result = self.dispatch.glIndexs(_c);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn indexsv(self: *const @This(), _c: [*c]const GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glIndexsv");
            defer zone.End();
            const result = self.dispatch.glIndexsv(_c);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn normal3b(self: *const @This(), _nx: GLbyte, _ny: GLbyte, _nz: GLbyte) Error!void {
            const zone = tracy.ZoneN(@src(), "glNormal3b");
            defer zone.End();
            const result = self.dispatch.glNormal3b(_nx, _ny, _nz);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn normal3bv(self: *const @This(), _v: [*c]const GLbyte) Error!void {
            const zone = tracy.ZoneN(@src(), "glNormal3bv");
            defer zone.End();
            const result = self.dispatch.glNormal3bv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn normal3d(self: *const @This(), _nx: GLdouble, _ny: GLdouble, _nz: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glNormal3d");
            defer zone.End();
            const result = self.dispatch.glNormal3d(_nx, _ny, _nz);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn normal3dv(self: *const @This(), _v: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glNormal3dv");
            defer zone.End();
            const result = self.dispatch.glNormal3dv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn normal3f(self: *const @This(), _nx: GLfloat, _ny: GLfloat, _nz: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glNormal3f");
            defer zone.End();
            const result = self.dispatch.glNormal3f(_nx, _ny, _nz);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn normal3fv(self: *const @This(), _v: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glNormal3fv");
            defer zone.End();
            const result = self.dispatch.glNormal3fv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn normal3i(self: *const @This(), _nx: GLint, _ny: GLint, _nz: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glNormal3i");
            defer zone.End();
            const result = self.dispatch.glNormal3i(_nx, _ny, _nz);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn normal3iv(self: *const @This(), _v: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glNormal3iv");
            defer zone.End();
            const result = self.dispatch.glNormal3iv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn normal3s(self: *const @This(), _nx: GLshort, _ny: GLshort, _nz: GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glNormal3s");
            defer zone.End();
            const result = self.dispatch.glNormal3s(_nx, _ny, _nz);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn normal3sv(self: *const @This(), _v: [*c]const GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glNormal3sv");
            defer zone.End();
            const result = self.dispatch.glNormal3sv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rasterPos2d(self: *const @This(), _x: GLdouble, _y: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glRasterPos2d");
            defer zone.End();
            const result = self.dispatch.glRasterPos2d(_x, _y);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rasterPos2dv(self: *const @This(), _v: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glRasterPos2dv");
            defer zone.End();
            const result = self.dispatch.glRasterPos2dv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rasterPos2f(self: *const @This(), _x: GLfloat, _y: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glRasterPos2f");
            defer zone.End();
            const result = self.dispatch.glRasterPos2f(_x, _y);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rasterPos2fv(self: *const @This(), _v: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glRasterPos2fv");
            defer zone.End();
            const result = self.dispatch.glRasterPos2fv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rasterPos2i(self: *const @This(), _x: GLint, _y: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glRasterPos2i");
            defer zone.End();
            const result = self.dispatch.glRasterPos2i(_x, _y);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rasterPos2iv(self: *const @This(), _v: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glRasterPos2iv");
            defer zone.End();
            const result = self.dispatch.glRasterPos2iv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rasterPos2s(self: *const @This(), _x: GLshort, _y: GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glRasterPos2s");
            defer zone.End();
            const result = self.dispatch.glRasterPos2s(_x, _y);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rasterPos2sv(self: *const @This(), _v: [*c]const GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glRasterPos2sv");
            defer zone.End();
            const result = self.dispatch.glRasterPos2sv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rasterPos3d(self: *const @This(), _x: GLdouble, _y: GLdouble, _z: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glRasterPos3d");
            defer zone.End();
            const result = self.dispatch.glRasterPos3d(_x, _y, _z);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rasterPos3dv(self: *const @This(), _v: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glRasterPos3dv");
            defer zone.End();
            const result = self.dispatch.glRasterPos3dv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rasterPos3f(self: *const @This(), _x: GLfloat, _y: GLfloat, _z: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glRasterPos3f");
            defer zone.End();
            const result = self.dispatch.glRasterPos3f(_x, _y, _z);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rasterPos3fv(self: *const @This(), _v: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glRasterPos3fv");
            defer zone.End();
            const result = self.dispatch.glRasterPos3fv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rasterPos3i(self: *const @This(), _x: GLint, _y: GLint, _z: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glRasterPos3i");
            defer zone.End();
            const result = self.dispatch.glRasterPos3i(_x, _y, _z);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rasterPos3iv(self: *const @This(), _v: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glRasterPos3iv");
            defer zone.End();
            const result = self.dispatch.glRasterPos3iv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rasterPos3s(self: *const @This(), _x: GLshort, _y: GLshort, _z: GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glRasterPos3s");
            defer zone.End();
            const result = self.dispatch.glRasterPos3s(_x, _y, _z);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rasterPos3sv(self: *const @This(), _v: [*c]const GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glRasterPos3sv");
            defer zone.End();
            const result = self.dispatch.glRasterPos3sv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rasterPos4d(self: *const @This(), _x: GLdouble, _y: GLdouble, _z: GLdouble, _w: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glRasterPos4d");
            defer zone.End();
            const result = self.dispatch.glRasterPos4d(_x, _y, _z, _w);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rasterPos4dv(self: *const @This(), _v: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glRasterPos4dv");
            defer zone.End();
            const result = self.dispatch.glRasterPos4dv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rasterPos4f(self: *const @This(), _x: GLfloat, _y: GLfloat, _z: GLfloat, _w: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glRasterPos4f");
            defer zone.End();
            const result = self.dispatch.glRasterPos4f(_x, _y, _z, _w);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rasterPos4fv(self: *const @This(), _v: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glRasterPos4fv");
            defer zone.End();
            const result = self.dispatch.glRasterPos4fv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rasterPos4i(self: *const @This(), _x: GLint, _y: GLint, _z: GLint, _w: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glRasterPos4i");
            defer zone.End();
            const result = self.dispatch.glRasterPos4i(_x, _y, _z, _w);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rasterPos4iv(self: *const @This(), _v: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glRasterPos4iv");
            defer zone.End();
            const result = self.dispatch.glRasterPos4iv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rasterPos4s(self: *const @This(), _x: GLshort, _y: GLshort, _z: GLshort, _w: GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glRasterPos4s");
            defer zone.End();
            const result = self.dispatch.glRasterPos4s(_x, _y, _z, _w);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rasterPos4sv(self: *const @This(), _v: [*c]const GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glRasterPos4sv");
            defer zone.End();
            const result = self.dispatch.glRasterPos4sv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rectd(self: *const @This(), _x1: GLdouble, _y1: GLdouble, _x2: GLdouble, _y2: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glRectd");
            defer zone.End();
            const result = self.dispatch.glRectd(_x1, _y1, _x2, _y2);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rectdv(self: *const @This(), _v1: [*c]const GLdouble, _v2: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glRectdv");
            defer zone.End();
            const result = self.dispatch.glRectdv(_v1, _v2);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rectf(self: *const @This(), _x1: GLfloat, _y1: GLfloat, _x2: GLfloat, _y2: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glRectf");
            defer zone.End();
            const result = self.dispatch.glRectf(_x1, _y1, _x2, _y2);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rectfv(self: *const @This(), _v1: [*c]const GLfloat, _v2: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glRectfv");
            defer zone.End();
            const result = self.dispatch.glRectfv(_v1, _v2);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn recti(self: *const @This(), _x1: GLint, _y1: GLint, _x2: GLint, _y2: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glRecti");
            defer zone.End();
            const result = self.dispatch.glRecti(_x1, _y1, _x2, _y2);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rectiv(self: *const @This(), _v1: [*c]const GLint, _v2: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glRectiv");
            defer zone.End();
            const result = self.dispatch.glRectiv(_v1, _v2);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rects(self: *const @This(), _x1: GLshort, _y1: GLshort, _x2: GLshort, _y2: GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glRects");
            defer zone.End();
            const result = self.dispatch.glRects(_x1, _y1, _x2, _y2);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rectsv(self: *const @This(), _v1: [*c]const GLshort, _v2: [*c]const GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glRectsv");
            defer zone.End();
            const result = self.dispatch.glRectsv(_v1, _v2);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord1d(self: *const @This(), _s: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord1d");
            defer zone.End();
            const result = self.dispatch.glTexCoord1d(_s);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord1dv(self: *const @This(), _v: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord1dv");
            defer zone.End();
            const result = self.dispatch.glTexCoord1dv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord1f(self: *const @This(), _s: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord1f");
            defer zone.End();
            const result = self.dispatch.glTexCoord1f(_s);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord1fv(self: *const @This(), _v: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord1fv");
            defer zone.End();
            const result = self.dispatch.glTexCoord1fv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord1i(self: *const @This(), _s: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord1i");
            defer zone.End();
            const result = self.dispatch.glTexCoord1i(_s);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord1iv(self: *const @This(), _v: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord1iv");
            defer zone.End();
            const result = self.dispatch.glTexCoord1iv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord1s(self: *const @This(), _s: GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord1s");
            defer zone.End();
            const result = self.dispatch.glTexCoord1s(_s);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord1sv(self: *const @This(), _v: [*c]const GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord1sv");
            defer zone.End();
            const result = self.dispatch.glTexCoord1sv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord2d(self: *const @This(), _s: GLdouble, _t: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord2d");
            defer zone.End();
            const result = self.dispatch.glTexCoord2d(_s, _t);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord2dv(self: *const @This(), _v: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord2dv");
            defer zone.End();
            const result = self.dispatch.glTexCoord2dv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord2f(self: *const @This(), _s: GLfloat, _t: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord2f");
            defer zone.End();
            const result = self.dispatch.glTexCoord2f(_s, _t);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord2fv(self: *const @This(), _v: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord2fv");
            defer zone.End();
            const result = self.dispatch.glTexCoord2fv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord2i(self: *const @This(), _s: GLint, _t: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord2i");
            defer zone.End();
            const result = self.dispatch.glTexCoord2i(_s, _t);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord2iv(self: *const @This(), _v: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord2iv");
            defer zone.End();
            const result = self.dispatch.glTexCoord2iv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord2s(self: *const @This(), _s: GLshort, _t: GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord2s");
            defer zone.End();
            const result = self.dispatch.glTexCoord2s(_s, _t);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord2sv(self: *const @This(), _v: [*c]const GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord2sv");
            defer zone.End();
            const result = self.dispatch.glTexCoord2sv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord3d(self: *const @This(), _s: GLdouble, _t: GLdouble, _r: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord3d");
            defer zone.End();
            const result = self.dispatch.glTexCoord3d(_s, _t, _r);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord3dv(self: *const @This(), _v: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord3dv");
            defer zone.End();
            const result = self.dispatch.glTexCoord3dv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord3f(self: *const @This(), _s: GLfloat, _t: GLfloat, _r: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord3f");
            defer zone.End();
            const result = self.dispatch.glTexCoord3f(_s, _t, _r);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord3fv(self: *const @This(), _v: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord3fv");
            defer zone.End();
            const result = self.dispatch.glTexCoord3fv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord3i(self: *const @This(), _s: GLint, _t: GLint, _r: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord3i");
            defer zone.End();
            const result = self.dispatch.glTexCoord3i(_s, _t, _r);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord3iv(self: *const @This(), _v: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord3iv");
            defer zone.End();
            const result = self.dispatch.glTexCoord3iv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord3s(self: *const @This(), _s: GLshort, _t: GLshort, _r: GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord3s");
            defer zone.End();
            const result = self.dispatch.glTexCoord3s(_s, _t, _r);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord3sv(self: *const @This(), _v: [*c]const GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord3sv");
            defer zone.End();
            const result = self.dispatch.glTexCoord3sv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord4d(self: *const @This(), _s: GLdouble, _t: GLdouble, _r: GLdouble, _q: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord4d");
            defer zone.End();
            const result = self.dispatch.glTexCoord4d(_s, _t, _r, _q);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord4dv(self: *const @This(), _v: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord4dv");
            defer zone.End();
            const result = self.dispatch.glTexCoord4dv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord4f(self: *const @This(), _s: GLfloat, _t: GLfloat, _r: GLfloat, _q: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord4f");
            defer zone.End();
            const result = self.dispatch.glTexCoord4f(_s, _t, _r, _q);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord4fv(self: *const @This(), _v: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord4fv");
            defer zone.End();
            const result = self.dispatch.glTexCoord4fv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord4i(self: *const @This(), _s: GLint, _t: GLint, _r: GLint, _q: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord4i");
            defer zone.End();
            const result = self.dispatch.glTexCoord4i(_s, _t, _r, _q);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord4iv(self: *const @This(), _v: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord4iv");
            defer zone.End();
            const result = self.dispatch.glTexCoord4iv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord4s(self: *const @This(), _s: GLshort, _t: GLshort, _r: GLshort, _q: GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord4s");
            defer zone.End();
            const result = self.dispatch.glTexCoord4s(_s, _t, _r, _q);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoord4sv(self: *const @This(), _v: [*c]const GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoord4sv");
            defer zone.End();
            const result = self.dispatch.glTexCoord4sv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertex2d(self: *const @This(), _x: GLdouble, _y: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertex2d");
            defer zone.End();
            const result = self.dispatch.glVertex2d(_x, _y);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertex2dv(self: *const @This(), _v: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertex2dv");
            defer zone.End();
            const result = self.dispatch.glVertex2dv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertex2f(self: *const @This(), _x: GLfloat, _y: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertex2f");
            defer zone.End();
            const result = self.dispatch.glVertex2f(_x, _y);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertex2fv(self: *const @This(), _v: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertex2fv");
            defer zone.End();
            const result = self.dispatch.glVertex2fv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertex2i(self: *const @This(), _x: GLint, _y: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertex2i");
            defer zone.End();
            const result = self.dispatch.glVertex2i(_x, _y);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertex2iv(self: *const @This(), _v: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertex2iv");
            defer zone.End();
            const result = self.dispatch.glVertex2iv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertex2s(self: *const @This(), _x: GLshort, _y: GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertex2s");
            defer zone.End();
            const result = self.dispatch.glVertex2s(_x, _y);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertex2sv(self: *const @This(), _v: [*c]const GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertex2sv");
            defer zone.End();
            const result = self.dispatch.glVertex2sv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertex3d(self: *const @This(), _x: GLdouble, _y: GLdouble, _z: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertex3d");
            defer zone.End();
            const result = self.dispatch.glVertex3d(_x, _y, _z);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertex3dv(self: *const @This(), _v: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertex3dv");
            defer zone.End();
            const result = self.dispatch.glVertex3dv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertex3f(self: *const @This(), _x: GLfloat, _y: GLfloat, _z: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertex3f");
            defer zone.End();
            const result = self.dispatch.glVertex3f(_x, _y, _z);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertex3fv(self: *const @This(), _v: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertex3fv");
            defer zone.End();
            const result = self.dispatch.glVertex3fv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertex3i(self: *const @This(), _x: GLint, _y: GLint, _z: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertex3i");
            defer zone.End();
            const result = self.dispatch.glVertex3i(_x, _y, _z);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertex3iv(self: *const @This(), _v: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertex3iv");
            defer zone.End();
            const result = self.dispatch.glVertex3iv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertex3s(self: *const @This(), _x: GLshort, _y: GLshort, _z: GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertex3s");
            defer zone.End();
            const result = self.dispatch.glVertex3s(_x, _y, _z);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertex3sv(self: *const @This(), _v: [*c]const GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertex3sv");
            defer zone.End();
            const result = self.dispatch.glVertex3sv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertex4d(self: *const @This(), _x: GLdouble, _y: GLdouble, _z: GLdouble, _w: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertex4d");
            defer zone.End();
            const result = self.dispatch.glVertex4d(_x, _y, _z, _w);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertex4dv(self: *const @This(), _v: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertex4dv");
            defer zone.End();
            const result = self.dispatch.glVertex4dv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertex4f(self: *const @This(), _x: GLfloat, _y: GLfloat, _z: GLfloat, _w: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertex4f");
            defer zone.End();
            const result = self.dispatch.glVertex4f(_x, _y, _z, _w);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertex4fv(self: *const @This(), _v: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertex4fv");
            defer zone.End();
            const result = self.dispatch.glVertex4fv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertex4i(self: *const @This(), _x: GLint, _y: GLint, _z: GLint, _w: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertex4i");
            defer zone.End();
            const result = self.dispatch.glVertex4i(_x, _y, _z, _w);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertex4iv(self: *const @This(), _v: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertex4iv");
            defer zone.End();
            const result = self.dispatch.glVertex4iv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertex4s(self: *const @This(), _x: GLshort, _y: GLshort, _z: GLshort, _w: GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertex4s");
            defer zone.End();
            const result = self.dispatch.glVertex4s(_x, _y, _z, _w);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertex4sv(self: *const @This(), _v: [*c]const GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertex4sv");
            defer zone.End();
            const result = self.dispatch.glVertex4sv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clipPlane(self: *const @This(), _plane: GLenum, _equation: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glClipPlane");
            defer zone.End();
            const result = self.dispatch.glClipPlane(_plane, _equation);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn colorMaterial(self: *const @This(), _face: GLenum, _mode: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glColorMaterial");
            defer zone.End();
            const result = self.dispatch.glColorMaterial(_face, _mode);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn fogf(self: *const @This(), _pname: GLenum, _param: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glFogf");
            defer zone.End();
            const result = self.dispatch.glFogf(_pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn fogfv(self: *const @This(), _pname: GLenum, _params: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glFogfv");
            defer zone.End();
            const result = self.dispatch.glFogfv(_pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn fogi(self: *const @This(), _pname: GLenum, _param: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glFogi");
            defer zone.End();
            const result = self.dispatch.glFogi(_pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn fogiv(self: *const @This(), _pname: GLenum, _params: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glFogiv");
            defer zone.End();
            const result = self.dispatch.glFogiv(_pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn lightf(self: *const @This(), _light: GLenum, _pname: GLenum, _param: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glLightf");
            defer zone.End();
            const result = self.dispatch.glLightf(_light, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn lightfv(self: *const @This(), _light: GLenum, _pname: GLenum, _params: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glLightfv");
            defer zone.End();
            const result = self.dispatch.glLightfv(_light, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn lighti(self: *const @This(), _light: GLenum, _pname: GLenum, _param: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glLighti");
            defer zone.End();
            const result = self.dispatch.glLighti(_light, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn lightiv(self: *const @This(), _light: GLenum, _pname: GLenum, _params: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glLightiv");
            defer zone.End();
            const result = self.dispatch.glLightiv(_light, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn lightModelf(self: *const @This(), _pname: GLenum, _param: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glLightModelf");
            defer zone.End();
            const result = self.dispatch.glLightModelf(_pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn lightModelfv(self: *const @This(), _pname: GLenum, _params: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glLightModelfv");
            defer zone.End();
            const result = self.dispatch.glLightModelfv(_pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn lightModeli(self: *const @This(), _pname: GLenum, _param: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glLightModeli");
            defer zone.End();
            const result = self.dispatch.glLightModeli(_pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn lightModeliv(self: *const @This(), _pname: GLenum, _params: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glLightModeliv");
            defer zone.End();
            const result = self.dispatch.glLightModeliv(_pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn lineStipple(self: *const @This(), _factor: GLint, _pattern: GLushort) Error!void {
            const zone = tracy.ZoneN(@src(), "glLineStipple");
            defer zone.End();
            const result = self.dispatch.glLineStipple(_factor, _pattern);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn materialf(self: *const @This(), _face: GLenum, _pname: GLenum, _param: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glMaterialf");
            defer zone.End();
            const result = self.dispatch.glMaterialf(_face, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn materialfv(self: *const @This(), _face: GLenum, _pname: GLenum, _params: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glMaterialfv");
            defer zone.End();
            const result = self.dispatch.glMaterialfv(_face, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn materiali(self: *const @This(), _face: GLenum, _pname: GLenum, _param: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glMateriali");
            defer zone.End();
            const result = self.dispatch.glMateriali(_face, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn materialiv(self: *const @This(), _face: GLenum, _pname: GLenum, _params: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glMaterialiv");
            defer zone.End();
            const result = self.dispatch.glMaterialiv(_face, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn polygonStipple(self: *const @This(), _mask: ?[*:0]const GLubyte) Error!void {
            const zone = tracy.ZoneN(@src(), "glPolygonStipple");
            defer zone.End();
            const result = self.dispatch.glPolygonStipple(_mask);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn shadeModel(self: *const @This(), _mode: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glShadeModel");
            defer zone.End();
            const result = self.dispatch.glShadeModel(_mode);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texEnvf(self: *const @This(), _target: GLenum, _pname: GLenum, _param: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexEnvf");
            defer zone.End();
            const result = self.dispatch.glTexEnvf(_target, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texEnvfv(self: *const @This(), _target: GLenum, _pname: GLenum, _params: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexEnvfv");
            defer zone.End();
            const result = self.dispatch.glTexEnvfv(_target, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texEnvi(self: *const @This(), _target: GLenum, _pname: GLenum, _param: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexEnvi");
            defer zone.End();
            const result = self.dispatch.glTexEnvi(_target, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texEnviv(self: *const @This(), _target: GLenum, _pname: GLenum, _params: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexEnviv");
            defer zone.End();
            const result = self.dispatch.glTexEnviv(_target, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texGend(self: *const @This(), _coord: GLenum, _pname: GLenum, _param: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexGend");
            defer zone.End();
            const result = self.dispatch.glTexGend(_coord, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texGendv(self: *const @This(), _coord: GLenum, _pname: GLenum, _params: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexGendv");
            defer zone.End();
            const result = self.dispatch.glTexGendv(_coord, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texGenf(self: *const @This(), _coord: GLenum, _pname: GLenum, _param: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexGenf");
            defer zone.End();
            const result = self.dispatch.glTexGenf(_coord, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texGenfv(self: *const @This(), _coord: GLenum, _pname: GLenum, _params: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexGenfv");
            defer zone.End();
            const result = self.dispatch.glTexGenfv(_coord, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texGeni(self: *const @This(), _coord: GLenum, _pname: GLenum, _param: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexGeni");
            defer zone.End();
            const result = self.dispatch.glTexGeni(_coord, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texGeniv(self: *const @This(), _coord: GLenum, _pname: GLenum, _params: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexGeniv");
            defer zone.End();
            const result = self.dispatch.glTexGeniv(_coord, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn feedbackBuffer(self: *const @This(), _size: GLsizei, _type: GLenum, _buffer: [*c]GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glFeedbackBuffer");
            defer zone.End();
            const result = self.dispatch.glFeedbackBuffer(_size, _type, _buffer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn selectBuffer(self: *const @This(), _size: GLsizei, _buffer: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glSelectBuffer");
            defer zone.End();
            const result = self.dispatch.glSelectBuffer(_size, _buffer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn renderMode(self: *const @This(), _mode: GLenum) Error!GLint {
            const zone = tracy.ZoneN(@src(), "glRenderMode");
            defer zone.End();
            const result = self.dispatch.glRenderMode(_mode);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn initNames(self: *const @This()) Error!void {
            const zone = tracy.ZoneN(@src(), "glInitNames");
            defer zone.End();
            const result = self.dispatch.glInitNames();
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn loadName(self: *const @This(), _name: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glLoadName");
            defer zone.End();
            const result = self.dispatch.glLoadName(_name);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn passThrough(self: *const @This(), _token: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glPassThrough");
            defer zone.End();
            const result = self.dispatch.glPassThrough(_token);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn popName(self: *const @This()) Error!void {
            const zone = tracy.ZoneN(@src(), "glPopName");
            defer zone.End();
            const result = self.dispatch.glPopName();
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn pushName(self: *const @This(), _name: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glPushName");
            defer zone.End();
            const result = self.dispatch.glPushName(_name);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clearAccum(self: *const @This(), _red: GLfloat, _green: GLfloat, _blue: GLfloat, _alpha: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glClearAccum");
            defer zone.End();
            const result = self.dispatch.glClearAccum(_red, _green, _blue, _alpha);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clearIndex(self: *const @This(), _c: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glClearIndex");
            defer zone.End();
            const result = self.dispatch.glClearIndex(_c);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn indexMask(self: *const @This(), _mask: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glIndexMask");
            defer zone.End();
            const result = self.dispatch.glIndexMask(_mask);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn accum(self: *const @This(), _op: GLenum, _value: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glAccum");
            defer zone.End();
            const result = self.dispatch.glAccum(_op, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn popAttrib(self: *const @This()) Error!void {
            const zone = tracy.ZoneN(@src(), "glPopAttrib");
            defer zone.End();
            const result = self.dispatch.glPopAttrib();
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn pushAttrib(self: *const @This(), _mask: GLbitfield) Error!void {
            const zone = tracy.ZoneN(@src(), "glPushAttrib");
            defer zone.End();
            const result = self.dispatch.glPushAttrib(_mask);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn map1d(self: *const @This(), _target: GLenum, _u1: GLdouble, _u2: GLdouble, _stride: GLint, _order: GLint, _points: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glMap1d");
            defer zone.End();
            const result = self.dispatch.glMap1d(_target, _u1, _u2, _stride, _order, _points);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn map1f(self: *const @This(), _target: GLenum, _u1: GLfloat, _u2: GLfloat, _stride: GLint, _order: GLint, _points: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glMap1f");
            defer zone.End();
            const result = self.dispatch.glMap1f(_target, _u1, _u2, _stride, _order, _points);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn map2d(self: *const @This(), _target: GLenum, _u1: GLdouble, _u2: GLdouble, _ustride: GLint, _uorder: GLint, _v1: GLdouble, _v2: GLdouble, _vstride: GLint, _vorder: GLint, _points: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glMap2d");
            defer zone.End();
            const result = self.dispatch.glMap2d(_target, _u1, _u2, _ustride, _uorder, _v1, _v2, _vstride, _vorder, _points);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn map2f(self: *const @This(), _target: GLenum, _u1: GLfloat, _u2: GLfloat, _ustride: GLint, _uorder: GLint, _v1: GLfloat, _v2: GLfloat, _vstride: GLint, _vorder: GLint, _points: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glMap2f");
            defer zone.End();
            const result = self.dispatch.glMap2f(_target, _u1, _u2, _ustride, _uorder, _v1, _v2, _vstride, _vorder, _points);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn mapGrid1d(self: *const @This(), _un: GLint, _u1: GLdouble, _u2: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glMapGrid1d");
            defer zone.End();
            const result = self.dispatch.glMapGrid1d(_un, _u1, _u2);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn mapGrid1f(self: *const @This(), _un: GLint, _u1: GLfloat, _u2: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glMapGrid1f");
            defer zone.End();
            const result = self.dispatch.glMapGrid1f(_un, _u1, _u2);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn mapGrid2d(self: *const @This(), _un: GLint, _u1: GLdouble, _u2: GLdouble, _vn: GLint, _v1: GLdouble, _v2: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glMapGrid2d");
            defer zone.End();
            const result = self.dispatch.glMapGrid2d(_un, _u1, _u2, _vn, _v1, _v2);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn mapGrid2f(self: *const @This(), _un: GLint, _u1: GLfloat, _u2: GLfloat, _vn: GLint, _v1: GLfloat, _v2: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glMapGrid2f");
            defer zone.End();
            const result = self.dispatch.glMapGrid2f(_un, _u1, _u2, _vn, _v1, _v2);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn evalCoord1d(self: *const @This(), _u: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glEvalCoord1d");
            defer zone.End();
            const result = self.dispatch.glEvalCoord1d(_u);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn evalCoord1dv(self: *const @This(), _u: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glEvalCoord1dv");
            defer zone.End();
            const result = self.dispatch.glEvalCoord1dv(_u);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn evalCoord1f(self: *const @This(), _u: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glEvalCoord1f");
            defer zone.End();
            const result = self.dispatch.glEvalCoord1f(_u);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn evalCoord1fv(self: *const @This(), _u: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glEvalCoord1fv");
            defer zone.End();
            const result = self.dispatch.glEvalCoord1fv(_u);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn evalCoord2d(self: *const @This(), _u: GLdouble, _v: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glEvalCoord2d");
            defer zone.End();
            const result = self.dispatch.glEvalCoord2d(_u, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn evalCoord2dv(self: *const @This(), _u: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glEvalCoord2dv");
            defer zone.End();
            const result = self.dispatch.glEvalCoord2dv(_u);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn evalCoord2f(self: *const @This(), _u: GLfloat, _v: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glEvalCoord2f");
            defer zone.End();
            const result = self.dispatch.glEvalCoord2f(_u, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn evalCoord2fv(self: *const @This(), _u: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glEvalCoord2fv");
            defer zone.End();
            const result = self.dispatch.glEvalCoord2fv(_u);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn evalMesh1(self: *const @This(), _mode: GLenum, _i1: GLint, _i2: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glEvalMesh1");
            defer zone.End();
            const result = self.dispatch.glEvalMesh1(_mode, _i1, _i2);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn evalPoint1(self: *const @This(), _i: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glEvalPoint1");
            defer zone.End();
            const result = self.dispatch.glEvalPoint1(_i);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn evalMesh2(self: *const @This(), _mode: GLenum, _i1: GLint, _i2: GLint, _j1: GLint, _j2: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glEvalMesh2");
            defer zone.End();
            const result = self.dispatch.glEvalMesh2(_mode, _i1, _i2, _j1, _j2);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn evalPoint2(self: *const @This(), _i: GLint, _j: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glEvalPoint2");
            defer zone.End();
            const result = self.dispatch.glEvalPoint2(_i, _j);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn alphaFunc(self: *const @This(), _func: GLenum, _ref: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glAlphaFunc");
            defer zone.End();
            const result = self.dispatch.glAlphaFunc(_func, _ref);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn pixelZoom(self: *const @This(), _xfactor: GLfloat, _yfactor: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glPixelZoom");
            defer zone.End();
            const result = self.dispatch.glPixelZoom(_xfactor, _yfactor);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn pixelTransferf(self: *const @This(), _pname: GLenum, _param: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glPixelTransferf");
            defer zone.End();
            const result = self.dispatch.glPixelTransferf(_pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn pixelTransferi(self: *const @This(), _pname: GLenum, _param: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glPixelTransferi");
            defer zone.End();
            const result = self.dispatch.glPixelTransferi(_pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn pixelMapfv(self: *const @This(), _map: GLenum, _mapsize: GLsizei, _values: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glPixelMapfv");
            defer zone.End();
            const result = self.dispatch.glPixelMapfv(_map, _mapsize, _values);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn pixelMapuiv(self: *const @This(), _map: GLenum, _mapsize: GLsizei, _values: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glPixelMapuiv");
            defer zone.End();
            const result = self.dispatch.glPixelMapuiv(_map, _mapsize, _values);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn pixelMapusv(self: *const @This(), _map: GLenum, _mapsize: GLsizei, _values: [*c]const GLushort) Error!void {
            const zone = tracy.ZoneN(@src(), "glPixelMapusv");
            defer zone.End();
            const result = self.dispatch.glPixelMapusv(_map, _mapsize, _values);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn copyPixels(self: *const @This(), _x: GLint, _y: GLint, _width: GLsizei, _height: GLsizei, _type: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glCopyPixels");
            defer zone.End();
            const result = self.dispatch.glCopyPixels(_x, _y, _width, _height, _type);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn drawPixels(self: *const @This(), _width: GLsizei, _height: GLsizei, _format: GLenum, _type: GLenum, _pixels: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glDrawPixels");
            defer zone.End();
            const result = self.dispatch.glDrawPixels(_width, _height, _format, _type, _pixels);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getClipPlane(self: *const @This(), _plane: GLenum, _equation: [*c]GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetClipPlane");
            defer zone.End();
            const result = self.dispatch.glGetClipPlane(_plane, _equation);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getLightfv(self: *const @This(), _light: GLenum, _pname: GLenum, _params: [*c]GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetLightfv");
            defer zone.End();
            const result = self.dispatch.glGetLightfv(_light, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getLightiv(self: *const @This(), _light: GLenum, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetLightiv");
            defer zone.End();
            const result = self.dispatch.glGetLightiv(_light, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getMapdv(self: *const @This(), _target: GLenum, _query: GLenum, _v: [*c]GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetMapdv");
            defer zone.End();
            const result = self.dispatch.glGetMapdv(_target, _query, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getMapfv(self: *const @This(), _target: GLenum, _query: GLenum, _v: [*c]GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetMapfv");
            defer zone.End();
            const result = self.dispatch.glGetMapfv(_target, _query, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getMapiv(self: *const @This(), _target: GLenum, _query: GLenum, _v: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetMapiv");
            defer zone.End();
            const result = self.dispatch.glGetMapiv(_target, _query, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getMaterialfv(self: *const @This(), _face: GLenum, _pname: GLenum, _params: [*c]GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetMaterialfv");
            defer zone.End();
            const result = self.dispatch.glGetMaterialfv(_face, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getMaterialiv(self: *const @This(), _face: GLenum, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetMaterialiv");
            defer zone.End();
            const result = self.dispatch.glGetMaterialiv(_face, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getPixelMapfv(self: *const @This(), _map: GLenum, _values: [*c]GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetPixelMapfv");
            defer zone.End();
            const result = self.dispatch.glGetPixelMapfv(_map, _values);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getPixelMapuiv(self: *const @This(), _map: GLenum, _values: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetPixelMapuiv");
            defer zone.End();
            const result = self.dispatch.glGetPixelMapuiv(_map, _values);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getPixelMapusv(self: *const @This(), _map: GLenum, _values: [*c]GLushort) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetPixelMapusv");
            defer zone.End();
            const result = self.dispatch.glGetPixelMapusv(_map, _values);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getPolygonStipple(self: *const @This(), _mask: [*c]GLubyte) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetPolygonStipple");
            defer zone.End();
            const result = self.dispatch.glGetPolygonStipple(_mask);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getTexEnvfv(self: *const @This(), _target: GLenum, _pname: GLenum, _params: [*c]GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetTexEnvfv");
            defer zone.End();
            const result = self.dispatch.glGetTexEnvfv(_target, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getTexEnviv(self: *const @This(), _target: GLenum, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetTexEnviv");
            defer zone.End();
            const result = self.dispatch.glGetTexEnviv(_target, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getTexGendv(self: *const @This(), _coord: GLenum, _pname: GLenum, _params: [*c]GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetTexGendv");
            defer zone.End();
            const result = self.dispatch.glGetTexGendv(_coord, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getTexGenfv(self: *const @This(), _coord: GLenum, _pname: GLenum, _params: [*c]GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetTexGenfv");
            defer zone.End();
            const result = self.dispatch.glGetTexGenfv(_coord, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getTexGeniv(self: *const @This(), _coord: GLenum, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetTexGeniv");
            defer zone.End();
            const result = self.dispatch.glGetTexGeniv(_coord, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn isList(self: *const @This(), _list: GLuint) Error!GLboolean {
            const zone = tracy.ZoneN(@src(), "glIsList");
            defer zone.End();
            const result = self.dispatch.glIsList(_list);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn frustum(self: *const @This(), _left: GLdouble, _right: GLdouble, _bottom: GLdouble, _top: GLdouble, _zNear: GLdouble, _zFar: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glFrustum");
            defer zone.End();
            const result = self.dispatch.glFrustum(_left, _right, _bottom, _top, _zNear, _zFar);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn loadIdentity(self: *const @This()) Error!void {
            const zone = tracy.ZoneN(@src(), "glLoadIdentity");
            defer zone.End();
            const result = self.dispatch.glLoadIdentity();
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn loadMatrixf(self: *const @This(), _m: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glLoadMatrixf");
            defer zone.End();
            const result = self.dispatch.glLoadMatrixf(_m);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn loadMatrixd(self: *const @This(), _m: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glLoadMatrixd");
            defer zone.End();
            const result = self.dispatch.glLoadMatrixd(_m);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn matrixMode(self: *const @This(), _mode: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glMatrixMode");
            defer zone.End();
            const result = self.dispatch.glMatrixMode(_mode);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multMatrixf(self: *const @This(), _m: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultMatrixf");
            defer zone.End();
            const result = self.dispatch.glMultMatrixf(_m);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multMatrixd(self: *const @This(), _m: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultMatrixd");
            defer zone.End();
            const result = self.dispatch.glMultMatrixd(_m);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn ortho(self: *const @This(), _left: GLdouble, _right: GLdouble, _bottom: GLdouble, _top: GLdouble, _zNear: GLdouble, _zFar: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glOrtho");
            defer zone.End();
            const result = self.dispatch.glOrtho(_left, _right, _bottom, _top, _zNear, _zFar);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn popMatrix(self: *const @This()) Error!void {
            const zone = tracy.ZoneN(@src(), "glPopMatrix");
            defer zone.End();
            const result = self.dispatch.glPopMatrix();
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn pushMatrix(self: *const @This()) Error!void {
            const zone = tracy.ZoneN(@src(), "glPushMatrix");
            defer zone.End();
            const result = self.dispatch.glPushMatrix();
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rotated(self: *const @This(), _angle: GLdouble, _x: GLdouble, _y: GLdouble, _z: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glRotated");
            defer zone.End();
            const result = self.dispatch.glRotated(_angle, _x, _y, _z);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rotatef(self: *const @This(), _angle: GLfloat, _x: GLfloat, _y: GLfloat, _z: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glRotatef");
            defer zone.End();
            const result = self.dispatch.glRotatef(_angle, _x, _y, _z);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn scaled(self: *const @This(), _x: GLdouble, _y: GLdouble, _z: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glScaled");
            defer zone.End();
            const result = self.dispatch.glScaled(_x, _y, _z);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn scalef(self: *const @This(), _x: GLfloat, _y: GLfloat, _z: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glScalef");
            defer zone.End();
            const result = self.dispatch.glScalef(_x, _y, _z);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn translated(self: *const @This(), _x: GLdouble, _y: GLdouble, _z: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glTranslated");
            defer zone.End();
            const result = self.dispatch.glTranslated(_x, _y, _z);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn translatef(self: *const @This(), _x: GLfloat, _y: GLfloat, _z: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glTranslatef");
            defer zone.End();
            const result = self.dispatch.glTranslatef(_x, _y, _z);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn drawArrays(self: *const @This(), _mode: GLenum, _first: GLint, _count: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glDrawArrays");
            defer zone.End();
            const result = self.dispatch.glDrawArrays(_mode, _first, _count);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn drawElements(self: *const @This(), _mode: GLenum, _count: GLsizei, _type: GLenum, _indices: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glDrawElements");
            defer zone.End();
            const result = self.dispatch.glDrawElements(_mode, _count, _type, _indices);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getPointerv(self: *const @This(), _pname: GLenum, _params: ?*?*anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetPointerv");
            defer zone.End();
            const result = self.dispatch.glGetPointerv(_pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn polygonOffset(self: *const @This(), _factor: GLfloat, _units: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glPolygonOffset");
            defer zone.End();
            const result = self.dispatch.glPolygonOffset(_factor, _units);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn copyTexImage1D(self: *const @This(), _target: GLenum, _level: GLint, _internalformat: GLenum, _x: GLint, _y: GLint, _width: GLsizei, _border: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glCopyTexImage1D");
            defer zone.End();
            const result = self.dispatch.glCopyTexImage1D(_target, _level, _internalformat, _x, _y, _width, _border);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn copyTexImage2D(self: *const @This(), _target: GLenum, _level: GLint, _internalformat: GLenum, _x: GLint, _y: GLint, _width: GLsizei, _height: GLsizei, _border: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glCopyTexImage2D");
            defer zone.End();
            const result = self.dispatch.glCopyTexImage2D(_target, _level, _internalformat, _x, _y, _width, _height, _border);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn copyTexSubImage1D(self: *const @This(), _target: GLenum, _level: GLint, _xoffset: GLint, _x: GLint, _y: GLint, _width: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glCopyTexSubImage1D");
            defer zone.End();
            const result = self.dispatch.glCopyTexSubImage1D(_target, _level, _xoffset, _x, _y, _width);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn copyTexSubImage2D(self: *const @This(), _target: GLenum, _level: GLint, _xoffset: GLint, _yoffset: GLint, _x: GLint, _y: GLint, _width: GLsizei, _height: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glCopyTexSubImage2D");
            defer zone.End();
            const result = self.dispatch.glCopyTexSubImage2D(_target, _level, _xoffset, _yoffset, _x, _y, _width, _height);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texSubImage1D(self: *const @This(), _target: GLenum, _level: GLint, _xoffset: GLint, _width: GLsizei, _format: GLenum, _type: GLenum, _pixels: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexSubImage1D");
            defer zone.End();
            const result = self.dispatch.glTexSubImage1D(_target, _level, _xoffset, _width, _format, _type, _pixels);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texSubImage2D(self: *const @This(), _target: GLenum, _level: GLint, _xoffset: GLint, _yoffset: GLint, _width: GLsizei, _height: GLsizei, _format: GLenum, _type: GLenum, _pixels: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexSubImage2D");
            defer zone.End();
            const result = self.dispatch.glTexSubImage2D(_target, _level, _xoffset, _yoffset, _width, _height, _format, _type, _pixels);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn bindTexture(self: *const @This(), _target: GLenum, _texture: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glBindTexture");
            defer zone.End();
            const result = self.dispatch.glBindTexture(_target, _texture);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn deleteTextures(self: *const @This(), _n: GLsizei, _textures: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glDeleteTextures");
            defer zone.End();
            const result = self.dispatch.glDeleteTextures(_n, _textures);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn genTextures(self: *const @This(), _n: GLsizei, _textures: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGenTextures");
            defer zone.End();
            const result = self.dispatch.glGenTextures(_n, _textures);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn isTexture(self: *const @This(), _texture: GLuint) Error!GLboolean {
            const zone = tracy.ZoneN(@src(), "glIsTexture");
            defer zone.End();
            const result = self.dispatch.glIsTexture(_texture);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn arrayElement(self: *const @This(), _i: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glArrayElement");
            defer zone.End();
            const result = self.dispatch.glArrayElement(_i);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn colorPointer(self: *const @This(), _size: GLint, _type: GLenum, _stride: GLsizei, _pointer: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glColorPointer");
            defer zone.End();
            const result = self.dispatch.glColorPointer(_size, _type, _stride, _pointer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn disableClientState(self: *const @This(), _array: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glDisableClientState");
            defer zone.End();
            const result = self.dispatch.glDisableClientState(_array);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn edgeFlagPointer(self: *const @This(), _stride: GLsizei, _pointer: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glEdgeFlagPointer");
            defer zone.End();
            const result = self.dispatch.glEdgeFlagPointer(_stride, _pointer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn enableClientState(self: *const @This(), _array: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glEnableClientState");
            defer zone.End();
            const result = self.dispatch.glEnableClientState(_array);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn indexPointer(self: *const @This(), _type: GLenum, _stride: GLsizei, _pointer: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glIndexPointer");
            defer zone.End();
            const result = self.dispatch.glIndexPointer(_type, _stride, _pointer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn interleavedArrays(self: *const @This(), _format: GLenum, _stride: GLsizei, _pointer: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glInterleavedArrays");
            defer zone.End();
            const result = self.dispatch.glInterleavedArrays(_format, _stride, _pointer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn normalPointer(self: *const @This(), _type: GLenum, _stride: GLsizei, _pointer: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glNormalPointer");
            defer zone.End();
            const result = self.dispatch.glNormalPointer(_type, _stride, _pointer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoordPointer(self: *const @This(), _size: GLint, _type: GLenum, _stride: GLsizei, _pointer: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoordPointer");
            defer zone.End();
            const result = self.dispatch.glTexCoordPointer(_size, _type, _stride, _pointer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexPointer(self: *const @This(), _size: GLint, _type: GLenum, _stride: GLsizei, _pointer: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexPointer");
            defer zone.End();
            const result = self.dispatch.glVertexPointer(_size, _type, _stride, _pointer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn areTexturesResident(self: *const @This(), _n: GLsizei, _textures: [*c]const GLuint, _residences: [*c]GLboolean) Error!GLboolean {
            const zone = tracy.ZoneN(@src(), "glAreTexturesResident");
            defer zone.End();
            const result = self.dispatch.glAreTexturesResident(_n, _textures, _residences);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn prioritizeTextures(self: *const @This(), _n: GLsizei, _textures: [*c]const GLuint, _priorities: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glPrioritizeTextures");
            defer zone.End();
            const result = self.dispatch.glPrioritizeTextures(_n, _textures, _priorities);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn indexub(self: *const @This(), _c: GLubyte) Error!void {
            const zone = tracy.ZoneN(@src(), "glIndexub");
            defer zone.End();
            const result = self.dispatch.glIndexub(_c);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn indexubv(self: *const @This(), _c: ?[*:0]const GLubyte) Error!void {
            const zone = tracy.ZoneN(@src(), "glIndexubv");
            defer zone.End();
            const result = self.dispatch.glIndexubv(_c);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn popClientAttrib(self: *const @This()) Error!void {
            const zone = tracy.ZoneN(@src(), "glPopClientAttrib");
            defer zone.End();
            const result = self.dispatch.glPopClientAttrib();
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn pushClientAttrib(self: *const @This(), _mask: GLbitfield) Error!void {
            const zone = tracy.ZoneN(@src(), "glPushClientAttrib");
            defer zone.End();
            const result = self.dispatch.glPushClientAttrib(_mask);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn drawRangeElements(self: *const @This(), _mode: GLenum, _start: GLuint, _end: GLuint, _count: GLsizei, _type: GLenum, _indices: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glDrawRangeElements");
            defer zone.End();
            const result = self.dispatch.glDrawRangeElements(_mode, _start, _end, _count, _type, _indices);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texImage3D(self: *const @This(), _target: GLenum, _level: GLint, _internalformat: GLint, _width: GLsizei, _height: GLsizei, _depth: GLsizei, _border: GLint, _format: GLenum, _type: GLenum, _pixels: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexImage3D");
            defer zone.End();
            const result = self.dispatch.glTexImage3D(_target, _level, _internalformat, _width, _height, _depth, _border, _format, _type, _pixels);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texSubImage3D(self: *const @This(), _target: GLenum, _level: GLint, _xoffset: GLint, _yoffset: GLint, _zoffset: GLint, _width: GLsizei, _height: GLsizei, _depth: GLsizei, _format: GLenum, _type: GLenum, _pixels: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexSubImage3D");
            defer zone.End();
            const result = self.dispatch.glTexSubImage3D(_target, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _type, _pixels);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn copyTexSubImage3D(self: *const @This(), _target: GLenum, _level: GLint, _xoffset: GLint, _yoffset: GLint, _zoffset: GLint, _x: GLint, _y: GLint, _width: GLsizei, _height: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glCopyTexSubImage3D");
            defer zone.End();
            const result = self.dispatch.glCopyTexSubImage3D(_target, _level, _xoffset, _yoffset, _zoffset, _x, _y, _width, _height);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn activeTexture(self: *const @This(), _texture: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glActiveTexture");
            defer zone.End();
            const result = self.dispatch.glActiveTexture(_texture);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn sampleCoverage(self: *const @This(), _value: GLfloat, _invert: GLboolean) Error!void {
            const zone = tracy.ZoneN(@src(), "glSampleCoverage");
            defer zone.End();
            const result = self.dispatch.glSampleCoverage(_value, _invert);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn compressedTexImage3D(self: *const @This(), _target: GLenum, _level: GLint, _internalformat: GLenum, _width: GLsizei, _height: GLsizei, _depth: GLsizei, _border: GLint, _imageSize: GLsizei, _data: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glCompressedTexImage3D");
            defer zone.End();
            const result = self.dispatch.glCompressedTexImage3D(_target, _level, _internalformat, _width, _height, _depth, _border, _imageSize, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn compressedTexImage2D(self: *const @This(), _target: GLenum, _level: GLint, _internalformat: GLenum, _width: GLsizei, _height: GLsizei, _border: GLint, _imageSize: GLsizei, _data: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glCompressedTexImage2D");
            defer zone.End();
            const result = self.dispatch.glCompressedTexImage2D(_target, _level, _internalformat, _width, _height, _border, _imageSize, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn compressedTexImage1D(self: *const @This(), _target: GLenum, _level: GLint, _internalformat: GLenum, _width: GLsizei, _border: GLint, _imageSize: GLsizei, _data: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glCompressedTexImage1D");
            defer zone.End();
            const result = self.dispatch.glCompressedTexImage1D(_target, _level, _internalformat, _width, _border, _imageSize, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn compressedTexSubImage3D(self: *const @This(), _target: GLenum, _level: GLint, _xoffset: GLint, _yoffset: GLint, _zoffset: GLint, _width: GLsizei, _height: GLsizei, _depth: GLsizei, _format: GLenum, _imageSize: GLsizei, _data: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glCompressedTexSubImage3D");
            defer zone.End();
            const result = self.dispatch.glCompressedTexSubImage3D(_target, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _imageSize, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn compressedTexSubImage2D(self: *const @This(), _target: GLenum, _level: GLint, _xoffset: GLint, _yoffset: GLint, _width: GLsizei, _height: GLsizei, _format: GLenum, _imageSize: GLsizei, _data: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glCompressedTexSubImage2D");
            defer zone.End();
            const result = self.dispatch.glCompressedTexSubImage2D(_target, _level, _xoffset, _yoffset, _width, _height, _format, _imageSize, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn compressedTexSubImage1D(self: *const @This(), _target: GLenum, _level: GLint, _xoffset: GLint, _width: GLsizei, _format: GLenum, _imageSize: GLsizei, _data: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glCompressedTexSubImage1D");
            defer zone.End();
            const result = self.dispatch.glCompressedTexSubImage1D(_target, _level, _xoffset, _width, _format, _imageSize, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getCompressedTexImage(self: *const @This(), _target: GLenum, _level: GLint, _img: ?*anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetCompressedTexImage");
            defer zone.End();
            const result = self.dispatch.glGetCompressedTexImage(_target, _level, _img);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clientActiveTexture(self: *const @This(), _texture: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glClientActiveTexture");
            defer zone.End();
            const result = self.dispatch.glClientActiveTexture(_texture);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord1d(self: *const @This(), _target: GLenum, _s: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord1d");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord1d(_target, _s);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord1dv(self: *const @This(), _target: GLenum, _v: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord1dv");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord1dv(_target, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord1f(self: *const @This(), _target: GLenum, _s: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord1f");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord1f(_target, _s);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord1fv(self: *const @This(), _target: GLenum, _v: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord1fv");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord1fv(_target, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord1i(self: *const @This(), _target: GLenum, _s: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord1i");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord1i(_target, _s);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord1iv(self: *const @This(), _target: GLenum, _v: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord1iv");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord1iv(_target, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord1s(self: *const @This(), _target: GLenum, _s: GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord1s");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord1s(_target, _s);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord1sv(self: *const @This(), _target: GLenum, _v: [*c]const GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord1sv");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord1sv(_target, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord2d(self: *const @This(), _target: GLenum, _s: GLdouble, _t: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord2d");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord2d(_target, _s, _t);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord2dv(self: *const @This(), _target: GLenum, _v: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord2dv");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord2dv(_target, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord2f(self: *const @This(), _target: GLenum, _s: GLfloat, _t: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord2f");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord2f(_target, _s, _t);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord2fv(self: *const @This(), _target: GLenum, _v: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord2fv");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord2fv(_target, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord2i(self: *const @This(), _target: GLenum, _s: GLint, _t: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord2i");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord2i(_target, _s, _t);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord2iv(self: *const @This(), _target: GLenum, _v: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord2iv");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord2iv(_target, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord2s(self: *const @This(), _target: GLenum, _s: GLshort, _t: GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord2s");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord2s(_target, _s, _t);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord2sv(self: *const @This(), _target: GLenum, _v: [*c]const GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord2sv");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord2sv(_target, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord3d(self: *const @This(), _target: GLenum, _s: GLdouble, _t: GLdouble, _r: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord3d");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord3d(_target, _s, _t, _r);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord3dv(self: *const @This(), _target: GLenum, _v: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord3dv");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord3dv(_target, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord3f(self: *const @This(), _target: GLenum, _s: GLfloat, _t: GLfloat, _r: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord3f");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord3f(_target, _s, _t, _r);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord3fv(self: *const @This(), _target: GLenum, _v: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord3fv");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord3fv(_target, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord3i(self: *const @This(), _target: GLenum, _s: GLint, _t: GLint, _r: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord3i");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord3i(_target, _s, _t, _r);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord3iv(self: *const @This(), _target: GLenum, _v: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord3iv");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord3iv(_target, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord3s(self: *const @This(), _target: GLenum, _s: GLshort, _t: GLshort, _r: GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord3s");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord3s(_target, _s, _t, _r);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord3sv(self: *const @This(), _target: GLenum, _v: [*c]const GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord3sv");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord3sv(_target, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord4d(self: *const @This(), _target: GLenum, _s: GLdouble, _t: GLdouble, _r: GLdouble, _q: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord4d");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord4d(_target, _s, _t, _r, _q);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord4dv(self: *const @This(), _target: GLenum, _v: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord4dv");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord4dv(_target, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord4f(self: *const @This(), _target: GLenum, _s: GLfloat, _t: GLfloat, _r: GLfloat, _q: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord4f");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord4f(_target, _s, _t, _r, _q);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord4fv(self: *const @This(), _target: GLenum, _v: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord4fv");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord4fv(_target, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord4i(self: *const @This(), _target: GLenum, _s: GLint, _t: GLint, _r: GLint, _q: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord4i");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord4i(_target, _s, _t, _r, _q);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord4iv(self: *const @This(), _target: GLenum, _v: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord4iv");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord4iv(_target, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord4s(self: *const @This(), _target: GLenum, _s: GLshort, _t: GLshort, _r: GLshort, _q: GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord4s");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord4s(_target, _s, _t, _r, _q);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord4sv(self: *const @This(), _target: GLenum, _v: [*c]const GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord4sv");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord4sv(_target, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn loadTransposeMatrixf(self: *const @This(), _m: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glLoadTransposeMatrixf");
            defer zone.End();
            const result = self.dispatch.glLoadTransposeMatrixf(_m);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn loadTransposeMatrixd(self: *const @This(), _m: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glLoadTransposeMatrixd");
            defer zone.End();
            const result = self.dispatch.glLoadTransposeMatrixd(_m);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multTransposeMatrixf(self: *const @This(), _m: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultTransposeMatrixf");
            defer zone.End();
            const result = self.dispatch.glMultTransposeMatrixf(_m);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multTransposeMatrixd(self: *const @This(), _m: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultTransposeMatrixd");
            defer zone.End();
            const result = self.dispatch.glMultTransposeMatrixd(_m);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn blendFuncSeparate(self: *const @This(), _sfactorRGB: GLenum, _dfactorRGB: GLenum, _sfactorAlpha: GLenum, _dfactorAlpha: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glBlendFuncSeparate");
            defer zone.End();
            const result = self.dispatch.glBlendFuncSeparate(_sfactorRGB, _dfactorRGB, _sfactorAlpha, _dfactorAlpha);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiDrawArrays(self: *const @This(), _mode: GLenum, _first: [*c]const GLint, _count: [*c]const GLsizei, _drawcount: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiDrawArrays");
            defer zone.End();
            const result = self.dispatch.glMultiDrawArrays(_mode, _first, _count, _drawcount);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiDrawElements(self: *const @This(), _mode: GLenum, _count: [*c]const GLsizei, _type: GLenum, _indices: [*c]const ?*const anyopaque, _drawcount: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiDrawElements");
            defer zone.End();
            const result = self.dispatch.glMultiDrawElements(_mode, _count, _type, _indices, _drawcount);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn pointParameterf(self: *const @This(), _pname: GLenum, _param: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glPointParameterf");
            defer zone.End();
            const result = self.dispatch.glPointParameterf(_pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn pointParameterfv(self: *const @This(), _pname: GLenum, _params: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glPointParameterfv");
            defer zone.End();
            const result = self.dispatch.glPointParameterfv(_pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn pointParameteri(self: *const @This(), _pname: GLenum, _param: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glPointParameteri");
            defer zone.End();
            const result = self.dispatch.glPointParameteri(_pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn pointParameteriv(self: *const @This(), _pname: GLenum, _params: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glPointParameteriv");
            defer zone.End();
            const result = self.dispatch.glPointParameteriv(_pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn fogCoordf(self: *const @This(), _coord: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glFogCoordf");
            defer zone.End();
            const result = self.dispatch.glFogCoordf(_coord);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn fogCoordfv(self: *const @This(), _coord: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glFogCoordfv");
            defer zone.End();
            const result = self.dispatch.glFogCoordfv(_coord);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn fogCoordd(self: *const @This(), _coord: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glFogCoordd");
            defer zone.End();
            const result = self.dispatch.glFogCoordd(_coord);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn fogCoorddv(self: *const @This(), _coord: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glFogCoorddv");
            defer zone.End();
            const result = self.dispatch.glFogCoorddv(_coord);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn fogCoordPointer(self: *const @This(), _type: GLenum, _stride: GLsizei, _pointer: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glFogCoordPointer");
            defer zone.End();
            const result = self.dispatch.glFogCoordPointer(_type, _stride, _pointer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn secondaryColor3b(self: *const @This(), _red: GLbyte, _green: GLbyte, _blue: GLbyte) Error!void {
            const zone = tracy.ZoneN(@src(), "glSecondaryColor3b");
            defer zone.End();
            const result = self.dispatch.glSecondaryColor3b(_red, _green, _blue);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn secondaryColor3bv(self: *const @This(), _v: [*c]const GLbyte) Error!void {
            const zone = tracy.ZoneN(@src(), "glSecondaryColor3bv");
            defer zone.End();
            const result = self.dispatch.glSecondaryColor3bv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn secondaryColor3d(self: *const @This(), _red: GLdouble, _green: GLdouble, _blue: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glSecondaryColor3d");
            defer zone.End();
            const result = self.dispatch.glSecondaryColor3d(_red, _green, _blue);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn secondaryColor3dv(self: *const @This(), _v: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glSecondaryColor3dv");
            defer zone.End();
            const result = self.dispatch.glSecondaryColor3dv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn secondaryColor3f(self: *const @This(), _red: GLfloat, _green: GLfloat, _blue: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glSecondaryColor3f");
            defer zone.End();
            const result = self.dispatch.glSecondaryColor3f(_red, _green, _blue);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn secondaryColor3fv(self: *const @This(), _v: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glSecondaryColor3fv");
            defer zone.End();
            const result = self.dispatch.glSecondaryColor3fv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn secondaryColor3i(self: *const @This(), _red: GLint, _green: GLint, _blue: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glSecondaryColor3i");
            defer zone.End();
            const result = self.dispatch.glSecondaryColor3i(_red, _green, _blue);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn secondaryColor3iv(self: *const @This(), _v: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glSecondaryColor3iv");
            defer zone.End();
            const result = self.dispatch.glSecondaryColor3iv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn secondaryColor3s(self: *const @This(), _red: GLshort, _green: GLshort, _blue: GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glSecondaryColor3s");
            defer zone.End();
            const result = self.dispatch.glSecondaryColor3s(_red, _green, _blue);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn secondaryColor3sv(self: *const @This(), _v: [*c]const GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glSecondaryColor3sv");
            defer zone.End();
            const result = self.dispatch.glSecondaryColor3sv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn secondaryColor3ub(self: *const @This(), _red: GLubyte, _green: GLubyte, _blue: GLubyte) Error!void {
            const zone = tracy.ZoneN(@src(), "glSecondaryColor3ub");
            defer zone.End();
            const result = self.dispatch.glSecondaryColor3ub(_red, _green, _blue);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn secondaryColor3ubv(self: *const @This(), _v: ?[*:0]const GLubyte) Error!void {
            const zone = tracy.ZoneN(@src(), "glSecondaryColor3ubv");
            defer zone.End();
            const result = self.dispatch.glSecondaryColor3ubv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn secondaryColor3ui(self: *const @This(), _red: GLuint, _green: GLuint, _blue: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glSecondaryColor3ui");
            defer zone.End();
            const result = self.dispatch.glSecondaryColor3ui(_red, _green, _blue);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn secondaryColor3uiv(self: *const @This(), _v: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glSecondaryColor3uiv");
            defer zone.End();
            const result = self.dispatch.glSecondaryColor3uiv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn secondaryColor3us(self: *const @This(), _red: GLushort, _green: GLushort, _blue: GLushort) Error!void {
            const zone = tracy.ZoneN(@src(), "glSecondaryColor3us");
            defer zone.End();
            const result = self.dispatch.glSecondaryColor3us(_red, _green, _blue);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn secondaryColor3usv(self: *const @This(), _v: [*c]const GLushort) Error!void {
            const zone = tracy.ZoneN(@src(), "glSecondaryColor3usv");
            defer zone.End();
            const result = self.dispatch.glSecondaryColor3usv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn secondaryColorPointer(self: *const @This(), _size: GLint, _type: GLenum, _stride: GLsizei, _pointer: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glSecondaryColorPointer");
            defer zone.End();
            const result = self.dispatch.glSecondaryColorPointer(_size, _type, _stride, _pointer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn windowPos2d(self: *const @This(), _x: GLdouble, _y: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glWindowPos2d");
            defer zone.End();
            const result = self.dispatch.glWindowPos2d(_x, _y);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn windowPos2dv(self: *const @This(), _v: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glWindowPos2dv");
            defer zone.End();
            const result = self.dispatch.glWindowPos2dv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn windowPos2f(self: *const @This(), _x: GLfloat, _y: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glWindowPos2f");
            defer zone.End();
            const result = self.dispatch.glWindowPos2f(_x, _y);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn windowPos2fv(self: *const @This(), _v: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glWindowPos2fv");
            defer zone.End();
            const result = self.dispatch.glWindowPos2fv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn windowPos2i(self: *const @This(), _x: GLint, _y: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glWindowPos2i");
            defer zone.End();
            const result = self.dispatch.glWindowPos2i(_x, _y);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn windowPos2iv(self: *const @This(), _v: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glWindowPos2iv");
            defer zone.End();
            const result = self.dispatch.glWindowPos2iv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn windowPos2s(self: *const @This(), _x: GLshort, _y: GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glWindowPos2s");
            defer zone.End();
            const result = self.dispatch.glWindowPos2s(_x, _y);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn windowPos2sv(self: *const @This(), _v: [*c]const GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glWindowPos2sv");
            defer zone.End();
            const result = self.dispatch.glWindowPos2sv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn windowPos3d(self: *const @This(), _x: GLdouble, _y: GLdouble, _z: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glWindowPos3d");
            defer zone.End();
            const result = self.dispatch.glWindowPos3d(_x, _y, _z);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn windowPos3dv(self: *const @This(), _v: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glWindowPos3dv");
            defer zone.End();
            const result = self.dispatch.glWindowPos3dv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn windowPos3f(self: *const @This(), _x: GLfloat, _y: GLfloat, _z: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glWindowPos3f");
            defer zone.End();
            const result = self.dispatch.glWindowPos3f(_x, _y, _z);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn windowPos3fv(self: *const @This(), _v: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glWindowPos3fv");
            defer zone.End();
            const result = self.dispatch.glWindowPos3fv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn windowPos3i(self: *const @This(), _x: GLint, _y: GLint, _z: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glWindowPos3i");
            defer zone.End();
            const result = self.dispatch.glWindowPos3i(_x, _y, _z);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn windowPos3iv(self: *const @This(), _v: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glWindowPos3iv");
            defer zone.End();
            const result = self.dispatch.glWindowPos3iv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn windowPos3s(self: *const @This(), _x: GLshort, _y: GLshort, _z: GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glWindowPos3s");
            defer zone.End();
            const result = self.dispatch.glWindowPos3s(_x, _y, _z);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn windowPos3sv(self: *const @This(), _v: [*c]const GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glWindowPos3sv");
            defer zone.End();
            const result = self.dispatch.glWindowPos3sv(_v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn blendColor(self: *const @This(), _red: GLfloat, _green: GLfloat, _blue: GLfloat, _alpha: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glBlendColor");
            defer zone.End();
            const result = self.dispatch.glBlendColor(_red, _green, _blue, _alpha);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn blendEquation(self: *const @This(), _mode: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glBlendEquation");
            defer zone.End();
            const result = self.dispatch.glBlendEquation(_mode);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn genQueries(self: *const @This(), _n: GLsizei, _ids: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGenQueries");
            defer zone.End();
            const result = self.dispatch.glGenQueries(_n, _ids);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn deleteQueries(self: *const @This(), _n: GLsizei, _ids: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glDeleteQueries");
            defer zone.End();
            const result = self.dispatch.glDeleteQueries(_n, _ids);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn isQuery(self: *const @This(), _id: GLuint) Error!GLboolean {
            const zone = tracy.ZoneN(@src(), "glIsQuery");
            defer zone.End();
            const result = self.dispatch.glIsQuery(_id);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn beginQuery(self: *const @This(), _target: GLenum, _id: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glBeginQuery");
            defer zone.End();
            const result = self.dispatch.glBeginQuery(_target, _id);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn endQuery(self: *const @This(), _target: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glEndQuery");
            defer zone.End();
            const result = self.dispatch.glEndQuery(_target);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getQueryiv(self: *const @This(), _target: GLenum, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetQueryiv");
            defer zone.End();
            const result = self.dispatch.glGetQueryiv(_target, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getQueryObjectiv(self: *const @This(), _id: GLuint, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetQueryObjectiv");
            defer zone.End();
            const result = self.dispatch.glGetQueryObjectiv(_id, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getQueryObjectuiv(self: *const @This(), _id: GLuint, _pname: GLenum, _params: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetQueryObjectuiv");
            defer zone.End();
            const result = self.dispatch.glGetQueryObjectuiv(_id, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn bindBuffer(self: *const @This(), _target: GLenum, _buffer: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glBindBuffer");
            defer zone.End();
            const result = self.dispatch.glBindBuffer(_target, _buffer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn deleteBuffers(self: *const @This(), _n: GLsizei, _buffers: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glDeleteBuffers");
            defer zone.End();
            const result = self.dispatch.glDeleteBuffers(_n, _buffers);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn genBuffers(self: *const @This(), _n: GLsizei, _buffers: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGenBuffers");
            defer zone.End();
            const result = self.dispatch.glGenBuffers(_n, _buffers);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn isBuffer(self: *const @This(), _buffer: GLuint) Error!GLboolean {
            const zone = tracy.ZoneN(@src(), "glIsBuffer");
            defer zone.End();
            const result = self.dispatch.glIsBuffer(_buffer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn bufferData(self: *const @This(), _target: GLenum, _size: GLsizeiptr, _data: ?*const anyopaque, _usage: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glBufferData");
            defer zone.End();
            const result = self.dispatch.glBufferData(_target, _size, _data, _usage);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn bufferSubData(self: *const @This(), _target: GLenum, _offset: GLintptr, _size: GLsizeiptr, _data: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glBufferSubData");
            defer zone.End();
            const result = self.dispatch.glBufferSubData(_target, _offset, _size, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getBufferSubData(self: *const @This(), _target: GLenum, _offset: GLintptr, _size: GLsizeiptr, _data: ?*anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetBufferSubData");
            defer zone.End();
            const result = self.dispatch.glGetBufferSubData(_target, _offset, _size, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn mapBuffer(self: *const @This(), _target: GLenum, _access: GLenum) Error!?*anyopaque {
            const zone = tracy.ZoneN(@src(), "glMapBuffer");
            defer zone.End();
            const result = self.dispatch.glMapBuffer(_target, _access);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn unmapBuffer(self: *const @This(), _target: GLenum) Error!GLboolean {
            const zone = tracy.ZoneN(@src(), "glUnmapBuffer");
            defer zone.End();
            const result = self.dispatch.glUnmapBuffer(_target);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getBufferParameteriv(self: *const @This(), _target: GLenum, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetBufferParameteriv");
            defer zone.End();
            const result = self.dispatch.glGetBufferParameteriv(_target, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getBufferPointerv(self: *const @This(), _target: GLenum, _pname: GLenum, _params: ?*?*anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetBufferPointerv");
            defer zone.End();
            const result = self.dispatch.glGetBufferPointerv(_target, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn blendEquationSeparate(self: *const @This(), _modeRGB: GLenum, _modeAlpha: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glBlendEquationSeparate");
            defer zone.End();
            const result = self.dispatch.glBlendEquationSeparate(_modeRGB, _modeAlpha);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn drawBuffers(self: *const @This(), _n: GLsizei, _bufs: [*c]const GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glDrawBuffers");
            defer zone.End();
            const result = self.dispatch.glDrawBuffers(_n, _bufs);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn stencilOpSeparate(self: *const @This(), _face: GLenum, _sfail: GLenum, _dpfail: GLenum, _dppass: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glStencilOpSeparate");
            defer zone.End();
            const result = self.dispatch.glStencilOpSeparate(_face, _sfail, _dpfail, _dppass);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn stencilFuncSeparate(self: *const @This(), _face: GLenum, _func: GLenum, _ref: GLint, _mask: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glStencilFuncSeparate");
            defer zone.End();
            const result = self.dispatch.glStencilFuncSeparate(_face, _func, _ref, _mask);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn stencilMaskSeparate(self: *const @This(), _face: GLenum, _mask: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glStencilMaskSeparate");
            defer zone.End();
            const result = self.dispatch.glStencilMaskSeparate(_face, _mask);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn attachShader(self: *const @This(), _program: GLuint, _shader: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glAttachShader");
            defer zone.End();
            const result = self.dispatch.glAttachShader(_program, _shader);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn bindAttribLocation(self: *const @This(), _program: GLuint, _index: GLuint, _name: [*c]const GLchar) Error!void {
            const zone = tracy.ZoneN(@src(), "glBindAttribLocation");
            defer zone.End();
            const result = self.dispatch.glBindAttribLocation(_program, _index, _name);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn compileShader(self: *const @This(), _shader: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glCompileShader");
            defer zone.End();
            const result = self.dispatch.glCompileShader(_shader);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn createProgram(self: *const @This()) Error!GLuint {
            const zone = tracy.ZoneN(@src(), "glCreateProgram");
            defer zone.End();
            const result = self.dispatch.glCreateProgram();
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn createShader(self: *const @This(), _type: GLenum) Error!GLuint {
            const zone = tracy.ZoneN(@src(), "glCreateShader");
            defer zone.End();
            const result = self.dispatch.glCreateShader(_type);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn deleteProgram(self: *const @This(), _program: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glDeleteProgram");
            defer zone.End();
            const result = self.dispatch.glDeleteProgram(_program);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn deleteShader(self: *const @This(), _shader: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glDeleteShader");
            defer zone.End();
            const result = self.dispatch.glDeleteShader(_shader);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn detachShader(self: *const @This(), _program: GLuint, _shader: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glDetachShader");
            defer zone.End();
            const result = self.dispatch.glDetachShader(_program, _shader);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn disableVertexAttribArray(self: *const @This(), _index: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glDisableVertexAttribArray");
            defer zone.End();
            const result = self.dispatch.glDisableVertexAttribArray(_index);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn enableVertexAttribArray(self: *const @This(), _index: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glEnableVertexAttribArray");
            defer zone.End();
            const result = self.dispatch.glEnableVertexAttribArray(_index);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getActiveAttrib(self: *const @This(), _program: GLuint, _index: GLuint, _bufSize: GLsizei, _length: [*c]GLsizei, _size: [*c]GLint, _type: [*c]GLenum, _name: [*c]GLchar) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetActiveAttrib");
            defer zone.End();
            const result = self.dispatch.glGetActiveAttrib(_program, _index, _bufSize, _length, _size, _type, _name);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getActiveUniform(self: *const @This(), _program: GLuint, _index: GLuint, _bufSize: GLsizei, _length: [*c]GLsizei, _size: [*c]GLint, _type: [*c]GLenum, _name: [*c]GLchar) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetActiveUniform");
            defer zone.End();
            const result = self.dispatch.glGetActiveUniform(_program, _index, _bufSize, _length, _size, _type, _name);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getAttachedShaders(self: *const @This(), _program: GLuint, _maxCount: GLsizei, _count: [*c]GLsizei, _shaders: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetAttachedShaders");
            defer zone.End();
            const result = self.dispatch.glGetAttachedShaders(_program, _maxCount, _count, _shaders);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getAttribLocation(self: *const @This(), _program: GLuint, _name: [*c]const GLchar) Error!GLint {
            const zone = tracy.ZoneN(@src(), "glGetAttribLocation");
            defer zone.End();
            const result = self.dispatch.glGetAttribLocation(_program, _name);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getProgramiv(self: *const @This(), _program: GLuint, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetProgramiv");
            defer zone.End();
            const result = self.dispatch.glGetProgramiv(_program, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getProgramInfoLog(self: *const @This(), _program: GLuint, _bufSize: GLsizei, _length: [*c]GLsizei, _infoLog: [*c]GLchar) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetProgramInfoLog");
            defer zone.End();
            const result = self.dispatch.glGetProgramInfoLog(_program, _bufSize, _length, _infoLog);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getShaderiv(self: *const @This(), _shader: GLuint, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetShaderiv");
            defer zone.End();
            const result = self.dispatch.glGetShaderiv(_shader, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getShaderInfoLog(self: *const @This(), _shader: GLuint, _bufSize: GLsizei, _length: [*c]GLsizei, _infoLog: [*c]GLchar) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetShaderInfoLog");
            defer zone.End();
            const result = self.dispatch.glGetShaderInfoLog(_shader, _bufSize, _length, _infoLog);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getShaderSource(self: *const @This(), _shader: GLuint, _bufSize: GLsizei, _length: [*c]GLsizei, _source: [*c]GLchar) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetShaderSource");
            defer zone.End();
            const result = self.dispatch.glGetShaderSource(_shader, _bufSize, _length, _source);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getUniformLocation(self: *const @This(), _program: GLuint, _name: [*c]const GLchar) Error!GLint {
            const zone = tracy.ZoneN(@src(), "glGetUniformLocation");
            defer zone.End();
            const result = self.dispatch.glGetUniformLocation(_program, _name);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getUniformfv(self: *const @This(), _program: GLuint, _location: GLint, _params: [*c]GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetUniformfv");
            defer zone.End();
            const result = self.dispatch.glGetUniformfv(_program, _location, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getUniformiv(self: *const @This(), _program: GLuint, _location: GLint, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetUniformiv");
            defer zone.End();
            const result = self.dispatch.glGetUniformiv(_program, _location, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getVertexAttribdv(self: *const @This(), _index: GLuint, _pname: GLenum, _params: [*c]GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetVertexAttribdv");
            defer zone.End();
            const result = self.dispatch.glGetVertexAttribdv(_index, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getVertexAttribfv(self: *const @This(), _index: GLuint, _pname: GLenum, _params: [*c]GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetVertexAttribfv");
            defer zone.End();
            const result = self.dispatch.glGetVertexAttribfv(_index, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getVertexAttribiv(self: *const @This(), _index: GLuint, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetVertexAttribiv");
            defer zone.End();
            const result = self.dispatch.glGetVertexAttribiv(_index, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getVertexAttribPointerv(self: *const @This(), _index: GLuint, _pname: GLenum, _pointer: ?*?*anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetVertexAttribPointerv");
            defer zone.End();
            const result = self.dispatch.glGetVertexAttribPointerv(_index, _pname, _pointer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn isProgram(self: *const @This(), _program: GLuint) Error!GLboolean {
            const zone = tracy.ZoneN(@src(), "glIsProgram");
            defer zone.End();
            const result = self.dispatch.glIsProgram(_program);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn isShader(self: *const @This(), _shader: GLuint) Error!GLboolean {
            const zone = tracy.ZoneN(@src(), "glIsShader");
            defer zone.End();
            const result = self.dispatch.glIsShader(_shader);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn linkProgram(self: *const @This(), _program: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glLinkProgram");
            defer zone.End();
            const result = self.dispatch.glLinkProgram(_program);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn shaderSource(self: *const @This(), _shader: GLuint, _count: GLsizei, _string: [*c]const [*c]const GLchar, _length: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glShaderSource");
            defer zone.End();
            const result = self.dispatch.glShaderSource(_shader, _count, _string, _length);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn useProgram(self: *const @This(), _program: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glUseProgram");
            defer zone.End();
            const result = self.dispatch.glUseProgram(_program);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform1f(self: *const @This(), _location: GLint, _v0: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform1f");
            defer zone.End();
            const result = self.dispatch.glUniform1f(_location, _v0);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform2f(self: *const @This(), _location: GLint, _v0: GLfloat, _v1: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform2f");
            defer zone.End();
            const result = self.dispatch.glUniform2f(_location, _v0, _v1);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform3f(self: *const @This(), _location: GLint, _v0: GLfloat, _v1: GLfloat, _v2: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform3f");
            defer zone.End();
            const result = self.dispatch.glUniform3f(_location, _v0, _v1, _v2);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform4f(self: *const @This(), _location: GLint, _v0: GLfloat, _v1: GLfloat, _v2: GLfloat, _v3: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform4f");
            defer zone.End();
            const result = self.dispatch.glUniform4f(_location, _v0, _v1, _v2, _v3);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform1i(self: *const @This(), _location: GLint, _v0: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform1i");
            defer zone.End();
            const result = self.dispatch.glUniform1i(_location, _v0);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform2i(self: *const @This(), _location: GLint, _v0: GLint, _v1: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform2i");
            defer zone.End();
            const result = self.dispatch.glUniform2i(_location, _v0, _v1);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform3i(self: *const @This(), _location: GLint, _v0: GLint, _v1: GLint, _v2: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform3i");
            defer zone.End();
            const result = self.dispatch.glUniform3i(_location, _v0, _v1, _v2);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform4i(self: *const @This(), _location: GLint, _v0: GLint, _v1: GLint, _v2: GLint, _v3: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform4i");
            defer zone.End();
            const result = self.dispatch.glUniform4i(_location, _v0, _v1, _v2, _v3);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform1fv(self: *const @This(), _location: GLint, _count: GLsizei, _value: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform1fv");
            defer zone.End();
            const result = self.dispatch.glUniform1fv(_location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform2fv(self: *const @This(), _location: GLint, _count: GLsizei, _value: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform2fv");
            defer zone.End();
            const result = self.dispatch.glUniform2fv(_location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform3fv(self: *const @This(), _location: GLint, _count: GLsizei, _value: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform3fv");
            defer zone.End();
            const result = self.dispatch.glUniform3fv(_location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform4fv(self: *const @This(), _location: GLint, _count: GLsizei, _value: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform4fv");
            defer zone.End();
            const result = self.dispatch.glUniform4fv(_location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform1iv(self: *const @This(), _location: GLint, _count: GLsizei, _value: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform1iv");
            defer zone.End();
            const result = self.dispatch.glUniform1iv(_location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform2iv(self: *const @This(), _location: GLint, _count: GLsizei, _value: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform2iv");
            defer zone.End();
            const result = self.dispatch.glUniform2iv(_location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform3iv(self: *const @This(), _location: GLint, _count: GLsizei, _value: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform3iv");
            defer zone.End();
            const result = self.dispatch.glUniform3iv(_location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform4iv(self: *const @This(), _location: GLint, _count: GLsizei, _value: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform4iv");
            defer zone.End();
            const result = self.dispatch.glUniform4iv(_location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniformMatrix2fv(self: *const @This(), _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniformMatrix2fv");
            defer zone.End();
            const result = self.dispatch.glUniformMatrix2fv(_location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniformMatrix3fv(self: *const @This(), _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniformMatrix3fv");
            defer zone.End();
            const result = self.dispatch.glUniformMatrix3fv(_location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniformMatrix4fv(self: *const @This(), _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniformMatrix4fv");
            defer zone.End();
            const result = self.dispatch.glUniformMatrix4fv(_location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn validateProgram(self: *const @This(), _program: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glValidateProgram");
            defer zone.End();
            const result = self.dispatch.glValidateProgram(_program);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib1d(self: *const @This(), _index: GLuint, _x: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib1d");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib1d(_index, _x);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib1dv(self: *const @This(), _index: GLuint, _v: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib1dv");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib1dv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib1f(self: *const @This(), _index: GLuint, _x: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib1f");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib1f(_index, _x);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib1fv(self: *const @This(), _index: GLuint, _v: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib1fv");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib1fv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib1s(self: *const @This(), _index: GLuint, _x: GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib1s");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib1s(_index, _x);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib1sv(self: *const @This(), _index: GLuint, _v: [*c]const GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib1sv");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib1sv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib2d(self: *const @This(), _index: GLuint, _x: GLdouble, _y: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib2d");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib2d(_index, _x, _y);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib2dv(self: *const @This(), _index: GLuint, _v: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib2dv");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib2dv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib2f(self: *const @This(), _index: GLuint, _x: GLfloat, _y: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib2f");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib2f(_index, _x, _y);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib2fv(self: *const @This(), _index: GLuint, _v: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib2fv");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib2fv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib2s(self: *const @This(), _index: GLuint, _x: GLshort, _y: GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib2s");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib2s(_index, _x, _y);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib2sv(self: *const @This(), _index: GLuint, _v: [*c]const GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib2sv");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib2sv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib3d(self: *const @This(), _index: GLuint, _x: GLdouble, _y: GLdouble, _z: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib3d");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib3d(_index, _x, _y, _z);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib3dv(self: *const @This(), _index: GLuint, _v: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib3dv");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib3dv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib3f(self: *const @This(), _index: GLuint, _x: GLfloat, _y: GLfloat, _z: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib3f");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib3f(_index, _x, _y, _z);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib3fv(self: *const @This(), _index: GLuint, _v: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib3fv");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib3fv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib3s(self: *const @This(), _index: GLuint, _x: GLshort, _y: GLshort, _z: GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib3s");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib3s(_index, _x, _y, _z);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib3sv(self: *const @This(), _index: GLuint, _v: [*c]const GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib3sv");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib3sv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib4Nbv(self: *const @This(), _index: GLuint, _v: [*c]const GLbyte) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib4Nbv");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib4Nbv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib4Niv(self: *const @This(), _index: GLuint, _v: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib4Niv");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib4Niv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib4Nsv(self: *const @This(), _index: GLuint, _v: [*c]const GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib4Nsv");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib4Nsv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib4Nub(self: *const @This(), _index: GLuint, _x: GLubyte, _y: GLubyte, _z: GLubyte, _w: GLubyte) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib4Nub");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib4Nub(_index, _x, _y, _z, _w);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib4Nubv(self: *const @This(), _index: GLuint, _v: ?[*:0]const GLubyte) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib4Nubv");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib4Nubv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib4Nuiv(self: *const @This(), _index: GLuint, _v: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib4Nuiv");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib4Nuiv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib4Nusv(self: *const @This(), _index: GLuint, _v: [*c]const GLushort) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib4Nusv");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib4Nusv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib4bv(self: *const @This(), _index: GLuint, _v: [*c]const GLbyte) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib4bv");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib4bv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib4d(self: *const @This(), _index: GLuint, _x: GLdouble, _y: GLdouble, _z: GLdouble, _w: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib4d");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib4d(_index, _x, _y, _z, _w);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib4dv(self: *const @This(), _index: GLuint, _v: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib4dv");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib4dv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib4f(self: *const @This(), _index: GLuint, _x: GLfloat, _y: GLfloat, _z: GLfloat, _w: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib4f");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib4f(_index, _x, _y, _z, _w);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib4fv(self: *const @This(), _index: GLuint, _v: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib4fv");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib4fv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib4iv(self: *const @This(), _index: GLuint, _v: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib4iv");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib4iv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib4s(self: *const @This(), _index: GLuint, _x: GLshort, _y: GLshort, _z: GLshort, _w: GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib4s");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib4s(_index, _x, _y, _z, _w);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib4sv(self: *const @This(), _index: GLuint, _v: [*c]const GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib4sv");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib4sv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib4ubv(self: *const @This(), _index: GLuint, _v: ?[*:0]const GLubyte) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib4ubv");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib4ubv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib4uiv(self: *const @This(), _index: GLuint, _v: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib4uiv");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib4uiv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttrib4usv(self: *const @This(), _index: GLuint, _v: [*c]const GLushort) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttrib4usv");
            defer zone.End();
            const result = self.dispatch.glVertexAttrib4usv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribPointer(self: *const @This(), _index: GLuint, _size: GLint, _type: GLenum, _normalized: GLboolean, _stride: GLsizei, _pointer: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribPointer");
            defer zone.End();
            const result = self.dispatch.glVertexAttribPointer(_index, _size, _type, _normalized, _stride, _pointer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniformMatrix2x3fv(self: *const @This(), _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniformMatrix2x3fv");
            defer zone.End();
            const result = self.dispatch.glUniformMatrix2x3fv(_location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniformMatrix3x2fv(self: *const @This(), _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniformMatrix3x2fv");
            defer zone.End();
            const result = self.dispatch.glUniformMatrix3x2fv(_location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniformMatrix2x4fv(self: *const @This(), _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniformMatrix2x4fv");
            defer zone.End();
            const result = self.dispatch.glUniformMatrix2x4fv(_location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniformMatrix4x2fv(self: *const @This(), _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniformMatrix4x2fv");
            defer zone.End();
            const result = self.dispatch.glUniformMatrix4x2fv(_location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniformMatrix3x4fv(self: *const @This(), _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniformMatrix3x4fv");
            defer zone.End();
            const result = self.dispatch.glUniformMatrix3x4fv(_location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniformMatrix4x3fv(self: *const @This(), _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniformMatrix4x3fv");
            defer zone.End();
            const result = self.dispatch.glUniformMatrix4x3fv(_location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn colorMaski(self: *const @This(), _index: GLuint, _r: GLboolean, _g: GLboolean, _b: GLboolean, _a: GLboolean) Error!void {
            const zone = tracy.ZoneN(@src(), "glColorMaski");
            defer zone.End();
            const result = self.dispatch.glColorMaski(_index, _r, _g, _b, _a);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getBooleani_v(self: *const @This(), _target: GLenum, _index: GLuint, _data: [*c]GLboolean) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetBooleani_v");
            defer zone.End();
            const result = self.dispatch.glGetBooleani_v(_target, _index, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getIntegeri_v(self: *const @This(), _target: GLenum, _index: GLuint, _data: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetIntegeri_v");
            defer zone.End();
            const result = self.dispatch.glGetIntegeri_v(_target, _index, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn enablei(self: *const @This(), _target: GLenum, _index: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glEnablei");
            defer zone.End();
            const result = self.dispatch.glEnablei(_target, _index);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn disablei(self: *const @This(), _target: GLenum, _index: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glDisablei");
            defer zone.End();
            const result = self.dispatch.glDisablei(_target, _index);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn isEnabledi(self: *const @This(), _target: GLenum, _index: GLuint) Error!GLboolean {
            const zone = tracy.ZoneN(@src(), "glIsEnabledi");
            defer zone.End();
            const result = self.dispatch.glIsEnabledi(_target, _index);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn beginTransformFeedback(self: *const @This(), _primitiveMode: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glBeginTransformFeedback");
            defer zone.End();
            const result = self.dispatch.glBeginTransformFeedback(_primitiveMode);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn endTransformFeedback(self: *const @This()) Error!void {
            const zone = tracy.ZoneN(@src(), "glEndTransformFeedback");
            defer zone.End();
            const result = self.dispatch.glEndTransformFeedback();
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn bindBufferRange(self: *const @This(), _target: GLenum, _index: GLuint, _buffer: GLuint, _offset: GLintptr, _size: GLsizeiptr) Error!void {
            const zone = tracy.ZoneN(@src(), "glBindBufferRange");
            defer zone.End();
            const result = self.dispatch.glBindBufferRange(_target, _index, _buffer, _offset, _size);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn bindBufferBase(self: *const @This(), _target: GLenum, _index: GLuint, _buffer: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glBindBufferBase");
            defer zone.End();
            const result = self.dispatch.glBindBufferBase(_target, _index, _buffer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn transformFeedbackVaryings(self: *const @This(), _program: GLuint, _count: GLsizei, _varyings: [*c]const [*c]const GLchar, _bufferMode: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glTransformFeedbackVaryings");
            defer zone.End();
            const result = self.dispatch.glTransformFeedbackVaryings(_program, _count, _varyings, _bufferMode);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getTransformFeedbackVarying(self: *const @This(), _program: GLuint, _index: GLuint, _bufSize: GLsizei, _length: [*c]GLsizei, _size: [*c]GLsizei, _type: [*c]GLenum, _name: [*c]GLchar) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetTransformFeedbackVarying");
            defer zone.End();
            const result = self.dispatch.glGetTransformFeedbackVarying(_program, _index, _bufSize, _length, _size, _type, _name);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clampColor(self: *const @This(), _target: GLenum, _clamp: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glClampColor");
            defer zone.End();
            const result = self.dispatch.glClampColor(_target, _clamp);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn beginConditionalRender(self: *const @This(), _id: GLuint, _mode: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glBeginConditionalRender");
            defer zone.End();
            const result = self.dispatch.glBeginConditionalRender(_id, _mode);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn endConditionalRender(self: *const @This()) Error!void {
            const zone = tracy.ZoneN(@src(), "glEndConditionalRender");
            defer zone.End();
            const result = self.dispatch.glEndConditionalRender();
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribIPointer(self: *const @This(), _index: GLuint, _size: GLint, _type: GLenum, _stride: GLsizei, _pointer: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribIPointer");
            defer zone.End();
            const result = self.dispatch.glVertexAttribIPointer(_index, _size, _type, _stride, _pointer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getVertexAttribIiv(self: *const @This(), _index: GLuint, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetVertexAttribIiv");
            defer zone.End();
            const result = self.dispatch.glGetVertexAttribIiv(_index, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getVertexAttribIuiv(self: *const @This(), _index: GLuint, _pname: GLenum, _params: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetVertexAttribIuiv");
            defer zone.End();
            const result = self.dispatch.glGetVertexAttribIuiv(_index, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribI1i(self: *const @This(), _index: GLuint, _x: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribI1i");
            defer zone.End();
            const result = self.dispatch.glVertexAttribI1i(_index, _x);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribI2i(self: *const @This(), _index: GLuint, _x: GLint, _y: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribI2i");
            defer zone.End();
            const result = self.dispatch.glVertexAttribI2i(_index, _x, _y);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribI3i(self: *const @This(), _index: GLuint, _x: GLint, _y: GLint, _z: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribI3i");
            defer zone.End();
            const result = self.dispatch.glVertexAttribI3i(_index, _x, _y, _z);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribI4i(self: *const @This(), _index: GLuint, _x: GLint, _y: GLint, _z: GLint, _w: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribI4i");
            defer zone.End();
            const result = self.dispatch.glVertexAttribI4i(_index, _x, _y, _z, _w);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribI1ui(self: *const @This(), _index: GLuint, _x: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribI1ui");
            defer zone.End();
            const result = self.dispatch.glVertexAttribI1ui(_index, _x);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribI2ui(self: *const @This(), _index: GLuint, _x: GLuint, _y: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribI2ui");
            defer zone.End();
            const result = self.dispatch.glVertexAttribI2ui(_index, _x, _y);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribI3ui(self: *const @This(), _index: GLuint, _x: GLuint, _y: GLuint, _z: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribI3ui");
            defer zone.End();
            const result = self.dispatch.glVertexAttribI3ui(_index, _x, _y, _z);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribI4ui(self: *const @This(), _index: GLuint, _x: GLuint, _y: GLuint, _z: GLuint, _w: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribI4ui");
            defer zone.End();
            const result = self.dispatch.glVertexAttribI4ui(_index, _x, _y, _z, _w);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribI1iv(self: *const @This(), _index: GLuint, _v: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribI1iv");
            defer zone.End();
            const result = self.dispatch.glVertexAttribI1iv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribI2iv(self: *const @This(), _index: GLuint, _v: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribI2iv");
            defer zone.End();
            const result = self.dispatch.glVertexAttribI2iv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribI3iv(self: *const @This(), _index: GLuint, _v: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribI3iv");
            defer zone.End();
            const result = self.dispatch.glVertexAttribI3iv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribI4iv(self: *const @This(), _index: GLuint, _v: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribI4iv");
            defer zone.End();
            const result = self.dispatch.glVertexAttribI4iv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribI1uiv(self: *const @This(), _index: GLuint, _v: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribI1uiv");
            defer zone.End();
            const result = self.dispatch.glVertexAttribI1uiv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribI2uiv(self: *const @This(), _index: GLuint, _v: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribI2uiv");
            defer zone.End();
            const result = self.dispatch.glVertexAttribI2uiv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribI3uiv(self: *const @This(), _index: GLuint, _v: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribI3uiv");
            defer zone.End();
            const result = self.dispatch.glVertexAttribI3uiv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribI4uiv(self: *const @This(), _index: GLuint, _v: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribI4uiv");
            defer zone.End();
            const result = self.dispatch.glVertexAttribI4uiv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribI4bv(self: *const @This(), _index: GLuint, _v: [*c]const GLbyte) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribI4bv");
            defer zone.End();
            const result = self.dispatch.glVertexAttribI4bv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribI4sv(self: *const @This(), _index: GLuint, _v: [*c]const GLshort) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribI4sv");
            defer zone.End();
            const result = self.dispatch.glVertexAttribI4sv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribI4ubv(self: *const @This(), _index: GLuint, _v: ?[*:0]const GLubyte) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribI4ubv");
            defer zone.End();
            const result = self.dispatch.glVertexAttribI4ubv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribI4usv(self: *const @This(), _index: GLuint, _v: [*c]const GLushort) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribI4usv");
            defer zone.End();
            const result = self.dispatch.glVertexAttribI4usv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getUniformuiv(self: *const @This(), _program: GLuint, _location: GLint, _params: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetUniformuiv");
            defer zone.End();
            const result = self.dispatch.glGetUniformuiv(_program, _location, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn bindFragDataLocation(self: *const @This(), _program: GLuint, _color: GLuint, _name: [*c]const GLchar) Error!void {
            const zone = tracy.ZoneN(@src(), "glBindFragDataLocation");
            defer zone.End();
            const result = self.dispatch.glBindFragDataLocation(_program, _color, _name);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getFragDataLocation(self: *const @This(), _program: GLuint, _name: [*c]const GLchar) Error!GLint {
            const zone = tracy.ZoneN(@src(), "glGetFragDataLocation");
            defer zone.End();
            const result = self.dispatch.glGetFragDataLocation(_program, _name);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform1ui(self: *const @This(), _location: GLint, _v0: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform1ui");
            defer zone.End();
            const result = self.dispatch.glUniform1ui(_location, _v0);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform2ui(self: *const @This(), _location: GLint, _v0: GLuint, _v1: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform2ui");
            defer zone.End();
            const result = self.dispatch.glUniform2ui(_location, _v0, _v1);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform3ui(self: *const @This(), _location: GLint, _v0: GLuint, _v1: GLuint, _v2: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform3ui");
            defer zone.End();
            const result = self.dispatch.glUniform3ui(_location, _v0, _v1, _v2);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform4ui(self: *const @This(), _location: GLint, _v0: GLuint, _v1: GLuint, _v2: GLuint, _v3: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform4ui");
            defer zone.End();
            const result = self.dispatch.glUniform4ui(_location, _v0, _v1, _v2, _v3);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform1uiv(self: *const @This(), _location: GLint, _count: GLsizei, _value: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform1uiv");
            defer zone.End();
            const result = self.dispatch.glUniform1uiv(_location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform2uiv(self: *const @This(), _location: GLint, _count: GLsizei, _value: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform2uiv");
            defer zone.End();
            const result = self.dispatch.glUniform2uiv(_location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform3uiv(self: *const @This(), _location: GLint, _count: GLsizei, _value: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform3uiv");
            defer zone.End();
            const result = self.dispatch.glUniform3uiv(_location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform4uiv(self: *const @This(), _location: GLint, _count: GLsizei, _value: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform4uiv");
            defer zone.End();
            const result = self.dispatch.glUniform4uiv(_location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texParameterIiv(self: *const @This(), _target: GLenum, _pname: GLenum, _params: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexParameterIiv");
            defer zone.End();
            const result = self.dispatch.glTexParameterIiv(_target, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texParameterIuiv(self: *const @This(), _target: GLenum, _pname: GLenum, _params: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexParameterIuiv");
            defer zone.End();
            const result = self.dispatch.glTexParameterIuiv(_target, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getTexParameterIiv(self: *const @This(), _target: GLenum, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetTexParameterIiv");
            defer zone.End();
            const result = self.dispatch.glGetTexParameterIiv(_target, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getTexParameterIuiv(self: *const @This(), _target: GLenum, _pname: GLenum, _params: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetTexParameterIuiv");
            defer zone.End();
            const result = self.dispatch.glGetTexParameterIuiv(_target, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clearBufferiv(self: *const @This(), _buffer: GLenum, _drawbuffer: GLint, _value: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glClearBufferiv");
            defer zone.End();
            const result = self.dispatch.glClearBufferiv(_buffer, _drawbuffer, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clearBufferuiv(self: *const @This(), _buffer: GLenum, _drawbuffer: GLint, _value: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glClearBufferuiv");
            defer zone.End();
            const result = self.dispatch.glClearBufferuiv(_buffer, _drawbuffer, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clearBufferfv(self: *const @This(), _buffer: GLenum, _drawbuffer: GLint, _value: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glClearBufferfv");
            defer zone.End();
            const result = self.dispatch.glClearBufferfv(_buffer, _drawbuffer, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clearBufferfi(self: *const @This(), _buffer: GLenum, _drawbuffer: GLint, _depth: GLfloat, _stencil: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glClearBufferfi");
            defer zone.End();
            const result = self.dispatch.glClearBufferfi(_buffer, _drawbuffer, _depth, _stencil);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getStringi(self: *const @This(), _name: GLenum, _index: GLuint) Error!?[*:0]const GLubyte {
            const zone = tracy.ZoneN(@src(), "glGetStringi");
            defer zone.End();
            const result = self.dispatch.glGetStringi(_name, _index);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn isRenderbuffer(self: *const @This(), _renderbuffer: GLuint) Error!GLboolean {
            const zone = tracy.ZoneN(@src(), "glIsRenderbuffer");
            defer zone.End();
            const result = self.dispatch.glIsRenderbuffer(_renderbuffer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn bindRenderbuffer(self: *const @This(), _target: GLenum, _renderbuffer: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glBindRenderbuffer");
            defer zone.End();
            const result = self.dispatch.glBindRenderbuffer(_target, _renderbuffer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn deleteRenderbuffers(self: *const @This(), _n: GLsizei, _renderbuffers: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glDeleteRenderbuffers");
            defer zone.End();
            const result = self.dispatch.glDeleteRenderbuffers(_n, _renderbuffers);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn genRenderbuffers(self: *const @This(), _n: GLsizei, _renderbuffers: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGenRenderbuffers");
            defer zone.End();
            const result = self.dispatch.glGenRenderbuffers(_n, _renderbuffers);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn renderbufferStorage(self: *const @This(), _target: GLenum, _internalformat: GLenum, _width: GLsizei, _height: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glRenderbufferStorage");
            defer zone.End();
            const result = self.dispatch.glRenderbufferStorage(_target, _internalformat, _width, _height);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getRenderbufferParameteriv(self: *const @This(), _target: GLenum, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetRenderbufferParameteriv");
            defer zone.End();
            const result = self.dispatch.glGetRenderbufferParameteriv(_target, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn isFramebuffer(self: *const @This(), _framebuffer: GLuint) Error!GLboolean {
            const zone = tracy.ZoneN(@src(), "glIsFramebuffer");
            defer zone.End();
            const result = self.dispatch.glIsFramebuffer(_framebuffer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn bindFramebuffer(self: *const @This(), _target: GLenum, _framebuffer: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glBindFramebuffer");
            defer zone.End();
            const result = self.dispatch.glBindFramebuffer(_target, _framebuffer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn deleteFramebuffers(self: *const @This(), _n: GLsizei, _framebuffers: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glDeleteFramebuffers");
            defer zone.End();
            const result = self.dispatch.glDeleteFramebuffers(_n, _framebuffers);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn genFramebuffers(self: *const @This(), _n: GLsizei, _framebuffers: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGenFramebuffers");
            defer zone.End();
            const result = self.dispatch.glGenFramebuffers(_n, _framebuffers);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn checkFramebufferStatus(self: *const @This(), _target: GLenum) Error!GLenum {
            const zone = tracy.ZoneN(@src(), "glCheckFramebufferStatus");
            defer zone.End();
            const result = self.dispatch.glCheckFramebufferStatus(_target);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn framebufferTexture1D(self: *const @This(), _target: GLenum, _attachment: GLenum, _textarget: GLenum, _texture: GLuint, _level: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glFramebufferTexture1D");
            defer zone.End();
            const result = self.dispatch.glFramebufferTexture1D(_target, _attachment, _textarget, _texture, _level);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn framebufferTexture2D(self: *const @This(), _target: GLenum, _attachment: GLenum, _textarget: GLenum, _texture: GLuint, _level: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glFramebufferTexture2D");
            defer zone.End();
            const result = self.dispatch.glFramebufferTexture2D(_target, _attachment, _textarget, _texture, _level);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn framebufferTexture3D(self: *const @This(), _target: GLenum, _attachment: GLenum, _textarget: GLenum, _texture: GLuint, _level: GLint, _zoffset: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glFramebufferTexture3D");
            defer zone.End();
            const result = self.dispatch.glFramebufferTexture3D(_target, _attachment, _textarget, _texture, _level, _zoffset);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn framebufferRenderbuffer(self: *const @This(), _target: GLenum, _attachment: GLenum, _renderbuffertarget: GLenum, _renderbuffer: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glFramebufferRenderbuffer");
            defer zone.End();
            const result = self.dispatch.glFramebufferRenderbuffer(_target, _attachment, _renderbuffertarget, _renderbuffer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getFramebufferAttachmentParameteriv(self: *const @This(), _target: GLenum, _attachment: GLenum, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetFramebufferAttachmentParameteriv");
            defer zone.End();
            const result = self.dispatch.glGetFramebufferAttachmentParameteriv(_target, _attachment, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn generateMipmap(self: *const @This(), _target: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glGenerateMipmap");
            defer zone.End();
            const result = self.dispatch.glGenerateMipmap(_target);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn blitFramebuffer(self: *const @This(), _srcX0: GLint, _srcY0: GLint, _srcX1: GLint, _srcY1: GLint, _dstX0: GLint, _dstY0: GLint, _dstX1: GLint, _dstY1: GLint, _mask: GLbitfield, _filter: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glBlitFramebuffer");
            defer zone.End();
            const result = self.dispatch.glBlitFramebuffer(_srcX0, _srcY0, _srcX1, _srcY1, _dstX0, _dstY0, _dstX1, _dstY1, _mask, _filter);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn renderbufferStorageMultisample(self: *const @This(), _target: GLenum, _samples: GLsizei, _internalformat: GLenum, _width: GLsizei, _height: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glRenderbufferStorageMultisample");
            defer zone.End();
            const result = self.dispatch.glRenderbufferStorageMultisample(_target, _samples, _internalformat, _width, _height);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn framebufferTextureLayer(self: *const @This(), _target: GLenum, _attachment: GLenum, _texture: GLuint, _level: GLint, _layer: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glFramebufferTextureLayer");
            defer zone.End();
            const result = self.dispatch.glFramebufferTextureLayer(_target, _attachment, _texture, _level, _layer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn mapBufferRange(self: *const @This(), _target: GLenum, _offset: GLintptr, _length: GLsizeiptr, _access: GLbitfield) Error!?*anyopaque {
            const zone = tracy.ZoneN(@src(), "glMapBufferRange");
            defer zone.End();
            const result = self.dispatch.glMapBufferRange(_target, _offset, _length, _access);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn flushMappedBufferRange(self: *const @This(), _target: GLenum, _offset: GLintptr, _length: GLsizeiptr) Error!void {
            const zone = tracy.ZoneN(@src(), "glFlushMappedBufferRange");
            defer zone.End();
            const result = self.dispatch.glFlushMappedBufferRange(_target, _offset, _length);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn bindVertexArray(self: *const @This(), _array: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glBindVertexArray");
            defer zone.End();
            const result = self.dispatch.glBindVertexArray(_array);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn deleteVertexArrays(self: *const @This(), _n: GLsizei, _arrays: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glDeleteVertexArrays");
            defer zone.End();
            const result = self.dispatch.glDeleteVertexArrays(_n, _arrays);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn genVertexArrays(self: *const @This(), _n: GLsizei, _arrays: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGenVertexArrays");
            defer zone.End();
            const result = self.dispatch.glGenVertexArrays(_n, _arrays);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn isVertexArray(self: *const @This(), _array: GLuint) Error!GLboolean {
            const zone = tracy.ZoneN(@src(), "glIsVertexArray");
            defer zone.End();
            const result = self.dispatch.glIsVertexArray(_array);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn drawArraysInstanced(self: *const @This(), _mode: GLenum, _first: GLint, _count: GLsizei, _instancecount: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glDrawArraysInstanced");
            defer zone.End();
            const result = self.dispatch.glDrawArraysInstanced(_mode, _first, _count, _instancecount);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn drawElementsInstanced(self: *const @This(), _mode: GLenum, _count: GLsizei, _type: GLenum, _indices: ?*const anyopaque, _instancecount: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glDrawElementsInstanced");
            defer zone.End();
            const result = self.dispatch.glDrawElementsInstanced(_mode, _count, _type, _indices, _instancecount);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texBuffer(self: *const @This(), _target: GLenum, _internalformat: GLenum, _buffer: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexBuffer");
            defer zone.End();
            const result = self.dispatch.glTexBuffer(_target, _internalformat, _buffer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn primitiveRestartIndex(self: *const @This(), _index: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glPrimitiveRestartIndex");
            defer zone.End();
            const result = self.dispatch.glPrimitiveRestartIndex(_index);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn copyBufferSubData(self: *const @This(), _readTarget: GLenum, _writeTarget: GLenum, _readOffset: GLintptr, _writeOffset: GLintptr, _size: GLsizeiptr) Error!void {
            const zone = tracy.ZoneN(@src(), "glCopyBufferSubData");
            defer zone.End();
            const result = self.dispatch.glCopyBufferSubData(_readTarget, _writeTarget, _readOffset, _writeOffset, _size);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getUniformIndices(self: *const @This(), _program: GLuint, _uniformCount: GLsizei, _uniformNames: [*c]const [*c]const GLchar, _uniformIndices: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetUniformIndices");
            defer zone.End();
            const result = self.dispatch.glGetUniformIndices(_program, _uniformCount, _uniformNames, _uniformIndices);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getActiveUniformsiv(self: *const @This(), _program: GLuint, _uniformCount: GLsizei, _uniformIndices: [*c]const GLuint, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetActiveUniformsiv");
            defer zone.End();
            const result = self.dispatch.glGetActiveUniformsiv(_program, _uniformCount, _uniformIndices, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getActiveUniformName(self: *const @This(), _program: GLuint, _uniformIndex: GLuint, _bufSize: GLsizei, _length: [*c]GLsizei, _uniformName: [*c]GLchar) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetActiveUniformName");
            defer zone.End();
            const result = self.dispatch.glGetActiveUniformName(_program, _uniformIndex, _bufSize, _length, _uniformName);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getUniformBlockIndex(self: *const @This(), _program: GLuint, _uniformBlockName: [*c]const GLchar) Error!GLuint {
            const zone = tracy.ZoneN(@src(), "glGetUniformBlockIndex");
            defer zone.End();
            const result = self.dispatch.glGetUniformBlockIndex(_program, _uniformBlockName);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getActiveUniformBlockiv(self: *const @This(), _program: GLuint, _uniformBlockIndex: GLuint, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetActiveUniformBlockiv");
            defer zone.End();
            const result = self.dispatch.glGetActiveUniformBlockiv(_program, _uniformBlockIndex, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getActiveUniformBlockName(self: *const @This(), _program: GLuint, _uniformBlockIndex: GLuint, _bufSize: GLsizei, _length: [*c]GLsizei, _uniformBlockName: [*c]GLchar) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetActiveUniformBlockName");
            defer zone.End();
            const result = self.dispatch.glGetActiveUniformBlockName(_program, _uniformBlockIndex, _bufSize, _length, _uniformBlockName);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniformBlockBinding(self: *const @This(), _program: GLuint, _uniformBlockIndex: GLuint, _uniformBlockBinding: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniformBlockBinding");
            defer zone.End();
            const result = self.dispatch.glUniformBlockBinding(_program, _uniformBlockIndex, _uniformBlockBinding);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn drawElementsBaseVertex(self: *const @This(), _mode: GLenum, _count: GLsizei, _type: GLenum, _indices: ?*const anyopaque, _basevertex: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glDrawElementsBaseVertex");
            defer zone.End();
            const result = self.dispatch.glDrawElementsBaseVertex(_mode, _count, _type, _indices, _basevertex);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn drawRangeElementsBaseVertex(self: *const @This(), _mode: GLenum, _start: GLuint, _end: GLuint, _count: GLsizei, _type: GLenum, _indices: ?*const anyopaque, _basevertex: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glDrawRangeElementsBaseVertex");
            defer zone.End();
            const result = self.dispatch.glDrawRangeElementsBaseVertex(_mode, _start, _end, _count, _type, _indices, _basevertex);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn drawElementsInstancedBaseVertex(self: *const @This(), _mode: GLenum, _count: GLsizei, _type: GLenum, _indices: ?*const anyopaque, _instancecount: GLsizei, _basevertex: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glDrawElementsInstancedBaseVertex");
            defer zone.End();
            const result = self.dispatch.glDrawElementsInstancedBaseVertex(_mode, _count, _type, _indices, _instancecount, _basevertex);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiDrawElementsBaseVertex(self: *const @This(), _mode: GLenum, _count: [*c]const GLsizei, _type: GLenum, _indices: [*c]const ?*const anyopaque, _drawcount: GLsizei, _basevertex: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiDrawElementsBaseVertex");
            defer zone.End();
            const result = self.dispatch.glMultiDrawElementsBaseVertex(_mode, _count, _type, _indices, _drawcount, _basevertex);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn provokingVertex(self: *const @This(), _mode: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glProvokingVertex");
            defer zone.End();
            const result = self.dispatch.glProvokingVertex(_mode);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn fenceSync(self: *const @This(), _condition: GLenum, _flags: GLbitfield) Error!GLsync {
            const zone = tracy.ZoneN(@src(), "glFenceSync");
            defer zone.End();
            const result = self.dispatch.glFenceSync(_condition, _flags);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn isSync(self: *const @This(), _sync: GLsync) Error!GLboolean {
            const zone = tracy.ZoneN(@src(), "glIsSync");
            defer zone.End();
            const result = self.dispatch.glIsSync(_sync);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn deleteSync(self: *const @This(), _sync: GLsync) Error!void {
            const zone = tracy.ZoneN(@src(), "glDeleteSync");
            defer zone.End();
            const result = self.dispatch.glDeleteSync(_sync);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clientWaitSync(self: *const @This(), _sync: GLsync, _flags: GLbitfield, _timeout: GLuint64) Error!GLenum {
            const zone = tracy.ZoneN(@src(), "glClientWaitSync");
            defer zone.End();
            const result = self.dispatch.glClientWaitSync(_sync, _flags, _timeout);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn waitSync(self: *const @This(), _sync: GLsync, _flags: GLbitfield, _timeout: GLuint64) Error!void {
            const zone = tracy.ZoneN(@src(), "glWaitSync");
            defer zone.End();
            const result = self.dispatch.glWaitSync(_sync, _flags, _timeout);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getInteger64v(self: *const @This(), _pname: GLenum, _data: [*c]GLint64) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetInteger64v");
            defer zone.End();
            const result = self.dispatch.glGetInteger64v(_pname, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getSynciv(self: *const @This(), _sync: GLsync, _pname: GLenum, _count: GLsizei, _length: [*c]GLsizei, _values: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetSynciv");
            defer zone.End();
            const result = self.dispatch.glGetSynciv(_sync, _pname, _count, _length, _values);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getInteger64i_v(self: *const @This(), _target: GLenum, _index: GLuint, _data: [*c]GLint64) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetInteger64i_v");
            defer zone.End();
            const result = self.dispatch.glGetInteger64i_v(_target, _index, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getBufferParameteri64v(self: *const @This(), _target: GLenum, _pname: GLenum, _params: [*c]GLint64) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetBufferParameteri64v");
            defer zone.End();
            const result = self.dispatch.glGetBufferParameteri64v(_target, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn framebufferTexture(self: *const @This(), _target: GLenum, _attachment: GLenum, _texture: GLuint, _level: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glFramebufferTexture");
            defer zone.End();
            const result = self.dispatch.glFramebufferTexture(_target, _attachment, _texture, _level);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texImage2DMultisample(self: *const @This(), _target: GLenum, _samples: GLsizei, _internalformat: GLenum, _width: GLsizei, _height: GLsizei, _fixedsamplelocations: GLboolean) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexImage2DMultisample");
            defer zone.End();
            const result = self.dispatch.glTexImage2DMultisample(_target, _samples, _internalformat, _width, _height, _fixedsamplelocations);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texImage3DMultisample(self: *const @This(), _target: GLenum, _samples: GLsizei, _internalformat: GLenum, _width: GLsizei, _height: GLsizei, _depth: GLsizei, _fixedsamplelocations: GLboolean) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexImage3DMultisample");
            defer zone.End();
            const result = self.dispatch.glTexImage3DMultisample(_target, _samples, _internalformat, _width, _height, _depth, _fixedsamplelocations);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getMultisamplefv(self: *const @This(), _pname: GLenum, _index: GLuint, _val: [*c]GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetMultisamplefv");
            defer zone.End();
            const result = self.dispatch.glGetMultisamplefv(_pname, _index, _val);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn sampleMaski(self: *const @This(), _maskNumber: GLuint, _mask: GLbitfield) Error!void {
            const zone = tracy.ZoneN(@src(), "glSampleMaski");
            defer zone.End();
            const result = self.dispatch.glSampleMaski(_maskNumber, _mask);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn bindFragDataLocationIndexed(self: *const @This(), _program: GLuint, _colorNumber: GLuint, _index: GLuint, _name: [*c]const GLchar) Error!void {
            const zone = tracy.ZoneN(@src(), "glBindFragDataLocationIndexed");
            defer zone.End();
            const result = self.dispatch.glBindFragDataLocationIndexed(_program, _colorNumber, _index, _name);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getFragDataIndex(self: *const @This(), _program: GLuint, _name: [*c]const GLchar) Error!GLint {
            const zone = tracy.ZoneN(@src(), "glGetFragDataIndex");
            defer zone.End();
            const result = self.dispatch.glGetFragDataIndex(_program, _name);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn genSamplers(self: *const @This(), _count: GLsizei, _samplers: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGenSamplers");
            defer zone.End();
            const result = self.dispatch.glGenSamplers(_count, _samplers);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn deleteSamplers(self: *const @This(), _count: GLsizei, _samplers: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glDeleteSamplers");
            defer zone.End();
            const result = self.dispatch.glDeleteSamplers(_count, _samplers);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn isSampler(self: *const @This(), _sampler: GLuint) Error!GLboolean {
            const zone = tracy.ZoneN(@src(), "glIsSampler");
            defer zone.End();
            const result = self.dispatch.glIsSampler(_sampler);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn bindSampler(self: *const @This(), _unit: GLuint, _sampler: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glBindSampler");
            defer zone.End();
            const result = self.dispatch.glBindSampler(_unit, _sampler);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn samplerParameteri(self: *const @This(), _sampler: GLuint, _pname: GLenum, _param: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glSamplerParameteri");
            defer zone.End();
            const result = self.dispatch.glSamplerParameteri(_sampler, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn samplerParameteriv(self: *const @This(), _sampler: GLuint, _pname: GLenum, _param: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glSamplerParameteriv");
            defer zone.End();
            const result = self.dispatch.glSamplerParameteriv(_sampler, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn samplerParameterf(self: *const @This(), _sampler: GLuint, _pname: GLenum, _param: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glSamplerParameterf");
            defer zone.End();
            const result = self.dispatch.glSamplerParameterf(_sampler, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn samplerParameterfv(self: *const @This(), _sampler: GLuint, _pname: GLenum, _param: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glSamplerParameterfv");
            defer zone.End();
            const result = self.dispatch.glSamplerParameterfv(_sampler, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn samplerParameterIiv(self: *const @This(), _sampler: GLuint, _pname: GLenum, _param: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glSamplerParameterIiv");
            defer zone.End();
            const result = self.dispatch.glSamplerParameterIiv(_sampler, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn samplerParameterIuiv(self: *const @This(), _sampler: GLuint, _pname: GLenum, _param: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glSamplerParameterIuiv");
            defer zone.End();
            const result = self.dispatch.glSamplerParameterIuiv(_sampler, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getSamplerParameteriv(self: *const @This(), _sampler: GLuint, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetSamplerParameteriv");
            defer zone.End();
            const result = self.dispatch.glGetSamplerParameteriv(_sampler, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getSamplerParameterIiv(self: *const @This(), _sampler: GLuint, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetSamplerParameterIiv");
            defer zone.End();
            const result = self.dispatch.glGetSamplerParameterIiv(_sampler, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getSamplerParameterfv(self: *const @This(), _sampler: GLuint, _pname: GLenum, _params: [*c]GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetSamplerParameterfv");
            defer zone.End();
            const result = self.dispatch.glGetSamplerParameterfv(_sampler, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getSamplerParameterIuiv(self: *const @This(), _sampler: GLuint, _pname: GLenum, _params: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetSamplerParameterIuiv");
            defer zone.End();
            const result = self.dispatch.glGetSamplerParameterIuiv(_sampler, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn queryCounter(self: *const @This(), _id: GLuint, _target: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glQueryCounter");
            defer zone.End();
            const result = self.dispatch.glQueryCounter(_id, _target);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getQueryObjecti64v(self: *const @This(), _id: GLuint, _pname: GLenum, _params: [*c]GLint64) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetQueryObjecti64v");
            defer zone.End();
            const result = self.dispatch.glGetQueryObjecti64v(_id, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getQueryObjectui64v(self: *const @This(), _id: GLuint, _pname: GLenum, _params: [*c]GLuint64) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetQueryObjectui64v");
            defer zone.End();
            const result = self.dispatch.glGetQueryObjectui64v(_id, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribDivisor(self: *const @This(), _index: GLuint, _divisor: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribDivisor");
            defer zone.End();
            const result = self.dispatch.glVertexAttribDivisor(_index, _divisor);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribP1ui(self: *const @This(), _index: GLuint, _type: GLenum, _normalized: GLboolean, _value: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribP1ui");
            defer zone.End();
            const result = self.dispatch.glVertexAttribP1ui(_index, _type, _normalized, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribP1uiv(self: *const @This(), _index: GLuint, _type: GLenum, _normalized: GLboolean, _value: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribP1uiv");
            defer zone.End();
            const result = self.dispatch.glVertexAttribP1uiv(_index, _type, _normalized, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribP2ui(self: *const @This(), _index: GLuint, _type: GLenum, _normalized: GLboolean, _value: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribP2ui");
            defer zone.End();
            const result = self.dispatch.glVertexAttribP2ui(_index, _type, _normalized, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribP2uiv(self: *const @This(), _index: GLuint, _type: GLenum, _normalized: GLboolean, _value: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribP2uiv");
            defer zone.End();
            const result = self.dispatch.glVertexAttribP2uiv(_index, _type, _normalized, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribP3ui(self: *const @This(), _index: GLuint, _type: GLenum, _normalized: GLboolean, _value: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribP3ui");
            defer zone.End();
            const result = self.dispatch.glVertexAttribP3ui(_index, _type, _normalized, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribP3uiv(self: *const @This(), _index: GLuint, _type: GLenum, _normalized: GLboolean, _value: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribP3uiv");
            defer zone.End();
            const result = self.dispatch.glVertexAttribP3uiv(_index, _type, _normalized, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribP4ui(self: *const @This(), _index: GLuint, _type: GLenum, _normalized: GLboolean, _value: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribP4ui");
            defer zone.End();
            const result = self.dispatch.glVertexAttribP4ui(_index, _type, _normalized, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribP4uiv(self: *const @This(), _index: GLuint, _type: GLenum, _normalized: GLboolean, _value: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribP4uiv");
            defer zone.End();
            const result = self.dispatch.glVertexAttribP4uiv(_index, _type, _normalized, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexP2ui(self: *const @This(), _type: GLenum, _value: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexP2ui");
            defer zone.End();
            const result = self.dispatch.glVertexP2ui(_type, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexP2uiv(self: *const @This(), _type: GLenum, _value: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexP2uiv");
            defer zone.End();
            const result = self.dispatch.glVertexP2uiv(_type, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexP3ui(self: *const @This(), _type: GLenum, _value: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexP3ui");
            defer zone.End();
            const result = self.dispatch.glVertexP3ui(_type, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexP3uiv(self: *const @This(), _type: GLenum, _value: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexP3uiv");
            defer zone.End();
            const result = self.dispatch.glVertexP3uiv(_type, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexP4ui(self: *const @This(), _type: GLenum, _value: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexP4ui");
            defer zone.End();
            const result = self.dispatch.glVertexP4ui(_type, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexP4uiv(self: *const @This(), _type: GLenum, _value: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexP4uiv");
            defer zone.End();
            const result = self.dispatch.glVertexP4uiv(_type, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoordP1ui(self: *const @This(), _type: GLenum, _coords: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoordP1ui");
            defer zone.End();
            const result = self.dispatch.glTexCoordP1ui(_type, _coords);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoordP1uiv(self: *const @This(), _type: GLenum, _coords: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoordP1uiv");
            defer zone.End();
            const result = self.dispatch.glTexCoordP1uiv(_type, _coords);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoordP2ui(self: *const @This(), _type: GLenum, _coords: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoordP2ui");
            defer zone.End();
            const result = self.dispatch.glTexCoordP2ui(_type, _coords);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoordP2uiv(self: *const @This(), _type: GLenum, _coords: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoordP2uiv");
            defer zone.End();
            const result = self.dispatch.glTexCoordP2uiv(_type, _coords);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoordP3ui(self: *const @This(), _type: GLenum, _coords: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoordP3ui");
            defer zone.End();
            const result = self.dispatch.glTexCoordP3ui(_type, _coords);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoordP3uiv(self: *const @This(), _type: GLenum, _coords: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoordP3uiv");
            defer zone.End();
            const result = self.dispatch.glTexCoordP3uiv(_type, _coords);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoordP4ui(self: *const @This(), _type: GLenum, _coords: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoordP4ui");
            defer zone.End();
            const result = self.dispatch.glTexCoordP4ui(_type, _coords);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texCoordP4uiv(self: *const @This(), _type: GLenum, _coords: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexCoordP4uiv");
            defer zone.End();
            const result = self.dispatch.glTexCoordP4uiv(_type, _coords);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoordP1ui(self: *const @This(), _texture: GLenum, _type: GLenum, _coords: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoordP1ui");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoordP1ui(_texture, _type, _coords);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoordP1uiv(self: *const @This(), _texture: GLenum, _type: GLenum, _coords: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoordP1uiv");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoordP1uiv(_texture, _type, _coords);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoordP2ui(self: *const @This(), _texture: GLenum, _type: GLenum, _coords: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoordP2ui");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoordP2ui(_texture, _type, _coords);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoordP2uiv(self: *const @This(), _texture: GLenum, _type: GLenum, _coords: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoordP2uiv");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoordP2uiv(_texture, _type, _coords);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoordP3ui(self: *const @This(), _texture: GLenum, _type: GLenum, _coords: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoordP3ui");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoordP3ui(_texture, _type, _coords);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoordP3uiv(self: *const @This(), _texture: GLenum, _type: GLenum, _coords: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoordP3uiv");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoordP3uiv(_texture, _type, _coords);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoordP4ui(self: *const @This(), _texture: GLenum, _type: GLenum, _coords: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoordP4ui");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoordP4ui(_texture, _type, _coords);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoordP4uiv(self: *const @This(), _texture: GLenum, _type: GLenum, _coords: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoordP4uiv");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoordP4uiv(_texture, _type, _coords);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn normalP3ui(self: *const @This(), _type: GLenum, _coords: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glNormalP3ui");
            defer zone.End();
            const result = self.dispatch.glNormalP3ui(_type, _coords);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn normalP3uiv(self: *const @This(), _type: GLenum, _coords: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glNormalP3uiv");
            defer zone.End();
            const result = self.dispatch.glNormalP3uiv(_type, _coords);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn colorP3ui(self: *const @This(), _type: GLenum, _color: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glColorP3ui");
            defer zone.End();
            const result = self.dispatch.glColorP3ui(_type, _color);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn colorP3uiv(self: *const @This(), _type: GLenum, _color: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glColorP3uiv");
            defer zone.End();
            const result = self.dispatch.glColorP3uiv(_type, _color);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn colorP4ui(self: *const @This(), _type: GLenum, _color: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glColorP4ui");
            defer zone.End();
            const result = self.dispatch.glColorP4ui(_type, _color);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn colorP4uiv(self: *const @This(), _type: GLenum, _color: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glColorP4uiv");
            defer zone.End();
            const result = self.dispatch.glColorP4uiv(_type, _color);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn secondaryColorP3ui(self: *const @This(), _type: GLenum, _color: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glSecondaryColorP3ui");
            defer zone.End();
            const result = self.dispatch.glSecondaryColorP3ui(_type, _color);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn secondaryColorP3uiv(self: *const @This(), _type: GLenum, _color: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glSecondaryColorP3uiv");
            defer zone.End();
            const result = self.dispatch.glSecondaryColorP3uiv(_type, _color);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn minSampleShading(self: *const @This(), _value: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glMinSampleShading");
            defer zone.End();
            const result = self.dispatch.glMinSampleShading(_value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn blendEquationi(self: *const @This(), _buf: GLuint, _mode: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glBlendEquationi");
            defer zone.End();
            const result = self.dispatch.glBlendEquationi(_buf, _mode);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn blendEquationSeparatei(self: *const @This(), _buf: GLuint, _modeRGB: GLenum, _modeAlpha: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glBlendEquationSeparatei");
            defer zone.End();
            const result = self.dispatch.glBlendEquationSeparatei(_buf, _modeRGB, _modeAlpha);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn blendFunci(self: *const @This(), _buf: GLuint, _src: GLenum, _dst: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glBlendFunci");
            defer zone.End();
            const result = self.dispatch.glBlendFunci(_buf, _src, _dst);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn blendFuncSeparatei(self: *const @This(), _buf: GLuint, _srcRGB: GLenum, _dstRGB: GLenum, _srcAlpha: GLenum, _dstAlpha: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glBlendFuncSeparatei");
            defer zone.End();
            const result = self.dispatch.glBlendFuncSeparatei(_buf, _srcRGB, _dstRGB, _srcAlpha, _dstAlpha);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn drawArraysIndirect(self: *const @This(), _mode: GLenum, _indirect: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glDrawArraysIndirect");
            defer zone.End();
            const result = self.dispatch.glDrawArraysIndirect(_mode, _indirect);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn drawElementsIndirect(self: *const @This(), _mode: GLenum, _type: GLenum, _indirect: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glDrawElementsIndirect");
            defer zone.End();
            const result = self.dispatch.glDrawElementsIndirect(_mode, _type, _indirect);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform1d(self: *const @This(), _location: GLint, _x: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform1d");
            defer zone.End();
            const result = self.dispatch.glUniform1d(_location, _x);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform2d(self: *const @This(), _location: GLint, _x: GLdouble, _y: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform2d");
            defer zone.End();
            const result = self.dispatch.glUniform2d(_location, _x, _y);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform3d(self: *const @This(), _location: GLint, _x: GLdouble, _y: GLdouble, _z: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform3d");
            defer zone.End();
            const result = self.dispatch.glUniform3d(_location, _x, _y, _z);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform4d(self: *const @This(), _location: GLint, _x: GLdouble, _y: GLdouble, _z: GLdouble, _w: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform4d");
            defer zone.End();
            const result = self.dispatch.glUniform4d(_location, _x, _y, _z, _w);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform1dv(self: *const @This(), _location: GLint, _count: GLsizei, _value: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform1dv");
            defer zone.End();
            const result = self.dispatch.glUniform1dv(_location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform2dv(self: *const @This(), _location: GLint, _count: GLsizei, _value: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform2dv");
            defer zone.End();
            const result = self.dispatch.glUniform2dv(_location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform3dv(self: *const @This(), _location: GLint, _count: GLsizei, _value: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform3dv");
            defer zone.End();
            const result = self.dispatch.glUniform3dv(_location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniform4dv(self: *const @This(), _location: GLint, _count: GLsizei, _value: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniform4dv");
            defer zone.End();
            const result = self.dispatch.glUniform4dv(_location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniformMatrix2dv(self: *const @This(), _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniformMatrix2dv");
            defer zone.End();
            const result = self.dispatch.glUniformMatrix2dv(_location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniformMatrix3dv(self: *const @This(), _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniformMatrix3dv");
            defer zone.End();
            const result = self.dispatch.glUniformMatrix3dv(_location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniformMatrix4dv(self: *const @This(), _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniformMatrix4dv");
            defer zone.End();
            const result = self.dispatch.glUniformMatrix4dv(_location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniformMatrix2x3dv(self: *const @This(), _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniformMatrix2x3dv");
            defer zone.End();
            const result = self.dispatch.glUniformMatrix2x3dv(_location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniformMatrix2x4dv(self: *const @This(), _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniformMatrix2x4dv");
            defer zone.End();
            const result = self.dispatch.glUniformMatrix2x4dv(_location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniformMatrix3x2dv(self: *const @This(), _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniformMatrix3x2dv");
            defer zone.End();
            const result = self.dispatch.glUniformMatrix3x2dv(_location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniformMatrix3x4dv(self: *const @This(), _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniformMatrix3x4dv");
            defer zone.End();
            const result = self.dispatch.glUniformMatrix3x4dv(_location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniformMatrix4x2dv(self: *const @This(), _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniformMatrix4x2dv");
            defer zone.End();
            const result = self.dispatch.glUniformMatrix4x2dv(_location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniformMatrix4x3dv(self: *const @This(), _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniformMatrix4x3dv");
            defer zone.End();
            const result = self.dispatch.glUniformMatrix4x3dv(_location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getUniformdv(self: *const @This(), _program: GLuint, _location: GLint, _params: [*c]GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetUniformdv");
            defer zone.End();
            const result = self.dispatch.glGetUniformdv(_program, _location, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getSubroutineUniformLocation(self: *const @This(), _program: GLuint, _shadertype: GLenum, _name: [*c]const GLchar) Error!GLint {
            const zone = tracy.ZoneN(@src(), "glGetSubroutineUniformLocation");
            defer zone.End();
            const result = self.dispatch.glGetSubroutineUniformLocation(_program, _shadertype, _name);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getSubroutineIndex(self: *const @This(), _program: GLuint, _shadertype: GLenum, _name: [*c]const GLchar) Error!GLuint {
            const zone = tracy.ZoneN(@src(), "glGetSubroutineIndex");
            defer zone.End();
            const result = self.dispatch.glGetSubroutineIndex(_program, _shadertype, _name);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getActiveSubroutineUniformiv(self: *const @This(), _program: GLuint, _shadertype: GLenum, _index: GLuint, _pname: GLenum, _values: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetActiveSubroutineUniformiv");
            defer zone.End();
            const result = self.dispatch.glGetActiveSubroutineUniformiv(_program, _shadertype, _index, _pname, _values);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getActiveSubroutineUniformName(self: *const @This(), _program: GLuint, _shadertype: GLenum, _index: GLuint, _bufSize: GLsizei, _length: [*c]GLsizei, _name: [*c]GLchar) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetActiveSubroutineUniformName");
            defer zone.End();
            const result = self.dispatch.glGetActiveSubroutineUniformName(_program, _shadertype, _index, _bufSize, _length, _name);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getActiveSubroutineName(self: *const @This(), _program: GLuint, _shadertype: GLenum, _index: GLuint, _bufSize: GLsizei, _length: [*c]GLsizei, _name: [*c]GLchar) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetActiveSubroutineName");
            defer zone.End();
            const result = self.dispatch.glGetActiveSubroutineName(_program, _shadertype, _index, _bufSize, _length, _name);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn uniformSubroutinesuiv(self: *const @This(), _shadertype: GLenum, _count: GLsizei, _indices: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glUniformSubroutinesuiv");
            defer zone.End();
            const result = self.dispatch.glUniformSubroutinesuiv(_shadertype, _count, _indices);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getUniformSubroutineuiv(self: *const @This(), _shadertype: GLenum, _location: GLint, _params: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetUniformSubroutineuiv");
            defer zone.End();
            const result = self.dispatch.glGetUniformSubroutineuiv(_shadertype, _location, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getProgramStageiv(self: *const @This(), _program: GLuint, _shadertype: GLenum, _pname: GLenum, _values: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetProgramStageiv");
            defer zone.End();
            const result = self.dispatch.glGetProgramStageiv(_program, _shadertype, _pname, _values);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn patchParameteri(self: *const @This(), _pname: GLenum, _value: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glPatchParameteri");
            defer zone.End();
            const result = self.dispatch.glPatchParameteri(_pname, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn patchParameterfv(self: *const @This(), _pname: GLenum, _values: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glPatchParameterfv");
            defer zone.End();
            const result = self.dispatch.glPatchParameterfv(_pname, _values);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn bindTransformFeedback(self: *const @This(), _target: GLenum, _id: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glBindTransformFeedback");
            defer zone.End();
            const result = self.dispatch.glBindTransformFeedback(_target, _id);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn deleteTransformFeedbacks(self: *const @This(), _n: GLsizei, _ids: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glDeleteTransformFeedbacks");
            defer zone.End();
            const result = self.dispatch.glDeleteTransformFeedbacks(_n, _ids);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn genTransformFeedbacks(self: *const @This(), _n: GLsizei, _ids: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGenTransformFeedbacks");
            defer zone.End();
            const result = self.dispatch.glGenTransformFeedbacks(_n, _ids);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn isTransformFeedback(self: *const @This(), _id: GLuint) Error!GLboolean {
            const zone = tracy.ZoneN(@src(), "glIsTransformFeedback");
            defer zone.End();
            const result = self.dispatch.glIsTransformFeedback(_id);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn pauseTransformFeedback(self: *const @This()) Error!void {
            const zone = tracy.ZoneN(@src(), "glPauseTransformFeedback");
            defer zone.End();
            const result = self.dispatch.glPauseTransformFeedback();
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn resumeTransformFeedback(self: *const @This()) Error!void {
            const zone = tracy.ZoneN(@src(), "glResumeTransformFeedback");
            defer zone.End();
            const result = self.dispatch.glResumeTransformFeedback();
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn drawTransformFeedback(self: *const @This(), _mode: GLenum, _id: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glDrawTransformFeedback");
            defer zone.End();
            const result = self.dispatch.glDrawTransformFeedback(_mode, _id);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn drawTransformFeedbackStream(self: *const @This(), _mode: GLenum, _id: GLuint, _stream: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glDrawTransformFeedbackStream");
            defer zone.End();
            const result = self.dispatch.glDrawTransformFeedbackStream(_mode, _id, _stream);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn beginQueryIndexed(self: *const @This(), _target: GLenum, _index: GLuint, _id: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glBeginQueryIndexed");
            defer zone.End();
            const result = self.dispatch.glBeginQueryIndexed(_target, _index, _id);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn endQueryIndexed(self: *const @This(), _target: GLenum, _index: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glEndQueryIndexed");
            defer zone.End();
            const result = self.dispatch.glEndQueryIndexed(_target, _index);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getQueryIndexediv(self: *const @This(), _target: GLenum, _index: GLuint, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetQueryIndexediv");
            defer zone.End();
            const result = self.dispatch.glGetQueryIndexediv(_target, _index, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn releaseShaderCompiler(self: *const @This()) Error!void {
            const zone = tracy.ZoneN(@src(), "glReleaseShaderCompiler");
            defer zone.End();
            const result = self.dispatch.glReleaseShaderCompiler();
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn shaderBinary(self: *const @This(), _count: GLsizei, _shaders: [*c]const GLuint, _binaryFormat: GLenum, _binary: ?*const anyopaque, _length: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glShaderBinary");
            defer zone.End();
            const result = self.dispatch.glShaderBinary(_count, _shaders, _binaryFormat, _binary, _length);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getShaderPrecisionFormat(self: *const @This(), _shadertype: GLenum, _precisiontype: GLenum, _range: [*c]GLint, _precision: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetShaderPrecisionFormat");
            defer zone.End();
            const result = self.dispatch.glGetShaderPrecisionFormat(_shadertype, _precisiontype, _range, _precision);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn depthRangef(self: *const @This(), _n: GLfloat, _f: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glDepthRangef");
            defer zone.End();
            const result = self.dispatch.glDepthRangef(_n, _f);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clearDepthf(self: *const @This(), _d: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glClearDepthf");
            defer zone.End();
            const result = self.dispatch.glClearDepthf(_d);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getProgramBinary(self: *const @This(), _program: GLuint, _bufSize: GLsizei, _length: [*c]GLsizei, _binaryFormat: [*c]GLenum, _binary: ?*anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetProgramBinary");
            defer zone.End();
            const result = self.dispatch.glGetProgramBinary(_program, _bufSize, _length, _binaryFormat, _binary);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programBinary(self: *const @This(), _program: GLuint, _binaryFormat: GLenum, _binary: ?*const anyopaque, _length: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramBinary");
            defer zone.End();
            const result = self.dispatch.glProgramBinary(_program, _binaryFormat, _binary, _length);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programParameteri(self: *const @This(), _program: GLuint, _pname: GLenum, _value: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramParameteri");
            defer zone.End();
            const result = self.dispatch.glProgramParameteri(_program, _pname, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn useProgramStages(self: *const @This(), _pipeline: GLuint, _stages: GLbitfield, _program: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glUseProgramStages");
            defer zone.End();
            const result = self.dispatch.glUseProgramStages(_pipeline, _stages, _program);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn activeShaderProgram(self: *const @This(), _pipeline: GLuint, _program: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glActiveShaderProgram");
            defer zone.End();
            const result = self.dispatch.glActiveShaderProgram(_pipeline, _program);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn createShaderProgramv(self: *const @This(), _type: GLenum, _count: GLsizei, _strings: [*c]const [*c]const GLchar) Error!GLuint {
            const zone = tracy.ZoneN(@src(), "glCreateShaderProgramv");
            defer zone.End();
            const result = self.dispatch.glCreateShaderProgramv(_type, _count, _strings);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn bindProgramPipeline(self: *const @This(), _pipeline: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glBindProgramPipeline");
            defer zone.End();
            const result = self.dispatch.glBindProgramPipeline(_pipeline);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn deleteProgramPipelines(self: *const @This(), _n: GLsizei, _pipelines: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glDeleteProgramPipelines");
            defer zone.End();
            const result = self.dispatch.glDeleteProgramPipelines(_n, _pipelines);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn genProgramPipelines(self: *const @This(), _n: GLsizei, _pipelines: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGenProgramPipelines");
            defer zone.End();
            const result = self.dispatch.glGenProgramPipelines(_n, _pipelines);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn isProgramPipeline(self: *const @This(), _pipeline: GLuint) Error!GLboolean {
            const zone = tracy.ZoneN(@src(), "glIsProgramPipeline");
            defer zone.End();
            const result = self.dispatch.glIsProgramPipeline(_pipeline);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getProgramPipelineiv(self: *const @This(), _pipeline: GLuint, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetProgramPipelineiv");
            defer zone.End();
            const result = self.dispatch.glGetProgramPipelineiv(_pipeline, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform1i(self: *const @This(), _program: GLuint, _location: GLint, _v0: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform1i");
            defer zone.End();
            const result = self.dispatch.glProgramUniform1i(_program, _location, _v0);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform1iv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform1iv");
            defer zone.End();
            const result = self.dispatch.glProgramUniform1iv(_program, _location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform1f(self: *const @This(), _program: GLuint, _location: GLint, _v0: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform1f");
            defer zone.End();
            const result = self.dispatch.glProgramUniform1f(_program, _location, _v0);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform1fv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform1fv");
            defer zone.End();
            const result = self.dispatch.glProgramUniform1fv(_program, _location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform1d(self: *const @This(), _program: GLuint, _location: GLint, _v0: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform1d");
            defer zone.End();
            const result = self.dispatch.glProgramUniform1d(_program, _location, _v0);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform1dv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform1dv");
            defer zone.End();
            const result = self.dispatch.glProgramUniform1dv(_program, _location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform1ui(self: *const @This(), _program: GLuint, _location: GLint, _v0: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform1ui");
            defer zone.End();
            const result = self.dispatch.glProgramUniform1ui(_program, _location, _v0);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform1uiv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform1uiv");
            defer zone.End();
            const result = self.dispatch.glProgramUniform1uiv(_program, _location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform2i(self: *const @This(), _program: GLuint, _location: GLint, _v0: GLint, _v1: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform2i");
            defer zone.End();
            const result = self.dispatch.glProgramUniform2i(_program, _location, _v0, _v1);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform2iv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform2iv");
            defer zone.End();
            const result = self.dispatch.glProgramUniform2iv(_program, _location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform2f(self: *const @This(), _program: GLuint, _location: GLint, _v0: GLfloat, _v1: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform2f");
            defer zone.End();
            const result = self.dispatch.glProgramUniform2f(_program, _location, _v0, _v1);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform2fv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform2fv");
            defer zone.End();
            const result = self.dispatch.glProgramUniform2fv(_program, _location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform2d(self: *const @This(), _program: GLuint, _location: GLint, _v0: GLdouble, _v1: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform2d");
            defer zone.End();
            const result = self.dispatch.glProgramUniform2d(_program, _location, _v0, _v1);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform2dv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform2dv");
            defer zone.End();
            const result = self.dispatch.glProgramUniform2dv(_program, _location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform2ui(self: *const @This(), _program: GLuint, _location: GLint, _v0: GLuint, _v1: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform2ui");
            defer zone.End();
            const result = self.dispatch.glProgramUniform2ui(_program, _location, _v0, _v1);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform2uiv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform2uiv");
            defer zone.End();
            const result = self.dispatch.glProgramUniform2uiv(_program, _location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform3i(self: *const @This(), _program: GLuint, _location: GLint, _v0: GLint, _v1: GLint, _v2: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform3i");
            defer zone.End();
            const result = self.dispatch.glProgramUniform3i(_program, _location, _v0, _v1, _v2);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform3iv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform3iv");
            defer zone.End();
            const result = self.dispatch.glProgramUniform3iv(_program, _location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform3f(self: *const @This(), _program: GLuint, _location: GLint, _v0: GLfloat, _v1: GLfloat, _v2: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform3f");
            defer zone.End();
            const result = self.dispatch.glProgramUniform3f(_program, _location, _v0, _v1, _v2);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform3fv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform3fv");
            defer zone.End();
            const result = self.dispatch.glProgramUniform3fv(_program, _location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform3d(self: *const @This(), _program: GLuint, _location: GLint, _v0: GLdouble, _v1: GLdouble, _v2: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform3d");
            defer zone.End();
            const result = self.dispatch.glProgramUniform3d(_program, _location, _v0, _v1, _v2);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform3dv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform3dv");
            defer zone.End();
            const result = self.dispatch.glProgramUniform3dv(_program, _location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform3ui(self: *const @This(), _program: GLuint, _location: GLint, _v0: GLuint, _v1: GLuint, _v2: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform3ui");
            defer zone.End();
            const result = self.dispatch.glProgramUniform3ui(_program, _location, _v0, _v1, _v2);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform3uiv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform3uiv");
            defer zone.End();
            const result = self.dispatch.glProgramUniform3uiv(_program, _location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform4i(self: *const @This(), _program: GLuint, _location: GLint, _v0: GLint, _v1: GLint, _v2: GLint, _v3: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform4i");
            defer zone.End();
            const result = self.dispatch.glProgramUniform4i(_program, _location, _v0, _v1, _v2, _v3);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform4iv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform4iv");
            defer zone.End();
            const result = self.dispatch.glProgramUniform4iv(_program, _location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform4f(self: *const @This(), _program: GLuint, _location: GLint, _v0: GLfloat, _v1: GLfloat, _v2: GLfloat, _v3: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform4f");
            defer zone.End();
            const result = self.dispatch.glProgramUniform4f(_program, _location, _v0, _v1, _v2, _v3);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform4fv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform4fv");
            defer zone.End();
            const result = self.dispatch.glProgramUniform4fv(_program, _location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform4d(self: *const @This(), _program: GLuint, _location: GLint, _v0: GLdouble, _v1: GLdouble, _v2: GLdouble, _v3: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform4d");
            defer zone.End();
            const result = self.dispatch.glProgramUniform4d(_program, _location, _v0, _v1, _v2, _v3);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform4dv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform4dv");
            defer zone.End();
            const result = self.dispatch.glProgramUniform4dv(_program, _location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform4ui(self: *const @This(), _program: GLuint, _location: GLint, _v0: GLuint, _v1: GLuint, _v2: GLuint, _v3: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform4ui");
            defer zone.End();
            const result = self.dispatch.glProgramUniform4ui(_program, _location, _v0, _v1, _v2, _v3);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniform4uiv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _value: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniform4uiv");
            defer zone.End();
            const result = self.dispatch.glProgramUniform4uiv(_program, _location, _count, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniformMatrix2fv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniformMatrix2fv");
            defer zone.End();
            const result = self.dispatch.glProgramUniformMatrix2fv(_program, _location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniformMatrix3fv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniformMatrix3fv");
            defer zone.End();
            const result = self.dispatch.glProgramUniformMatrix3fv(_program, _location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniformMatrix4fv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniformMatrix4fv");
            defer zone.End();
            const result = self.dispatch.glProgramUniformMatrix4fv(_program, _location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniformMatrix2dv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniformMatrix2dv");
            defer zone.End();
            const result = self.dispatch.glProgramUniformMatrix2dv(_program, _location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniformMatrix3dv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniformMatrix3dv");
            defer zone.End();
            const result = self.dispatch.glProgramUniformMatrix3dv(_program, _location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniformMatrix4dv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniformMatrix4dv");
            defer zone.End();
            const result = self.dispatch.glProgramUniformMatrix4dv(_program, _location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniformMatrix2x3fv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniformMatrix2x3fv");
            defer zone.End();
            const result = self.dispatch.glProgramUniformMatrix2x3fv(_program, _location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniformMatrix3x2fv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniformMatrix3x2fv");
            defer zone.End();
            const result = self.dispatch.glProgramUniformMatrix3x2fv(_program, _location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniformMatrix2x4fv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniformMatrix2x4fv");
            defer zone.End();
            const result = self.dispatch.glProgramUniformMatrix2x4fv(_program, _location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniformMatrix4x2fv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniformMatrix4x2fv");
            defer zone.End();
            const result = self.dispatch.glProgramUniformMatrix4x2fv(_program, _location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniformMatrix3x4fv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniformMatrix3x4fv");
            defer zone.End();
            const result = self.dispatch.glProgramUniformMatrix3x4fv(_program, _location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniformMatrix4x3fv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniformMatrix4x3fv");
            defer zone.End();
            const result = self.dispatch.glProgramUniformMatrix4x3fv(_program, _location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniformMatrix2x3dv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniformMatrix2x3dv");
            defer zone.End();
            const result = self.dispatch.glProgramUniformMatrix2x3dv(_program, _location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniformMatrix3x2dv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniformMatrix3x2dv");
            defer zone.End();
            const result = self.dispatch.glProgramUniformMatrix3x2dv(_program, _location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniformMatrix2x4dv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniformMatrix2x4dv");
            defer zone.End();
            const result = self.dispatch.glProgramUniformMatrix2x4dv(_program, _location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniformMatrix4x2dv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniformMatrix4x2dv");
            defer zone.End();
            const result = self.dispatch.glProgramUniformMatrix4x2dv(_program, _location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniformMatrix3x4dv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniformMatrix3x4dv");
            defer zone.End();
            const result = self.dispatch.glProgramUniformMatrix3x4dv(_program, _location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn programUniformMatrix4x3dv(self: *const @This(), _program: GLuint, _location: GLint, _count: GLsizei, _transpose: GLboolean, _value: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glProgramUniformMatrix4x3dv");
            defer zone.End();
            const result = self.dispatch.glProgramUniformMatrix4x3dv(_program, _location, _count, _transpose, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn validateProgramPipeline(self: *const @This(), _pipeline: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glValidateProgramPipeline");
            defer zone.End();
            const result = self.dispatch.glValidateProgramPipeline(_pipeline);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getProgramPipelineInfoLog(self: *const @This(), _pipeline: GLuint, _bufSize: GLsizei, _length: [*c]GLsizei, _infoLog: [*c]GLchar) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetProgramPipelineInfoLog");
            defer zone.End();
            const result = self.dispatch.glGetProgramPipelineInfoLog(_pipeline, _bufSize, _length, _infoLog);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribL1d(self: *const @This(), _index: GLuint, _x: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribL1d");
            defer zone.End();
            const result = self.dispatch.glVertexAttribL1d(_index, _x);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribL2d(self: *const @This(), _index: GLuint, _x: GLdouble, _y: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribL2d");
            defer zone.End();
            const result = self.dispatch.glVertexAttribL2d(_index, _x, _y);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribL3d(self: *const @This(), _index: GLuint, _x: GLdouble, _y: GLdouble, _z: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribL3d");
            defer zone.End();
            const result = self.dispatch.glVertexAttribL3d(_index, _x, _y, _z);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribL4d(self: *const @This(), _index: GLuint, _x: GLdouble, _y: GLdouble, _z: GLdouble, _w: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribL4d");
            defer zone.End();
            const result = self.dispatch.glVertexAttribL4d(_index, _x, _y, _z, _w);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribL1dv(self: *const @This(), _index: GLuint, _v: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribL1dv");
            defer zone.End();
            const result = self.dispatch.glVertexAttribL1dv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribL2dv(self: *const @This(), _index: GLuint, _v: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribL2dv");
            defer zone.End();
            const result = self.dispatch.glVertexAttribL2dv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribL3dv(self: *const @This(), _index: GLuint, _v: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribL3dv");
            defer zone.End();
            const result = self.dispatch.glVertexAttribL3dv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribL4dv(self: *const @This(), _index: GLuint, _v: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribL4dv");
            defer zone.End();
            const result = self.dispatch.glVertexAttribL4dv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribLPointer(self: *const @This(), _index: GLuint, _size: GLint, _type: GLenum, _stride: GLsizei, _pointer: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribLPointer");
            defer zone.End();
            const result = self.dispatch.glVertexAttribLPointer(_index, _size, _type, _stride, _pointer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getVertexAttribLdv(self: *const @This(), _index: GLuint, _pname: GLenum, _params: [*c]GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetVertexAttribLdv");
            defer zone.End();
            const result = self.dispatch.glGetVertexAttribLdv(_index, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn viewportArrayv(self: *const @This(), _first: GLuint, _count: GLsizei, _v: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glViewportArrayv");
            defer zone.End();
            const result = self.dispatch.glViewportArrayv(_first, _count, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn viewportIndexedf(self: *const @This(), _index: GLuint, _x: GLfloat, _y: GLfloat, _w: GLfloat, _h: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glViewportIndexedf");
            defer zone.End();
            const result = self.dispatch.glViewportIndexedf(_index, _x, _y, _w, _h);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn viewportIndexedfv(self: *const @This(), _index: GLuint, _v: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glViewportIndexedfv");
            defer zone.End();
            const result = self.dispatch.glViewportIndexedfv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn scissorArrayv(self: *const @This(), _first: GLuint, _count: GLsizei, _v: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glScissorArrayv");
            defer zone.End();
            const result = self.dispatch.glScissorArrayv(_first, _count, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn scissorIndexed(self: *const @This(), _index: GLuint, _left: GLint, _bottom: GLint, _width: GLsizei, _height: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glScissorIndexed");
            defer zone.End();
            const result = self.dispatch.glScissorIndexed(_index, _left, _bottom, _width, _height);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn scissorIndexedv(self: *const @This(), _index: GLuint, _v: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glScissorIndexedv");
            defer zone.End();
            const result = self.dispatch.glScissorIndexedv(_index, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn depthRangeArrayv(self: *const @This(), _first: GLuint, _count: GLsizei, _v: [*c]const GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glDepthRangeArrayv");
            defer zone.End();
            const result = self.dispatch.glDepthRangeArrayv(_first, _count, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn depthRangeIndexed(self: *const @This(), _index: GLuint, _n: GLdouble, _f: GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glDepthRangeIndexed");
            defer zone.End();
            const result = self.dispatch.glDepthRangeIndexed(_index, _n, _f);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getFloati_v(self: *const @This(), _target: GLenum, _index: GLuint, _data: [*c]GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetFloati_v");
            defer zone.End();
            const result = self.dispatch.glGetFloati_v(_target, _index, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getDoublei_v(self: *const @This(), _target: GLenum, _index: GLuint, _data: [*c]GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetDoublei_v");
            defer zone.End();
            const result = self.dispatch.glGetDoublei_v(_target, _index, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn drawArraysInstancedBaseInstance(self: *const @This(), _mode: GLenum, _first: GLint, _count: GLsizei, _instancecount: GLsizei, _baseinstance: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glDrawArraysInstancedBaseInstance");
            defer zone.End();
            const result = self.dispatch.glDrawArraysInstancedBaseInstance(_mode, _first, _count, _instancecount, _baseinstance);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn drawElementsInstancedBaseInstance(self: *const @This(), _mode: GLenum, _count: GLsizei, _type: GLenum, _indices: ?*const anyopaque, _instancecount: GLsizei, _baseinstance: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glDrawElementsInstancedBaseInstance");
            defer zone.End();
            const result = self.dispatch.glDrawElementsInstancedBaseInstance(_mode, _count, _type, _indices, _instancecount, _baseinstance);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn drawElementsInstancedBaseVertexBaseInstance(self: *const @This(), _mode: GLenum, _count: GLsizei, _type: GLenum, _indices: ?*const anyopaque, _instancecount: GLsizei, _basevertex: GLint, _baseinstance: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glDrawElementsInstancedBaseVertexBaseInstance");
            defer zone.End();
            const result = self.dispatch.glDrawElementsInstancedBaseVertexBaseInstance(_mode, _count, _type, _indices, _instancecount, _basevertex, _baseinstance);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getInternalformativ(self: *const @This(), _target: GLenum, _internalformat: GLenum, _pname: GLenum, _count: GLsizei, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetInternalformativ");
            defer zone.End();
            const result = self.dispatch.glGetInternalformativ(_target, _internalformat, _pname, _count, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getActiveAtomicCounterBufferiv(self: *const @This(), _program: GLuint, _bufferIndex: GLuint, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetActiveAtomicCounterBufferiv");
            defer zone.End();
            const result = self.dispatch.glGetActiveAtomicCounterBufferiv(_program, _bufferIndex, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn bindImageTexture(self: *const @This(), _unit: GLuint, _texture: GLuint, _level: GLint, _layered: GLboolean, _layer: GLint, _access: GLenum, _format: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glBindImageTexture");
            defer zone.End();
            const result = self.dispatch.glBindImageTexture(_unit, _texture, _level, _layered, _layer, _access, _format);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn memoryBarrier(self: *const @This(), _barriers: GLbitfield) Error!void {
            const zone = tracy.ZoneN(@src(), "glMemoryBarrier");
            defer zone.End();
            const result = self.dispatch.glMemoryBarrier(_barriers);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texStorage1D(self: *const @This(), _target: GLenum, _levels: GLsizei, _internalformat: GLenum, _width: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexStorage1D");
            defer zone.End();
            const result = self.dispatch.glTexStorage1D(_target, _levels, _internalformat, _width);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texStorage2D(self: *const @This(), _target: GLenum, _levels: GLsizei, _internalformat: GLenum, _width: GLsizei, _height: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexStorage2D");
            defer zone.End();
            const result = self.dispatch.glTexStorage2D(_target, _levels, _internalformat, _width, _height);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texStorage3D(self: *const @This(), _target: GLenum, _levels: GLsizei, _internalformat: GLenum, _width: GLsizei, _height: GLsizei, _depth: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexStorage3D");
            defer zone.End();
            const result = self.dispatch.glTexStorage3D(_target, _levels, _internalformat, _width, _height, _depth);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn drawTransformFeedbackInstanced(self: *const @This(), _mode: GLenum, _id: GLuint, _instancecount: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glDrawTransformFeedbackInstanced");
            defer zone.End();
            const result = self.dispatch.glDrawTransformFeedbackInstanced(_mode, _id, _instancecount);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn drawTransformFeedbackStreamInstanced(self: *const @This(), _mode: GLenum, _id: GLuint, _stream: GLuint, _instancecount: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glDrawTransformFeedbackStreamInstanced");
            defer zone.End();
            const result = self.dispatch.glDrawTransformFeedbackStreamInstanced(_mode, _id, _stream, _instancecount);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clearBufferData(self: *const @This(), _target: GLenum, _internalformat: GLenum, _format: GLenum, _type: GLenum, _data: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glClearBufferData");
            defer zone.End();
            const result = self.dispatch.glClearBufferData(_target, _internalformat, _format, _type, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clearBufferSubData(self: *const @This(), _target: GLenum, _internalformat: GLenum, _offset: GLintptr, _size: GLsizeiptr, _format: GLenum, _type: GLenum, _data: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glClearBufferSubData");
            defer zone.End();
            const result = self.dispatch.glClearBufferSubData(_target, _internalformat, _offset, _size, _format, _type, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn dispatchCompute(self: *const @This(), _num_groups_x: GLuint, _num_groups_y: GLuint, _num_groups_z: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glDispatchCompute");
            defer zone.End();
            const result = self.dispatch.glDispatchCompute(_num_groups_x, _num_groups_y, _num_groups_z);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn dispatchComputeIndirect(self: *const @This(), _indirect: GLintptr) Error!void {
            const zone = tracy.ZoneN(@src(), "glDispatchComputeIndirect");
            defer zone.End();
            const result = self.dispatch.glDispatchComputeIndirect(_indirect);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn copyImageSubData(self: *const @This(), _srcName: GLuint, _srcTarget: GLenum, _srcLevel: GLint, _srcX: GLint, _srcY: GLint, _srcZ: GLint, _dstName: GLuint, _dstTarget: GLenum, _dstLevel: GLint, _dstX: GLint, _dstY: GLint, _dstZ: GLint, _srcWidth: GLsizei, _srcHeight: GLsizei, _srcDepth: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glCopyImageSubData");
            defer zone.End();
            const result = self.dispatch.glCopyImageSubData(_srcName, _srcTarget, _srcLevel, _srcX, _srcY, _srcZ, _dstName, _dstTarget, _dstLevel, _dstX, _dstY, _dstZ, _srcWidth, _srcHeight, _srcDepth);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn framebufferParameteri(self: *const @This(), _target: GLenum, _pname: GLenum, _param: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glFramebufferParameteri");
            defer zone.End();
            const result = self.dispatch.glFramebufferParameteri(_target, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getFramebufferParameteriv(self: *const @This(), _target: GLenum, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetFramebufferParameteriv");
            defer zone.End();
            const result = self.dispatch.glGetFramebufferParameteriv(_target, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getInternalformati64v(self: *const @This(), _target: GLenum, _internalformat: GLenum, _pname: GLenum, _count: GLsizei, _params: [*c]GLint64) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetInternalformati64v");
            defer zone.End();
            const result = self.dispatch.glGetInternalformati64v(_target, _internalformat, _pname, _count, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn invalidateTexSubImage(self: *const @This(), _texture: GLuint, _level: GLint, _xoffset: GLint, _yoffset: GLint, _zoffset: GLint, _width: GLsizei, _height: GLsizei, _depth: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glInvalidateTexSubImage");
            defer zone.End();
            const result = self.dispatch.glInvalidateTexSubImage(_texture, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn invalidateTexImage(self: *const @This(), _texture: GLuint, _level: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glInvalidateTexImage");
            defer zone.End();
            const result = self.dispatch.glInvalidateTexImage(_texture, _level);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn invalidateBufferSubData(self: *const @This(), _buffer: GLuint, _offset: GLintptr, _length: GLsizeiptr) Error!void {
            const zone = tracy.ZoneN(@src(), "glInvalidateBufferSubData");
            defer zone.End();
            const result = self.dispatch.glInvalidateBufferSubData(_buffer, _offset, _length);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn invalidateBufferData(self: *const @This(), _buffer: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glInvalidateBufferData");
            defer zone.End();
            const result = self.dispatch.glInvalidateBufferData(_buffer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn invalidateFramebuffer(self: *const @This(), _target: GLenum, _numAttachments: GLsizei, _attachments: [*c]const GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glInvalidateFramebuffer");
            defer zone.End();
            const result = self.dispatch.glInvalidateFramebuffer(_target, _numAttachments, _attachments);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn invalidateSubFramebuffer(self: *const @This(), _target: GLenum, _numAttachments: GLsizei, _attachments: [*c]const GLenum, _x: GLint, _y: GLint, _width: GLsizei, _height: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glInvalidateSubFramebuffer");
            defer zone.End();
            const result = self.dispatch.glInvalidateSubFramebuffer(_target, _numAttachments, _attachments, _x, _y, _width, _height);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiDrawArraysIndirect(self: *const @This(), _mode: GLenum, _indirect: ?*const anyopaque, _drawcount: GLsizei, _stride: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiDrawArraysIndirect");
            defer zone.End();
            const result = self.dispatch.glMultiDrawArraysIndirect(_mode, _indirect, _drawcount, _stride);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiDrawElementsIndirect(self: *const @This(), _mode: GLenum, _type: GLenum, _indirect: ?*const anyopaque, _drawcount: GLsizei, _stride: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiDrawElementsIndirect");
            defer zone.End();
            const result = self.dispatch.glMultiDrawElementsIndirect(_mode, _type, _indirect, _drawcount, _stride);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getProgramInterfaceiv(self: *const @This(), _program: GLuint, _programInterface: GLenum, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetProgramInterfaceiv");
            defer zone.End();
            const result = self.dispatch.glGetProgramInterfaceiv(_program, _programInterface, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getProgramResourceIndex(self: *const @This(), _program: GLuint, _programInterface: GLenum, _name: [*c]const GLchar) Error!GLuint {
            const zone = tracy.ZoneN(@src(), "glGetProgramResourceIndex");
            defer zone.End();
            const result = self.dispatch.glGetProgramResourceIndex(_program, _programInterface, _name);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getProgramResourceName(self: *const @This(), _program: GLuint, _programInterface: GLenum, _index: GLuint, _bufSize: GLsizei, _length: [*c]GLsizei, _name: [*c]GLchar) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetProgramResourceName");
            defer zone.End();
            const result = self.dispatch.glGetProgramResourceName(_program, _programInterface, _index, _bufSize, _length, _name);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getProgramResourceiv(self: *const @This(), _program: GLuint, _programInterface: GLenum, _index: GLuint, _propCount: GLsizei, _props: [*c]const GLenum, _count: GLsizei, _length: [*c]GLsizei, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetProgramResourceiv");
            defer zone.End();
            const result = self.dispatch.glGetProgramResourceiv(_program, _programInterface, _index, _propCount, _props, _count, _length, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getProgramResourceLocation(self: *const @This(), _program: GLuint, _programInterface: GLenum, _name: [*c]const GLchar) Error!GLint {
            const zone = tracy.ZoneN(@src(), "glGetProgramResourceLocation");
            defer zone.End();
            const result = self.dispatch.glGetProgramResourceLocation(_program, _programInterface, _name);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getProgramResourceLocationIndex(self: *const @This(), _program: GLuint, _programInterface: GLenum, _name: [*c]const GLchar) Error!GLint {
            const zone = tracy.ZoneN(@src(), "glGetProgramResourceLocationIndex");
            defer zone.End();
            const result = self.dispatch.glGetProgramResourceLocationIndex(_program, _programInterface, _name);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn shaderStorageBlockBinding(self: *const @This(), _program: GLuint, _storageBlockIndex: GLuint, _storageBlockBinding: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glShaderStorageBlockBinding");
            defer zone.End();
            const result = self.dispatch.glShaderStorageBlockBinding(_program, _storageBlockIndex, _storageBlockBinding);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texBufferRange(self: *const @This(), _target: GLenum, _internalformat: GLenum, _buffer: GLuint, _offset: GLintptr, _size: GLsizeiptr) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexBufferRange");
            defer zone.End();
            const result = self.dispatch.glTexBufferRange(_target, _internalformat, _buffer, _offset, _size);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texStorage2DMultisample(self: *const @This(), _target: GLenum, _samples: GLsizei, _internalformat: GLenum, _width: GLsizei, _height: GLsizei, _fixedsamplelocations: GLboolean) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexStorage2DMultisample");
            defer zone.End();
            const result = self.dispatch.glTexStorage2DMultisample(_target, _samples, _internalformat, _width, _height, _fixedsamplelocations);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texStorage3DMultisample(self: *const @This(), _target: GLenum, _samples: GLsizei, _internalformat: GLenum, _width: GLsizei, _height: GLsizei, _depth: GLsizei, _fixedsamplelocations: GLboolean) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexStorage3DMultisample");
            defer zone.End();
            const result = self.dispatch.glTexStorage3DMultisample(_target, _samples, _internalformat, _width, _height, _depth, _fixedsamplelocations);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn textureView(self: *const @This(), _texture: GLuint, _target: GLenum, _origtexture: GLuint, _internalformat: GLenum, _minlevel: GLuint, _numlevels: GLuint, _minlayer: GLuint, _numlayers: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTextureView");
            defer zone.End();
            const result = self.dispatch.glTextureView(_texture, _target, _origtexture, _internalformat, _minlevel, _numlevels, _minlayer, _numlayers);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn bindVertexBuffer(self: *const @This(), _bindingindex: GLuint, _buffer: GLuint, _offset: GLintptr, _stride: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glBindVertexBuffer");
            defer zone.End();
            const result = self.dispatch.glBindVertexBuffer(_bindingindex, _buffer, _offset, _stride);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribFormat(self: *const @This(), _attribindex: GLuint, _size: GLint, _type: GLenum, _normalized: GLboolean, _relativeoffset: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribFormat");
            defer zone.End();
            const result = self.dispatch.glVertexAttribFormat(_attribindex, _size, _type, _normalized, _relativeoffset);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribIFormat(self: *const @This(), _attribindex: GLuint, _size: GLint, _type: GLenum, _relativeoffset: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribIFormat");
            defer zone.End();
            const result = self.dispatch.glVertexAttribIFormat(_attribindex, _size, _type, _relativeoffset);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribLFormat(self: *const @This(), _attribindex: GLuint, _size: GLint, _type: GLenum, _relativeoffset: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribLFormat");
            defer zone.End();
            const result = self.dispatch.glVertexAttribLFormat(_attribindex, _size, _type, _relativeoffset);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexAttribBinding(self: *const @This(), _attribindex: GLuint, _bindingindex: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexAttribBinding");
            defer zone.End();
            const result = self.dispatch.glVertexAttribBinding(_attribindex, _bindingindex);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexBindingDivisor(self: *const @This(), _bindingindex: GLuint, _divisor: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexBindingDivisor");
            defer zone.End();
            const result = self.dispatch.glVertexBindingDivisor(_bindingindex, _divisor);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn debugMessageControl(self: *const @This(), _source: GLenum, _type: GLenum, _severity: GLenum, _count: GLsizei, _ids: [*c]const GLuint, _enabled: GLboolean) Error!void {
            const zone = tracy.ZoneN(@src(), "glDebugMessageControl");
            defer zone.End();
            const result = self.dispatch.glDebugMessageControl(_source, _type, _severity, _count, _ids, _enabled);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn debugMessageInsert(self: *const @This(), _source: GLenum, _type: GLenum, _id: GLuint, _severity: GLenum, _length: GLsizei, _buf: [*c]const GLchar) Error!void {
            const zone = tracy.ZoneN(@src(), "glDebugMessageInsert");
            defer zone.End();
            const result = self.dispatch.glDebugMessageInsert(_source, _type, _id, _severity, _length, _buf);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn debugMessageCallback(self: *const @This(), _callback: GLDEBUGPROC, _userParam: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glDebugMessageCallback");
            defer zone.End();
            const result = self.dispatch.glDebugMessageCallback(_callback, _userParam);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getDebugMessageLog(self: *const @This(), _count: GLuint, _bufSize: GLsizei, _sources: [*c]GLenum, _types: [*c]GLenum, _ids: [*c]GLuint, _severities: [*c]GLenum, _lengths: [*c]GLsizei, _messageLog: [*c]GLchar) Error!GLuint {
            const zone = tracy.ZoneN(@src(), "glGetDebugMessageLog");
            defer zone.End();
            const result = self.dispatch.glGetDebugMessageLog(_count, _bufSize, _sources, _types, _ids, _severities, _lengths, _messageLog);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn pushDebugGroup(self: *const @This(), _source: GLenum, _id: GLuint, _length: GLsizei, _message: [*c]const GLchar) Error!void {
            const zone = tracy.ZoneN(@src(), "glPushDebugGroup");
            defer zone.End();
            const result = self.dispatch.glPushDebugGroup(_source, _id, _length, _message);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn popDebugGroup(self: *const @This()) Error!void {
            const zone = tracy.ZoneN(@src(), "glPopDebugGroup");
            defer zone.End();
            const result = self.dispatch.glPopDebugGroup();
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn objectLabel(self: *const @This(), _identifier: GLenum, _name: GLuint, _length: GLsizei, _label: [*c]const GLchar) Error!void {
            const zone = tracy.ZoneN(@src(), "glObjectLabel");
            defer zone.End();
            const result = self.dispatch.glObjectLabel(_identifier, _name, _length, _label);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getObjectLabel(self: *const @This(), _identifier: GLenum, _name: GLuint, _bufSize: GLsizei, _length: [*c]GLsizei, _label: [*c]GLchar) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetObjectLabel");
            defer zone.End();
            const result = self.dispatch.glGetObjectLabel(_identifier, _name, _bufSize, _length, _label);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn objectPtrLabel(self: *const @This(), _ptr: ?*const anyopaque, _length: GLsizei, _label: [*c]const GLchar) Error!void {
            const zone = tracy.ZoneN(@src(), "glObjectPtrLabel");
            defer zone.End();
            const result = self.dispatch.glObjectPtrLabel(_ptr, _length, _label);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getObjectPtrLabel(self: *const @This(), _ptr: ?*const anyopaque, _bufSize: GLsizei, _length: [*c]GLsizei, _label: [*c]GLchar) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetObjectPtrLabel");
            defer zone.End();
            const result = self.dispatch.glGetObjectPtrLabel(_ptr, _bufSize, _length, _label);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn bufferStorage(self: *const @This(), _target: GLenum, _size: GLsizeiptr, _data: ?*const anyopaque, _flags: GLbitfield) Error!void {
            const zone = tracy.ZoneN(@src(), "glBufferStorage");
            defer zone.End();
            const result = self.dispatch.glBufferStorage(_target, _size, _data, _flags);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clearTexImage(self: *const @This(), _texture: GLuint, _level: GLint, _format: GLenum, _type: GLenum, _data: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glClearTexImage");
            defer zone.End();
            const result = self.dispatch.glClearTexImage(_texture, _level, _format, _type, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clearTexSubImage(self: *const @This(), _texture: GLuint, _level: GLint, _xoffset: GLint, _yoffset: GLint, _zoffset: GLint, _width: GLsizei, _height: GLsizei, _depth: GLsizei, _format: GLenum, _type: GLenum, _data: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glClearTexSubImage");
            defer zone.End();
            const result = self.dispatch.glClearTexSubImage(_texture, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _type, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn bindBuffersBase(self: *const @This(), _target: GLenum, _first: GLuint, _count: GLsizei, _buffers: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glBindBuffersBase");
            defer zone.End();
            const result = self.dispatch.glBindBuffersBase(_target, _first, _count, _buffers);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn bindBuffersRange(self: *const @This(), _target: GLenum, _first: GLuint, _count: GLsizei, _buffers: [*c]const GLuint, _offsets: [*c]const GLintptr, _sizes: [*c]const GLsizeiptr) Error!void {
            const zone = tracy.ZoneN(@src(), "glBindBuffersRange");
            defer zone.End();
            const result = self.dispatch.glBindBuffersRange(_target, _first, _count, _buffers, _offsets, _sizes);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn bindTextures(self: *const @This(), _first: GLuint, _count: GLsizei, _textures: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glBindTextures");
            defer zone.End();
            const result = self.dispatch.glBindTextures(_first, _count, _textures);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn bindSamplers(self: *const @This(), _first: GLuint, _count: GLsizei, _samplers: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glBindSamplers");
            defer zone.End();
            const result = self.dispatch.glBindSamplers(_first, _count, _samplers);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn bindImageTextures(self: *const @This(), _first: GLuint, _count: GLsizei, _textures: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glBindImageTextures");
            defer zone.End();
            const result = self.dispatch.glBindImageTextures(_first, _count, _textures);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn bindVertexBuffers(self: *const @This(), _first: GLuint, _count: GLsizei, _buffers: [*c]const GLuint, _offsets: [*c]const GLintptr, _strides: [*c]const GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glBindVertexBuffers");
            defer zone.End();
            const result = self.dispatch.glBindVertexBuffers(_first, _count, _buffers, _offsets, _strides);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clipControl(self: *const @This(), _origin: GLenum, _depth: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glClipControl");
            defer zone.End();
            const result = self.dispatch.glClipControl(_origin, _depth);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn createTransformFeedbacks(self: *const @This(), _n: GLsizei, _ids: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glCreateTransformFeedbacks");
            defer zone.End();
            const result = self.dispatch.glCreateTransformFeedbacks(_n, _ids);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn transformFeedbackBufferBase(self: *const @This(), _xfb: GLuint, _index: GLuint, _buffer: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTransformFeedbackBufferBase");
            defer zone.End();
            const result = self.dispatch.glTransformFeedbackBufferBase(_xfb, _index, _buffer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn transformFeedbackBufferRange(self: *const @This(), _xfb: GLuint, _index: GLuint, _buffer: GLuint, _offset: GLintptr, _size: GLsizeiptr) Error!void {
            const zone = tracy.ZoneN(@src(), "glTransformFeedbackBufferRange");
            defer zone.End();
            const result = self.dispatch.glTransformFeedbackBufferRange(_xfb, _index, _buffer, _offset, _size);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getTransformFeedbackiv(self: *const @This(), _xfb: GLuint, _pname: GLenum, _param: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetTransformFeedbackiv");
            defer zone.End();
            const result = self.dispatch.glGetTransformFeedbackiv(_xfb, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getTransformFeedbacki_v(self: *const @This(), _xfb: GLuint, _pname: GLenum, _index: GLuint, _param: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetTransformFeedbacki_v");
            defer zone.End();
            const result = self.dispatch.glGetTransformFeedbacki_v(_xfb, _pname, _index, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getTransformFeedbacki64_v(self: *const @This(), _xfb: GLuint, _pname: GLenum, _index: GLuint, _param: [*c]GLint64) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetTransformFeedbacki64_v");
            defer zone.End();
            const result = self.dispatch.glGetTransformFeedbacki64_v(_xfb, _pname, _index, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn createBuffers(self: *const @This(), _n: GLsizei, _buffers: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glCreateBuffers");
            defer zone.End();
            const result = self.dispatch.glCreateBuffers(_n, _buffers);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn namedBufferStorage(self: *const @This(), _buffer: GLuint, _size: GLsizeiptr, _data: ?*const anyopaque, _flags: GLbitfield) Error!void {
            const zone = tracy.ZoneN(@src(), "glNamedBufferStorage");
            defer zone.End();
            const result = self.dispatch.glNamedBufferStorage(_buffer, _size, _data, _flags);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn namedBufferData(self: *const @This(), _buffer: GLuint, _size: GLsizeiptr, _data: ?*const anyopaque, _usage: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glNamedBufferData");
            defer zone.End();
            const result = self.dispatch.glNamedBufferData(_buffer, _size, _data, _usage);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn namedBufferSubData(self: *const @This(), _buffer: GLuint, _offset: GLintptr, _size: GLsizeiptr, _data: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glNamedBufferSubData");
            defer zone.End();
            const result = self.dispatch.glNamedBufferSubData(_buffer, _offset, _size, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn copyNamedBufferSubData(self: *const @This(), _readBuffer: GLuint, _writeBuffer: GLuint, _readOffset: GLintptr, _writeOffset: GLintptr, _size: GLsizeiptr) Error!void {
            const zone = tracy.ZoneN(@src(), "glCopyNamedBufferSubData");
            defer zone.End();
            const result = self.dispatch.glCopyNamedBufferSubData(_readBuffer, _writeBuffer, _readOffset, _writeOffset, _size);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clearNamedBufferData(self: *const @This(), _buffer: GLuint, _internalformat: GLenum, _format: GLenum, _type: GLenum, _data: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glClearNamedBufferData");
            defer zone.End();
            const result = self.dispatch.glClearNamedBufferData(_buffer, _internalformat, _format, _type, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clearNamedBufferSubData(self: *const @This(), _buffer: GLuint, _internalformat: GLenum, _offset: GLintptr, _size: GLsizeiptr, _format: GLenum, _type: GLenum, _data: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glClearNamedBufferSubData");
            defer zone.End();
            const result = self.dispatch.glClearNamedBufferSubData(_buffer, _internalformat, _offset, _size, _format, _type, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn mapNamedBuffer(self: *const @This(), _buffer: GLuint, _access: GLenum) Error!?*anyopaque {
            const zone = tracy.ZoneN(@src(), "glMapNamedBuffer");
            defer zone.End();
            const result = self.dispatch.glMapNamedBuffer(_buffer, _access);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn mapNamedBufferRange(self: *const @This(), _buffer: GLuint, _offset: GLintptr, _length: GLsizeiptr, _access: GLbitfield) Error!?*anyopaque {
            const zone = tracy.ZoneN(@src(), "glMapNamedBufferRange");
            defer zone.End();
            const result = self.dispatch.glMapNamedBufferRange(_buffer, _offset, _length, _access);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn unmapNamedBuffer(self: *const @This(), _buffer: GLuint) Error!GLboolean {
            const zone = tracy.ZoneN(@src(), "glUnmapNamedBuffer");
            defer zone.End();
            const result = self.dispatch.glUnmapNamedBuffer(_buffer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn flushMappedNamedBufferRange(self: *const @This(), _buffer: GLuint, _offset: GLintptr, _length: GLsizeiptr) Error!void {
            const zone = tracy.ZoneN(@src(), "glFlushMappedNamedBufferRange");
            defer zone.End();
            const result = self.dispatch.glFlushMappedNamedBufferRange(_buffer, _offset, _length);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getNamedBufferParameteriv(self: *const @This(), _buffer: GLuint, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetNamedBufferParameteriv");
            defer zone.End();
            const result = self.dispatch.glGetNamedBufferParameteriv(_buffer, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getNamedBufferParameteri64v(self: *const @This(), _buffer: GLuint, _pname: GLenum, _params: [*c]GLint64) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetNamedBufferParameteri64v");
            defer zone.End();
            const result = self.dispatch.glGetNamedBufferParameteri64v(_buffer, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getNamedBufferPointerv(self: *const @This(), _buffer: GLuint, _pname: GLenum, _params: ?*?*anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetNamedBufferPointerv");
            defer zone.End();
            const result = self.dispatch.glGetNamedBufferPointerv(_buffer, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getNamedBufferSubData(self: *const @This(), _buffer: GLuint, _offset: GLintptr, _size: GLsizeiptr, _data: ?*anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetNamedBufferSubData");
            defer zone.End();
            const result = self.dispatch.glGetNamedBufferSubData(_buffer, _offset, _size, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn createFramebuffers(self: *const @This(), _n: GLsizei, _framebuffers: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glCreateFramebuffers");
            defer zone.End();
            const result = self.dispatch.glCreateFramebuffers(_n, _framebuffers);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn namedFramebufferRenderbuffer(self: *const @This(), _framebuffer: GLuint, _attachment: GLenum, _renderbuffertarget: GLenum, _renderbuffer: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glNamedFramebufferRenderbuffer");
            defer zone.End();
            const result = self.dispatch.glNamedFramebufferRenderbuffer(_framebuffer, _attachment, _renderbuffertarget, _renderbuffer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn namedFramebufferParameteri(self: *const @This(), _framebuffer: GLuint, _pname: GLenum, _param: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glNamedFramebufferParameteri");
            defer zone.End();
            const result = self.dispatch.glNamedFramebufferParameteri(_framebuffer, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn namedFramebufferTexture(self: *const @This(), _framebuffer: GLuint, _attachment: GLenum, _texture: GLuint, _level: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glNamedFramebufferTexture");
            defer zone.End();
            const result = self.dispatch.glNamedFramebufferTexture(_framebuffer, _attachment, _texture, _level);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn namedFramebufferTextureLayer(self: *const @This(), _framebuffer: GLuint, _attachment: GLenum, _texture: GLuint, _level: GLint, _layer: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glNamedFramebufferTextureLayer");
            defer zone.End();
            const result = self.dispatch.glNamedFramebufferTextureLayer(_framebuffer, _attachment, _texture, _level, _layer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn namedFramebufferDrawBuffer(self: *const @This(), _framebuffer: GLuint, _buf: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glNamedFramebufferDrawBuffer");
            defer zone.End();
            const result = self.dispatch.glNamedFramebufferDrawBuffer(_framebuffer, _buf);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn namedFramebufferDrawBuffers(self: *const @This(), _framebuffer: GLuint, _n: GLsizei, _bufs: [*c]const GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glNamedFramebufferDrawBuffers");
            defer zone.End();
            const result = self.dispatch.glNamedFramebufferDrawBuffers(_framebuffer, _n, _bufs);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn namedFramebufferReadBuffer(self: *const @This(), _framebuffer: GLuint, _src: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glNamedFramebufferReadBuffer");
            defer zone.End();
            const result = self.dispatch.glNamedFramebufferReadBuffer(_framebuffer, _src);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn invalidateNamedFramebufferData(self: *const @This(), _framebuffer: GLuint, _numAttachments: GLsizei, _attachments: [*c]const GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glInvalidateNamedFramebufferData");
            defer zone.End();
            const result = self.dispatch.glInvalidateNamedFramebufferData(_framebuffer, _numAttachments, _attachments);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn invalidateNamedFramebufferSubData(self: *const @This(), _framebuffer: GLuint, _numAttachments: GLsizei, _attachments: [*c]const GLenum, _x: GLint, _y: GLint, _width: GLsizei, _height: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glInvalidateNamedFramebufferSubData");
            defer zone.End();
            const result = self.dispatch.glInvalidateNamedFramebufferSubData(_framebuffer, _numAttachments, _attachments, _x, _y, _width, _height);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clearNamedFramebufferiv(self: *const @This(), _framebuffer: GLuint, _buffer: GLenum, _drawbuffer: GLint, _value: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glClearNamedFramebufferiv");
            defer zone.End();
            const result = self.dispatch.glClearNamedFramebufferiv(_framebuffer, _buffer, _drawbuffer, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clearNamedFramebufferuiv(self: *const @This(), _framebuffer: GLuint, _buffer: GLenum, _drawbuffer: GLint, _value: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glClearNamedFramebufferuiv");
            defer zone.End();
            const result = self.dispatch.glClearNamedFramebufferuiv(_framebuffer, _buffer, _drawbuffer, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clearNamedFramebufferfv(self: *const @This(), _framebuffer: GLuint, _buffer: GLenum, _drawbuffer: GLint, _value: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glClearNamedFramebufferfv");
            defer zone.End();
            const result = self.dispatch.glClearNamedFramebufferfv(_framebuffer, _buffer, _drawbuffer, _value);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clearNamedFramebufferfi(self: *const @This(), _framebuffer: GLuint, _buffer: GLenum, _drawbuffer: GLint, _depth: GLfloat, _stencil: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glClearNamedFramebufferfi");
            defer zone.End();
            const result = self.dispatch.glClearNamedFramebufferfi(_framebuffer, _buffer, _drawbuffer, _depth, _stencil);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn blitNamedFramebuffer(self: *const @This(), _readFramebuffer: GLuint, _drawFramebuffer: GLuint, _srcX0: GLint, _srcY0: GLint, _srcX1: GLint, _srcY1: GLint, _dstX0: GLint, _dstY0: GLint, _dstX1: GLint, _dstY1: GLint, _mask: GLbitfield, _filter: GLenum) Error!void {
            const zone = tracy.ZoneN(@src(), "glBlitNamedFramebuffer");
            defer zone.End();
            const result = self.dispatch.glBlitNamedFramebuffer(_readFramebuffer, _drawFramebuffer, _srcX0, _srcY0, _srcX1, _srcY1, _dstX0, _dstY0, _dstX1, _dstY1, _mask, _filter);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn checkNamedFramebufferStatus(self: *const @This(), _framebuffer: GLuint, _target: GLenum) Error!GLenum {
            const zone = tracy.ZoneN(@src(), "glCheckNamedFramebufferStatus");
            defer zone.End();
            const result = self.dispatch.glCheckNamedFramebufferStatus(_framebuffer, _target);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getNamedFramebufferParameteriv(self: *const @This(), _framebuffer: GLuint, _pname: GLenum, _param: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetNamedFramebufferParameteriv");
            defer zone.End();
            const result = self.dispatch.glGetNamedFramebufferParameteriv(_framebuffer, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getNamedFramebufferAttachmentParameteriv(self: *const @This(), _framebuffer: GLuint, _attachment: GLenum, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetNamedFramebufferAttachmentParameteriv");
            defer zone.End();
            const result = self.dispatch.glGetNamedFramebufferAttachmentParameteriv(_framebuffer, _attachment, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn createRenderbuffers(self: *const @This(), _n: GLsizei, _renderbuffers: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glCreateRenderbuffers");
            defer zone.End();
            const result = self.dispatch.glCreateRenderbuffers(_n, _renderbuffers);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn namedRenderbufferStorage(self: *const @This(), _renderbuffer: GLuint, _internalformat: GLenum, _width: GLsizei, _height: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glNamedRenderbufferStorage");
            defer zone.End();
            const result = self.dispatch.glNamedRenderbufferStorage(_renderbuffer, _internalformat, _width, _height);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn namedRenderbufferStorageMultisample(self: *const @This(), _renderbuffer: GLuint, _samples: GLsizei, _internalformat: GLenum, _width: GLsizei, _height: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glNamedRenderbufferStorageMultisample");
            defer zone.End();
            const result = self.dispatch.glNamedRenderbufferStorageMultisample(_renderbuffer, _samples, _internalformat, _width, _height);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getNamedRenderbufferParameteriv(self: *const @This(), _renderbuffer: GLuint, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetNamedRenderbufferParameteriv");
            defer zone.End();
            const result = self.dispatch.glGetNamedRenderbufferParameteriv(_renderbuffer, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn createTextures(self: *const @This(), _target: GLenum, _n: GLsizei, _textures: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glCreateTextures");
            defer zone.End();
            const result = self.dispatch.glCreateTextures(_target, _n, _textures);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn textureBuffer(self: *const @This(), _texture: GLuint, _internalformat: GLenum, _buffer: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTextureBuffer");
            defer zone.End();
            const result = self.dispatch.glTextureBuffer(_texture, _internalformat, _buffer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn textureBufferRange(self: *const @This(), _texture: GLuint, _internalformat: GLenum, _buffer: GLuint, _offset: GLintptr, _size: GLsizeiptr) Error!void {
            const zone = tracy.ZoneN(@src(), "glTextureBufferRange");
            defer zone.End();
            const result = self.dispatch.glTextureBufferRange(_texture, _internalformat, _buffer, _offset, _size);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn textureStorage1D(self: *const @This(), _texture: GLuint, _levels: GLsizei, _internalformat: GLenum, _width: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glTextureStorage1D");
            defer zone.End();
            const result = self.dispatch.glTextureStorage1D(_texture, _levels, _internalformat, _width);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn textureStorage2D(self: *const @This(), _texture: GLuint, _levels: GLsizei, _internalformat: GLenum, _width: GLsizei, _height: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glTextureStorage2D");
            defer zone.End();
            const result = self.dispatch.glTextureStorage2D(_texture, _levels, _internalformat, _width, _height);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn textureStorage3D(self: *const @This(), _texture: GLuint, _levels: GLsizei, _internalformat: GLenum, _width: GLsizei, _height: GLsizei, _depth: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glTextureStorage3D");
            defer zone.End();
            const result = self.dispatch.glTextureStorage3D(_texture, _levels, _internalformat, _width, _height, _depth);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn textureStorage2DMultisample(self: *const @This(), _texture: GLuint, _samples: GLsizei, _internalformat: GLenum, _width: GLsizei, _height: GLsizei, _fixedsamplelocations: GLboolean) Error!void {
            const zone = tracy.ZoneN(@src(), "glTextureStorage2DMultisample");
            defer zone.End();
            const result = self.dispatch.glTextureStorage2DMultisample(_texture, _samples, _internalformat, _width, _height, _fixedsamplelocations);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn textureStorage3DMultisample(self: *const @This(), _texture: GLuint, _samples: GLsizei, _internalformat: GLenum, _width: GLsizei, _height: GLsizei, _depth: GLsizei, _fixedsamplelocations: GLboolean) Error!void {
            const zone = tracy.ZoneN(@src(), "glTextureStorage3DMultisample");
            defer zone.End();
            const result = self.dispatch.glTextureStorage3DMultisample(_texture, _samples, _internalformat, _width, _height, _depth, _fixedsamplelocations);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn textureSubImage1D(self: *const @This(), _texture: GLuint, _level: GLint, _xoffset: GLint, _width: GLsizei, _format: GLenum, _type: GLenum, _pixels: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glTextureSubImage1D");
            defer zone.End();
            const result = self.dispatch.glTextureSubImage1D(_texture, _level, _xoffset, _width, _format, _type, _pixels);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn textureSubImage2D(self: *const @This(), _texture: GLuint, _level: GLint, _xoffset: GLint, _yoffset: GLint, _width: GLsizei, _height: GLsizei, _format: GLenum, _type: GLenum, _pixels: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glTextureSubImage2D");
            defer zone.End();
            const result = self.dispatch.glTextureSubImage2D(_texture, _level, _xoffset, _yoffset, _width, _height, _format, _type, _pixels);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn textureSubImage3D(self: *const @This(), _texture: GLuint, _level: GLint, _xoffset: GLint, _yoffset: GLint, _zoffset: GLint, _width: GLsizei, _height: GLsizei, _depth: GLsizei, _format: GLenum, _type: GLenum, _pixels: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glTextureSubImage3D");
            defer zone.End();
            const result = self.dispatch.glTextureSubImage3D(_texture, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _type, _pixels);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn compressedTextureSubImage1D(self: *const @This(), _texture: GLuint, _level: GLint, _xoffset: GLint, _width: GLsizei, _format: GLenum, _imageSize: GLsizei, _data: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glCompressedTextureSubImage1D");
            defer zone.End();
            const result = self.dispatch.glCompressedTextureSubImage1D(_texture, _level, _xoffset, _width, _format, _imageSize, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn compressedTextureSubImage2D(self: *const @This(), _texture: GLuint, _level: GLint, _xoffset: GLint, _yoffset: GLint, _width: GLsizei, _height: GLsizei, _format: GLenum, _imageSize: GLsizei, _data: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glCompressedTextureSubImage2D");
            defer zone.End();
            const result = self.dispatch.glCompressedTextureSubImage2D(_texture, _level, _xoffset, _yoffset, _width, _height, _format, _imageSize, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn compressedTextureSubImage3D(self: *const @This(), _texture: GLuint, _level: GLint, _xoffset: GLint, _yoffset: GLint, _zoffset: GLint, _width: GLsizei, _height: GLsizei, _depth: GLsizei, _format: GLenum, _imageSize: GLsizei, _data: ?*const anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glCompressedTextureSubImage3D");
            defer zone.End();
            const result = self.dispatch.glCompressedTextureSubImage3D(_texture, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _imageSize, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn copyTextureSubImage1D(self: *const @This(), _texture: GLuint, _level: GLint, _xoffset: GLint, _x: GLint, _y: GLint, _width: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glCopyTextureSubImage1D");
            defer zone.End();
            const result = self.dispatch.glCopyTextureSubImage1D(_texture, _level, _xoffset, _x, _y, _width);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn copyTextureSubImage2D(self: *const @This(), _texture: GLuint, _level: GLint, _xoffset: GLint, _yoffset: GLint, _x: GLint, _y: GLint, _width: GLsizei, _height: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glCopyTextureSubImage2D");
            defer zone.End();
            const result = self.dispatch.glCopyTextureSubImage2D(_texture, _level, _xoffset, _yoffset, _x, _y, _width, _height);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn copyTextureSubImage3D(self: *const @This(), _texture: GLuint, _level: GLint, _xoffset: GLint, _yoffset: GLint, _zoffset: GLint, _x: GLint, _y: GLint, _width: GLsizei, _height: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glCopyTextureSubImage3D");
            defer zone.End();
            const result = self.dispatch.glCopyTextureSubImage3D(_texture, _level, _xoffset, _yoffset, _zoffset, _x, _y, _width, _height);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn textureParameterf(self: *const @This(), _texture: GLuint, _pname: GLenum, _param: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glTextureParameterf");
            defer zone.End();
            const result = self.dispatch.glTextureParameterf(_texture, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn textureParameterfv(self: *const @This(), _texture: GLuint, _pname: GLenum, _param: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glTextureParameterfv");
            defer zone.End();
            const result = self.dispatch.glTextureParameterfv(_texture, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn textureParameteri(self: *const @This(), _texture: GLuint, _pname: GLenum, _param: GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTextureParameteri");
            defer zone.End();
            const result = self.dispatch.glTextureParameteri(_texture, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn textureParameterIiv(self: *const @This(), _texture: GLuint, _pname: GLenum, _params: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTextureParameterIiv");
            defer zone.End();
            const result = self.dispatch.glTextureParameterIiv(_texture, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn textureParameterIuiv(self: *const @This(), _texture: GLuint, _pname: GLenum, _params: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTextureParameterIuiv");
            defer zone.End();
            const result = self.dispatch.glTextureParameterIuiv(_texture, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn textureParameteriv(self: *const @This(), _texture: GLuint, _pname: GLenum, _param: [*c]const GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glTextureParameteriv");
            defer zone.End();
            const result = self.dispatch.glTextureParameteriv(_texture, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn generateTextureMipmap(self: *const @This(), _texture: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGenerateTextureMipmap");
            defer zone.End();
            const result = self.dispatch.glGenerateTextureMipmap(_texture);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn bindTextureUnit(self: *const @This(), _unit: GLuint, _texture: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glBindTextureUnit");
            defer zone.End();
            const result = self.dispatch.glBindTextureUnit(_unit, _texture);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getTextureImage(self: *const @This(), _texture: GLuint, _level: GLint, _format: GLenum, _type: GLenum, _bufSize: GLsizei, _pixels: ?*anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetTextureImage");
            defer zone.End();
            const result = self.dispatch.glGetTextureImage(_texture, _level, _format, _type, _bufSize, _pixels);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getCompressedTextureImage(self: *const @This(), _texture: GLuint, _level: GLint, _bufSize: GLsizei, _pixels: ?*anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetCompressedTextureImage");
            defer zone.End();
            const result = self.dispatch.glGetCompressedTextureImage(_texture, _level, _bufSize, _pixels);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getTextureLevelParameterfv(self: *const @This(), _texture: GLuint, _level: GLint, _pname: GLenum, _params: [*c]GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetTextureLevelParameterfv");
            defer zone.End();
            const result = self.dispatch.glGetTextureLevelParameterfv(_texture, _level, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getTextureLevelParameteriv(self: *const @This(), _texture: GLuint, _level: GLint, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetTextureLevelParameteriv");
            defer zone.End();
            const result = self.dispatch.glGetTextureLevelParameteriv(_texture, _level, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getTextureParameterfv(self: *const @This(), _texture: GLuint, _pname: GLenum, _params: [*c]GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetTextureParameterfv");
            defer zone.End();
            const result = self.dispatch.glGetTextureParameterfv(_texture, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getTextureParameterIiv(self: *const @This(), _texture: GLuint, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetTextureParameterIiv");
            defer zone.End();
            const result = self.dispatch.glGetTextureParameterIiv(_texture, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getTextureParameterIuiv(self: *const @This(), _texture: GLuint, _pname: GLenum, _params: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetTextureParameterIuiv");
            defer zone.End();
            const result = self.dispatch.glGetTextureParameterIuiv(_texture, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getTextureParameteriv(self: *const @This(), _texture: GLuint, _pname: GLenum, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetTextureParameteriv");
            defer zone.End();
            const result = self.dispatch.glGetTextureParameteriv(_texture, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn createVertexArrays(self: *const @This(), _n: GLsizei, _arrays: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glCreateVertexArrays");
            defer zone.End();
            const result = self.dispatch.glCreateVertexArrays(_n, _arrays);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn disableVertexArrayAttrib(self: *const @This(), _vaobj: GLuint, _index: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glDisableVertexArrayAttrib");
            defer zone.End();
            const result = self.dispatch.glDisableVertexArrayAttrib(_vaobj, _index);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn enableVertexArrayAttrib(self: *const @This(), _vaobj: GLuint, _index: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glEnableVertexArrayAttrib");
            defer zone.End();
            const result = self.dispatch.glEnableVertexArrayAttrib(_vaobj, _index);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexArrayElementBuffer(self: *const @This(), _vaobj: GLuint, _buffer: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexArrayElementBuffer");
            defer zone.End();
            const result = self.dispatch.glVertexArrayElementBuffer(_vaobj, _buffer);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexArrayVertexBuffer(self: *const @This(), _vaobj: GLuint, _bindingindex: GLuint, _buffer: GLuint, _offset: GLintptr, _stride: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexArrayVertexBuffer");
            defer zone.End();
            const result = self.dispatch.glVertexArrayVertexBuffer(_vaobj, _bindingindex, _buffer, _offset, _stride);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexArrayVertexBuffers(self: *const @This(), _vaobj: GLuint, _first: GLuint, _count: GLsizei, _buffers: [*c]const GLuint, _offsets: [*c]const GLintptr, _strides: [*c]const GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexArrayVertexBuffers");
            defer zone.End();
            const result = self.dispatch.glVertexArrayVertexBuffers(_vaobj, _first, _count, _buffers, _offsets, _strides);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexArrayAttribBinding(self: *const @This(), _vaobj: GLuint, _attribindex: GLuint, _bindingindex: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexArrayAttribBinding");
            defer zone.End();
            const result = self.dispatch.glVertexArrayAttribBinding(_vaobj, _attribindex, _bindingindex);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexArrayAttribFormat(self: *const @This(), _vaobj: GLuint, _attribindex: GLuint, _size: GLint, _type: GLenum, _normalized: GLboolean, _relativeoffset: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexArrayAttribFormat");
            defer zone.End();
            const result = self.dispatch.glVertexArrayAttribFormat(_vaobj, _attribindex, _size, _type, _normalized, _relativeoffset);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexArrayAttribIFormat(self: *const @This(), _vaobj: GLuint, _attribindex: GLuint, _size: GLint, _type: GLenum, _relativeoffset: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexArrayAttribIFormat");
            defer zone.End();
            const result = self.dispatch.glVertexArrayAttribIFormat(_vaobj, _attribindex, _size, _type, _relativeoffset);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexArrayAttribLFormat(self: *const @This(), _vaobj: GLuint, _attribindex: GLuint, _size: GLint, _type: GLenum, _relativeoffset: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexArrayAttribLFormat");
            defer zone.End();
            const result = self.dispatch.glVertexArrayAttribLFormat(_vaobj, _attribindex, _size, _type, _relativeoffset);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn vertexArrayBindingDivisor(self: *const @This(), _vaobj: GLuint, _bindingindex: GLuint, _divisor: GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glVertexArrayBindingDivisor");
            defer zone.End();
            const result = self.dispatch.glVertexArrayBindingDivisor(_vaobj, _bindingindex, _divisor);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getVertexArrayiv(self: *const @This(), _vaobj: GLuint, _pname: GLenum, _param: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetVertexArrayiv");
            defer zone.End();
            const result = self.dispatch.glGetVertexArrayiv(_vaobj, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getVertexArrayIndexediv(self: *const @This(), _vaobj: GLuint, _index: GLuint, _pname: GLenum, _param: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetVertexArrayIndexediv");
            defer zone.End();
            const result = self.dispatch.glGetVertexArrayIndexediv(_vaobj, _index, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getVertexArrayIndexed64iv(self: *const @This(), _vaobj: GLuint, _index: GLuint, _pname: GLenum, _param: [*c]GLint64) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetVertexArrayIndexed64iv");
            defer zone.End();
            const result = self.dispatch.glGetVertexArrayIndexed64iv(_vaobj, _index, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn createSamplers(self: *const @This(), _n: GLsizei, _samplers: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glCreateSamplers");
            defer zone.End();
            const result = self.dispatch.glCreateSamplers(_n, _samplers);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn createProgramPipelines(self: *const @This(), _n: GLsizei, _pipelines: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glCreateProgramPipelines");
            defer zone.End();
            const result = self.dispatch.glCreateProgramPipelines(_n, _pipelines);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn createQueries(self: *const @This(), _target: GLenum, _n: GLsizei, _ids: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glCreateQueries");
            defer zone.End();
            const result = self.dispatch.glCreateQueries(_target, _n, _ids);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getQueryBufferObjecti64v(self: *const @This(), _id: GLuint, _buffer: GLuint, _pname: GLenum, _offset: GLintptr) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetQueryBufferObjecti64v");
            defer zone.End();
            const result = self.dispatch.glGetQueryBufferObjecti64v(_id, _buffer, _pname, _offset);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getQueryBufferObjectiv(self: *const @This(), _id: GLuint, _buffer: GLuint, _pname: GLenum, _offset: GLintptr) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetQueryBufferObjectiv");
            defer zone.End();
            const result = self.dispatch.glGetQueryBufferObjectiv(_id, _buffer, _pname, _offset);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getQueryBufferObjectui64v(self: *const @This(), _id: GLuint, _buffer: GLuint, _pname: GLenum, _offset: GLintptr) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetQueryBufferObjectui64v");
            defer zone.End();
            const result = self.dispatch.glGetQueryBufferObjectui64v(_id, _buffer, _pname, _offset);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getQueryBufferObjectuiv(self: *const @This(), _id: GLuint, _buffer: GLuint, _pname: GLenum, _offset: GLintptr) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetQueryBufferObjectuiv");
            defer zone.End();
            const result = self.dispatch.glGetQueryBufferObjectuiv(_id, _buffer, _pname, _offset);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn memoryBarrierByRegion(self: *const @This(), _barriers: GLbitfield) Error!void {
            const zone = tracy.ZoneN(@src(), "glMemoryBarrierByRegion");
            defer zone.End();
            const result = self.dispatch.glMemoryBarrierByRegion(_barriers);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getTextureSubImage(self: *const @This(), _texture: GLuint, _level: GLint, _xoffset: GLint, _yoffset: GLint, _zoffset: GLint, _width: GLsizei, _height: GLsizei, _depth: GLsizei, _format: GLenum, _type: GLenum, _bufSize: GLsizei, _pixels: ?*anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetTextureSubImage");
            defer zone.End();
            const result = self.dispatch.glGetTextureSubImage(_texture, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _type, _bufSize, _pixels);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getCompressedTextureSubImage(self: *const @This(), _texture: GLuint, _level: GLint, _xoffset: GLint, _yoffset: GLint, _zoffset: GLint, _width: GLsizei, _height: GLsizei, _depth: GLsizei, _bufSize: GLsizei, _pixels: ?*anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetCompressedTextureSubImage");
            defer zone.End();
            const result = self.dispatch.glGetCompressedTextureSubImage(_texture, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _bufSize, _pixels);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getGraphicsResetStatus(self: *const @This()) Error!GLenum {
            const zone = tracy.ZoneN(@src(), "glGetGraphicsResetStatus");
            defer zone.End();
            const result = self.dispatch.glGetGraphicsResetStatus();
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getnCompressedTexImage(self: *const @This(), _target: GLenum, _lod: GLint, _bufSize: GLsizei, _pixels: ?*anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetnCompressedTexImage");
            defer zone.End();
            const result = self.dispatch.glGetnCompressedTexImage(_target, _lod, _bufSize, _pixels);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getnTexImage(self: *const @This(), _target: GLenum, _level: GLint, _format: GLenum, _type: GLenum, _bufSize: GLsizei, _pixels: ?*anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetnTexImage");
            defer zone.End();
            const result = self.dispatch.glGetnTexImage(_target, _level, _format, _type, _bufSize, _pixels);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getnUniformdv(self: *const @This(), _program: GLuint, _location: GLint, _bufSize: GLsizei, _params: [*c]GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetnUniformdv");
            defer zone.End();
            const result = self.dispatch.glGetnUniformdv(_program, _location, _bufSize, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getnUniformfv(self: *const @This(), _program: GLuint, _location: GLint, _bufSize: GLsizei, _params: [*c]GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetnUniformfv");
            defer zone.End();
            const result = self.dispatch.glGetnUniformfv(_program, _location, _bufSize, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getnUniformiv(self: *const @This(), _program: GLuint, _location: GLint, _bufSize: GLsizei, _params: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetnUniformiv");
            defer zone.End();
            const result = self.dispatch.glGetnUniformiv(_program, _location, _bufSize, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getnUniformuiv(self: *const @This(), _program: GLuint, _location: GLint, _bufSize: GLsizei, _params: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetnUniformuiv");
            defer zone.End();
            const result = self.dispatch.glGetnUniformuiv(_program, _location, _bufSize, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn readnPixels(self: *const @This(), _x: GLint, _y: GLint, _width: GLsizei, _height: GLsizei, _format: GLenum, _type: GLenum, _bufSize: GLsizei, _data: ?*anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glReadnPixels");
            defer zone.End();
            const result = self.dispatch.glReadnPixels(_x, _y, _width, _height, _format, _type, _bufSize, _data);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getnMapdv(self: *const @This(), _target: GLenum, _query: GLenum, _bufSize: GLsizei, _v: [*c]GLdouble) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetnMapdv");
            defer zone.End();
            const result = self.dispatch.glGetnMapdv(_target, _query, _bufSize, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getnMapfv(self: *const @This(), _target: GLenum, _query: GLenum, _bufSize: GLsizei, _v: [*c]GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetnMapfv");
            defer zone.End();
            const result = self.dispatch.glGetnMapfv(_target, _query, _bufSize, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getnMapiv(self: *const @This(), _target: GLenum, _query: GLenum, _bufSize: GLsizei, _v: [*c]GLint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetnMapiv");
            defer zone.End();
            const result = self.dispatch.glGetnMapiv(_target, _query, _bufSize, _v);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getnPixelMapfv(self: *const @This(), _map: GLenum, _bufSize: GLsizei, _values: [*c]GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetnPixelMapfv");
            defer zone.End();
            const result = self.dispatch.glGetnPixelMapfv(_map, _bufSize, _values);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getnPixelMapuiv(self: *const @This(), _map: GLenum, _bufSize: GLsizei, _values: [*c]GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetnPixelMapuiv");
            defer zone.End();
            const result = self.dispatch.glGetnPixelMapuiv(_map, _bufSize, _values);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getnPixelMapusv(self: *const @This(), _map: GLenum, _bufSize: GLsizei, _values: [*c]GLushort) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetnPixelMapusv");
            defer zone.End();
            const result = self.dispatch.glGetnPixelMapusv(_map, _bufSize, _values);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getnPolygonStipple(self: *const @This(), _bufSize: GLsizei, _pattern: [*c]GLubyte) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetnPolygonStipple");
            defer zone.End();
            const result = self.dispatch.glGetnPolygonStipple(_bufSize, _pattern);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getnColorTable(self: *const @This(), _target: GLenum, _format: GLenum, _type: GLenum, _bufSize: GLsizei, _table: ?*anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetnColorTable");
            defer zone.End();
            const result = self.dispatch.glGetnColorTable(_target, _format, _type, _bufSize, _table);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getnConvolutionFilter(self: *const @This(), _target: GLenum, _format: GLenum, _type: GLenum, _bufSize: GLsizei, _image: ?*anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetnConvolutionFilter");
            defer zone.End();
            const result = self.dispatch.glGetnConvolutionFilter(_target, _format, _type, _bufSize, _image);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getnSeparableFilter(self: *const @This(), _target: GLenum, _format: GLenum, _type: GLenum, _rowBufSize: GLsizei, _row: ?*anyopaque, _columnBufSize: GLsizei, _column: ?*anyopaque, _span: ?*anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetnSeparableFilter");
            defer zone.End();
            const result = self.dispatch.glGetnSeparableFilter(_target, _format, _type, _rowBufSize, _row, _columnBufSize, _column, _span);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getnHistogram(self: *const @This(), _target: GLenum, _reset: GLboolean, _format: GLenum, _type: GLenum, _bufSize: GLsizei, _values: ?*anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetnHistogram");
            defer zone.End();
            const result = self.dispatch.glGetnHistogram(_target, _reset, _format, _type, _bufSize, _values);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getnMinmax(self: *const @This(), _target: GLenum, _reset: GLboolean, _format: GLenum, _type: GLenum, _bufSize: GLsizei, _values: ?*anyopaque) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetnMinmax");
            defer zone.End();
            const result = self.dispatch.glGetnMinmax(_target, _reset, _format, _type, _bufSize, _values);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn textureBarrier(self: *const @This()) Error!void {
            const zone = tracy.ZoneN(@src(), "glTextureBarrier");
            defer zone.End();
            const result = self.dispatch.glTextureBarrier();
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn specializeShader(self: *const @This(), _shader: GLuint, _pEntryPoint: [*c]const GLchar, _numSpecializationConstants: GLuint, _pConstantIndex: [*c]const GLuint, _pConstantValue: [*c]const GLuint) Error!void {
            const zone = tracy.ZoneN(@src(), "glSpecializeShader");
            defer zone.End();
            const result = self.dispatch.glSpecializeShader(_shader, _pEntryPoint, _numSpecializationConstants, _pConstantIndex, _pConstantValue);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiDrawArraysIndirectCount(self: *const @This(), _mode: GLenum, _indirect: ?*const anyopaque, _drawcount: GLintptr, _maxdrawcount: GLsizei, _stride: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiDrawArraysIndirectCount");
            defer zone.End();
            const result = self.dispatch.glMultiDrawArraysIndirectCount(_mode, _indirect, _drawcount, _maxdrawcount, _stride);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiDrawElementsIndirectCount(self: *const @This(), _mode: GLenum, _type: GLenum, _indirect: ?*const anyopaque, _drawcount: GLintptr, _maxdrawcount: GLsizei, _stride: GLsizei) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiDrawElementsIndirectCount");
            defer zone.End();
            const result = self.dispatch.glMultiDrawElementsIndirectCount(_mode, _type, _indirect, _drawcount, _maxdrawcount, _stride);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn polygonOffsetClamp(self: *const @This(), _factor: GLfloat, _units: GLfloat, _clamp: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glPolygonOffsetClamp");
            defer zone.End();
            const result = self.dispatch.glPolygonOffsetClamp(_factor, _units, _clamp);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clipPlanef(self: *const @This(), _p: GLenum, _eqn: [*c]const GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glClipPlanef");
            defer zone.End();
            const result = self.dispatch.glClipPlanef(_p, _eqn);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn frustumf(self: *const @This(), _l: GLfloat, _r: GLfloat, _b: GLfloat, _t: GLfloat, _n: GLfloat, _f: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glFrustumf");
            defer zone.End();
            const result = self.dispatch.glFrustumf(_l, _r, _b, _t, _n, _f);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getClipPlanef(self: *const @This(), _plane: GLenum, _equation: [*c]GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetClipPlanef");
            defer zone.End();
            const result = self.dispatch.glGetClipPlanef(_plane, _equation);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn orthof(self: *const @This(), _l: GLfloat, _r: GLfloat, _b: GLfloat, _t: GLfloat, _n: GLfloat, _f: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glOrthof");
            defer zone.End();
            const result = self.dispatch.glOrthof(_l, _r, _b, _t, _n, _f);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn alphaFuncx(self: *const @This(), _func: GLenum, _ref: GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glAlphaFuncx");
            defer zone.End();
            const result = self.dispatch.glAlphaFuncx(_func, _ref);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clearColorx(self: *const @This(), _red: GLfixed, _green: GLfixed, _blue: GLfixed, _alpha: GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glClearColorx");
            defer zone.End();
            const result = self.dispatch.glClearColorx(_red, _green, _blue, _alpha);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clearDepthx(self: *const @This(), _depth: GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glClearDepthx");
            defer zone.End();
            const result = self.dispatch.glClearDepthx(_depth);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn clipPlanex(self: *const @This(), _plane: GLenum, _equation: [*c]const GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glClipPlanex");
            defer zone.End();
            const result = self.dispatch.glClipPlanex(_plane, _equation);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn color4x(self: *const @This(), _red: GLfixed, _green: GLfixed, _blue: GLfixed, _alpha: GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glColor4x");
            defer zone.End();
            const result = self.dispatch.glColor4x(_red, _green, _blue, _alpha);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn depthRangex(self: *const @This(), _n: GLfixed, _f: GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glDepthRangex");
            defer zone.End();
            const result = self.dispatch.glDepthRangex(_n, _f);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn fogx(self: *const @This(), _pname: GLenum, _param: GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glFogx");
            defer zone.End();
            const result = self.dispatch.glFogx(_pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn fogxv(self: *const @This(), _pname: GLenum, _param: [*c]const GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glFogxv");
            defer zone.End();
            const result = self.dispatch.glFogxv(_pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn frustumx(self: *const @This(), _l: GLfixed, _r: GLfixed, _b: GLfixed, _t: GLfixed, _n: GLfixed, _f: GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glFrustumx");
            defer zone.End();
            const result = self.dispatch.glFrustumx(_l, _r, _b, _t, _n, _f);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getClipPlanex(self: *const @This(), _plane: GLenum, _equation: [*c]GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetClipPlanex");
            defer zone.End();
            const result = self.dispatch.glGetClipPlanex(_plane, _equation);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getFixedv(self: *const @This(), _pname: GLenum, _params: [*c]GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetFixedv");
            defer zone.End();
            const result = self.dispatch.glGetFixedv(_pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getLightxv(self: *const @This(), _light: GLenum, _pname: GLenum, _params: [*c]GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetLightxv");
            defer zone.End();
            const result = self.dispatch.glGetLightxv(_light, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getMaterialxv(self: *const @This(), _face: GLenum, _pname: GLenum, _params: [*c]GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetMaterialxv");
            defer zone.End();
            const result = self.dispatch.glGetMaterialxv(_face, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getTexEnvxv(self: *const @This(), _target: GLenum, _pname: GLenum, _params: [*c]GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetTexEnvxv");
            defer zone.End();
            const result = self.dispatch.glGetTexEnvxv(_target, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn getTexParameterxv(self: *const @This(), _target: GLenum, _pname: GLenum, _params: [*c]GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glGetTexParameterxv");
            defer zone.End();
            const result = self.dispatch.glGetTexParameterxv(_target, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn lightModelx(self: *const @This(), _pname: GLenum, _param: GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glLightModelx");
            defer zone.End();
            const result = self.dispatch.glLightModelx(_pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn lightModelxv(self: *const @This(), _pname: GLenum, _param: [*c]const GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glLightModelxv");
            defer zone.End();
            const result = self.dispatch.glLightModelxv(_pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn lightx(self: *const @This(), _light: GLenum, _pname: GLenum, _param: GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glLightx");
            defer zone.End();
            const result = self.dispatch.glLightx(_light, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn lightxv(self: *const @This(), _light: GLenum, _pname: GLenum, _params: [*c]const GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glLightxv");
            defer zone.End();
            const result = self.dispatch.glLightxv(_light, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn lineWidthx(self: *const @This(), _width: GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glLineWidthx");
            defer zone.End();
            const result = self.dispatch.glLineWidthx(_width);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn loadMatrixx(self: *const @This(), _m: [*c]const GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glLoadMatrixx");
            defer zone.End();
            const result = self.dispatch.glLoadMatrixx(_m);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn materialx(self: *const @This(), _face: GLenum, _pname: GLenum, _param: GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glMaterialx");
            defer zone.End();
            const result = self.dispatch.glMaterialx(_face, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn materialxv(self: *const @This(), _face: GLenum, _pname: GLenum, _param: [*c]const GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glMaterialxv");
            defer zone.End();
            const result = self.dispatch.glMaterialxv(_face, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multMatrixx(self: *const @This(), _m: [*c]const GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultMatrixx");
            defer zone.End();
            const result = self.dispatch.glMultMatrixx(_m);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn multiTexCoord4x(self: *const @This(), _texture: GLenum, _s: GLfixed, _t: GLfixed, _r: GLfixed, _q: GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glMultiTexCoord4x");
            defer zone.End();
            const result = self.dispatch.glMultiTexCoord4x(_texture, _s, _t, _r, _q);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn normal3x(self: *const @This(), _nx: GLfixed, _ny: GLfixed, _nz: GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glNormal3x");
            defer zone.End();
            const result = self.dispatch.glNormal3x(_nx, _ny, _nz);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn orthox(self: *const @This(), _l: GLfixed, _r: GLfixed, _b: GLfixed, _t: GLfixed, _n: GLfixed, _f: GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glOrthox");
            defer zone.End();
            const result = self.dispatch.glOrthox(_l, _r, _b, _t, _n, _f);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn pointParameterx(self: *const @This(), _pname: GLenum, _param: GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glPointParameterx");
            defer zone.End();
            const result = self.dispatch.glPointParameterx(_pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn pointParameterxv(self: *const @This(), _pname: GLenum, _params: [*c]const GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glPointParameterxv");
            defer zone.End();
            const result = self.dispatch.glPointParameterxv(_pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn pointSizex(self: *const @This(), _size: GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glPointSizex");
            defer zone.End();
            const result = self.dispatch.glPointSizex(_size);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn polygonOffsetx(self: *const @This(), _factor: GLfixed, _units: GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glPolygonOffsetx");
            defer zone.End();
            const result = self.dispatch.glPolygonOffsetx(_factor, _units);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn rotatex(self: *const @This(), _angle: GLfixed, _x: GLfixed, _y: GLfixed, _z: GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glRotatex");
            defer zone.End();
            const result = self.dispatch.glRotatex(_angle, _x, _y, _z);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn sampleCoveragex(self: *const @This(), _value: GLclampx, _invert: GLboolean) Error!void {
            const zone = tracy.ZoneN(@src(), "glSampleCoveragex");
            defer zone.End();
            const result = self.dispatch.glSampleCoveragex(_value, _invert);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn scalex(self: *const @This(), _x: GLfixed, _y: GLfixed, _z: GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glScalex");
            defer zone.End();
            const result = self.dispatch.glScalex(_x, _y, _z);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texEnvx(self: *const @This(), _target: GLenum, _pname: GLenum, _param: GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexEnvx");
            defer zone.End();
            const result = self.dispatch.glTexEnvx(_target, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texEnvxv(self: *const @This(), _target: GLenum, _pname: GLenum, _params: [*c]const GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexEnvxv");
            defer zone.End();
            const result = self.dispatch.glTexEnvxv(_target, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texParameterx(self: *const @This(), _target: GLenum, _pname: GLenum, _param: GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexParameterx");
            defer zone.End();
            const result = self.dispatch.glTexParameterx(_target, _pname, _param);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn texParameterxv(self: *const @This(), _target: GLenum, _pname: GLenum, _params: [*c]const GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glTexParameterxv");
            defer zone.End();
            const result = self.dispatch.glTexParameterxv(_target, _pname, _params);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn translatex(self: *const @This(), _x: GLfixed, _y: GLfixed, _z: GLfixed) Error!void {
            const zone = tracy.ZoneN(@src(), "glTranslatex");
            defer zone.End();
            const result = self.dispatch.glTranslatex(_x, _y, _z);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn blendBarrier(self: *const @This()) Error!void {
            const zone = tracy.ZoneN(@src(), "glBlendBarrier");
            defer zone.End();
            const result = self.dispatch.glBlendBarrier();
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
        pub inline fn primitiveBoundingBox(self: *const @This(), _minX: GLfloat, _minY: GLfloat, _minZ: GLfloat, _minW: GLfloat, _maxX: GLfloat, _maxY: GLfloat, _maxZ: GLfloat, _maxW: GLfloat) Error!void {
            const zone = tracy.ZoneN(@src(), "glPrimitiveBoundingBox");
            defer zone.End();
            const result = self.dispatch.glPrimitiveBoundingBox(_minX, _minY, _minZ, _minW, _maxX, _maxY, _maxZ, _maxW);
            if (validation and cmds.getError) {
                const err_code = self.dispatch.glGetError();
                if (err_code != NO_ERROR) return errorFromCode(err_code);
            }
            return result;
        }
    };
}

pub const gl10 = CommandFlags{
    .cullFace = true,
    .frontFace = true,
    .hint = true,
    .lineWidth = true,
    .pointSize = true,
    .polygonMode = true,
    .scissor = true,
    .texParameterf = true,
    .texParameterfv = true,
    .texParameteri = true,
    .texParameteriv = true,
    .texImage1D = true,
    .texImage2D = true,
    .drawBuffer = true,
    .clear = true,
    .clearColor = true,
    .clearStencil = true,
    .clearDepth = true,
    .stencilMask = true,
    .colorMask = true,
    .depthMask = true,
    .disable = true,
    .enable = true,
    .finish = true,
    .flush = true,
    .blendFunc = true,
    .logicOp = true,
    .stencilFunc = true,
    .stencilOp = true,
    .depthFunc = true,
    .pixelStoref = true,
    .pixelStorei = true,
    .readBuffer = true,
    .readPixels = true,
    .getBooleanv = true,
    .getDoublev = true,
    .getError = true,
    .getFloatv = true,
    .getIntegerv = true,
    .getString = true,
    .getTexImage = true,
    .getTexParameterfv = true,
    .getTexParameteriv = true,
    .getTexLevelParameterfv = true,
    .getTexLevelParameteriv = true,
    .isEnabled = true,
    .depthRange = true,
    .viewport = true,
    .newList = true,
    .endList = true,
    .callList = true,
    .callLists = true,
    .deleteLists = true,
    .genLists = true,
    .listBase = true,
    .begin = true,
    .bitmap = true,
    .color3b = true,
    .color3bv = true,
    .color3d = true,
    .color3dv = true,
    .color3f = true,
    .color3fv = true,
    .color3i = true,
    .color3iv = true,
    .color3s = true,
    .color3sv = true,
    .color3ub = true,
    .color3ubv = true,
    .color3ui = true,
    .color3uiv = true,
    .color3us = true,
    .color3usv = true,
    .color4b = true,
    .color4bv = true,
    .color4d = true,
    .color4dv = true,
    .color4f = true,
    .color4fv = true,
    .color4i = true,
    .color4iv = true,
    .color4s = true,
    .color4sv = true,
    .color4ub = true,
    .color4ubv = true,
    .color4ui = true,
    .color4uiv = true,
    .color4us = true,
    .color4usv = true,
    .edgeFlag = true,
    .edgeFlagv = true,
    .end = true,
    .indexd = true,
    .indexdv = true,
    .indexf = true,
    .indexfv = true,
    .indexi = true,
    .indexiv = true,
    .indexs = true,
    .indexsv = true,
    .normal3b = true,
    .normal3bv = true,
    .normal3d = true,
    .normal3dv = true,
    .normal3f = true,
    .normal3fv = true,
    .normal3i = true,
    .normal3iv = true,
    .normal3s = true,
    .normal3sv = true,
    .rasterPos2d = true,
    .rasterPos2dv = true,
    .rasterPos2f = true,
    .rasterPos2fv = true,
    .rasterPos2i = true,
    .rasterPos2iv = true,
    .rasterPos2s = true,
    .rasterPos2sv = true,
    .rasterPos3d = true,
    .rasterPos3dv = true,
    .rasterPos3f = true,
    .rasterPos3fv = true,
    .rasterPos3i = true,
    .rasterPos3iv = true,
    .rasterPos3s = true,
    .rasterPos3sv = true,
    .rasterPos4d = true,
    .rasterPos4dv = true,
    .rasterPos4f = true,
    .rasterPos4fv = true,
    .rasterPos4i = true,
    .rasterPos4iv = true,
    .rasterPos4s = true,
    .rasterPos4sv = true,
    .rectd = true,
    .rectdv = true,
    .rectf = true,
    .rectfv = true,
    .recti = true,
    .rectiv = true,
    .rects = true,
    .rectsv = true,
    .texCoord1d = true,
    .texCoord1dv = true,
    .texCoord1f = true,
    .texCoord1fv = true,
    .texCoord1i = true,
    .texCoord1iv = true,
    .texCoord1s = true,
    .texCoord1sv = true,
    .texCoord2d = true,
    .texCoord2dv = true,
    .texCoord2f = true,
    .texCoord2fv = true,
    .texCoord2i = true,
    .texCoord2iv = true,
    .texCoord2s = true,
    .texCoord2sv = true,
    .texCoord3d = true,
    .texCoord3dv = true,
    .texCoord3f = true,
    .texCoord3fv = true,
    .texCoord3i = true,
    .texCoord3iv = true,
    .texCoord3s = true,
    .texCoord3sv = true,
    .texCoord4d = true,
    .texCoord4dv = true,
    .texCoord4f = true,
    .texCoord4fv = true,
    .texCoord4i = true,
    .texCoord4iv = true,
    .texCoord4s = true,
    .texCoord4sv = true,
    .vertex2d = true,
    .vertex2dv = true,
    .vertex2f = true,
    .vertex2fv = true,
    .vertex2i = true,
    .vertex2iv = true,
    .vertex2s = true,
    .vertex2sv = true,
    .vertex3d = true,
    .vertex3dv = true,
    .vertex3f = true,
    .vertex3fv = true,
    .vertex3i = true,
    .vertex3iv = true,
    .vertex3s = true,
    .vertex3sv = true,
    .vertex4d = true,
    .vertex4dv = true,
    .vertex4f = true,
    .vertex4fv = true,
    .vertex4i = true,
    .vertex4iv = true,
    .vertex4s = true,
    .vertex4sv = true,
    .clipPlane = true,
    .colorMaterial = true,
    .fogf = true,
    .fogfv = true,
    .fogi = true,
    .fogiv = true,
    .lightf = true,
    .lightfv = true,
    .lighti = true,
    .lightiv = true,
    .lightModelf = true,
    .lightModelfv = true,
    .lightModeli = true,
    .lightModeliv = true,
    .lineStipple = true,
    .materialf = true,
    .materialfv = true,
    .materiali = true,
    .materialiv = true,
    .polygonStipple = true,
    .shadeModel = true,
    .texEnvf = true,
    .texEnvfv = true,
    .texEnvi = true,
    .texEnviv = true,
    .texGend = true,
    .texGendv = true,
    .texGenf = true,
    .texGenfv = true,
    .texGeni = true,
    .texGeniv = true,
    .feedbackBuffer = true,
    .selectBuffer = true,
    .renderMode = true,
    .initNames = true,
    .loadName = true,
    .passThrough = true,
    .popName = true,
    .pushName = true,
    .clearAccum = true,
    .clearIndex = true,
    .indexMask = true,
    .accum = true,
    .popAttrib = true,
    .pushAttrib = true,
    .map1d = true,
    .map1f = true,
    .map2d = true,
    .map2f = true,
    .mapGrid1d = true,
    .mapGrid1f = true,
    .mapGrid2d = true,
    .mapGrid2f = true,
    .evalCoord1d = true,
    .evalCoord1dv = true,
    .evalCoord1f = true,
    .evalCoord1fv = true,
    .evalCoord2d = true,
    .evalCoord2dv = true,
    .evalCoord2f = true,
    .evalCoord2fv = true,
    .evalMesh1 = true,
    .evalPoint1 = true,
    .evalMesh2 = true,
    .evalPoint2 = true,
    .alphaFunc = true,
    .pixelZoom = true,
    .pixelTransferf = true,
    .pixelTransferi = true,
    .pixelMapfv = true,
    .pixelMapuiv = true,
    .pixelMapusv = true,
    .copyPixels = true,
    .drawPixels = true,
    .getClipPlane = true,
    .getLightfv = true,
    .getLightiv = true,
    .getMapdv = true,
    .getMapfv = true,
    .getMapiv = true,
    .getMaterialfv = true,
    .getMaterialiv = true,
    .getPixelMapfv = true,
    .getPixelMapuiv = true,
    .getPixelMapusv = true,
    .getPolygonStipple = true,
    .getTexEnvfv = true,
    .getTexEnviv = true,
    .getTexGendv = true,
    .getTexGenfv = true,
    .getTexGeniv = true,
    .isList = true,
    .frustum = true,
    .loadIdentity = true,
    .loadMatrixf = true,
    .loadMatrixd = true,
    .matrixMode = true,
    .multMatrixf = true,
    .multMatrixd = true,
    .ortho = true,
    .popMatrix = true,
    .pushMatrix = true,
    .rotated = true,
    .rotatef = true,
    .scaled = true,
    .scalef = true,
    .translated = true,
    .translatef = true,
};

pub const gl11 = CommandFlags{
    .cullFace = true,
    .frontFace = true,
    .hint = true,
    .lineWidth = true,
    .pointSize = true,
    .polygonMode = true,
    .scissor = true,
    .texParameterf = true,
    .texParameterfv = true,
    .texParameteri = true,
    .texParameteriv = true,
    .texImage1D = true,
    .texImage2D = true,
    .drawBuffer = true,
    .clear = true,
    .clearColor = true,
    .clearStencil = true,
    .clearDepth = true,
    .stencilMask = true,
    .colorMask = true,
    .depthMask = true,
    .disable = true,
    .enable = true,
    .finish = true,
    .flush = true,
    .blendFunc = true,
    .logicOp = true,
    .stencilFunc = true,
    .stencilOp = true,
    .depthFunc = true,
    .pixelStoref = true,
    .pixelStorei = true,
    .readBuffer = true,
    .readPixels = true,
    .getBooleanv = true,
    .getDoublev = true,
    .getError = true,
    .getFloatv = true,
    .getIntegerv = true,
    .getString = true,
    .getTexImage = true,
    .getTexParameterfv = true,
    .getTexParameteriv = true,
    .getTexLevelParameterfv = true,
    .getTexLevelParameteriv = true,
    .isEnabled = true,
    .depthRange = true,
    .viewport = true,
    .newList = true,
    .endList = true,
    .callList = true,
    .callLists = true,
    .deleteLists = true,
    .genLists = true,
    .listBase = true,
    .begin = true,
    .bitmap = true,
    .color3b = true,
    .color3bv = true,
    .color3d = true,
    .color3dv = true,
    .color3f = true,
    .color3fv = true,
    .color3i = true,
    .color3iv = true,
    .color3s = true,
    .color3sv = true,
    .color3ub = true,
    .color3ubv = true,
    .color3ui = true,
    .color3uiv = true,
    .color3us = true,
    .color3usv = true,
    .color4b = true,
    .color4bv = true,
    .color4d = true,
    .color4dv = true,
    .color4f = true,
    .color4fv = true,
    .color4i = true,
    .color4iv = true,
    .color4s = true,
    .color4sv = true,
    .color4ub = true,
    .color4ubv = true,
    .color4ui = true,
    .color4uiv = true,
    .color4us = true,
    .color4usv = true,
    .edgeFlag = true,
    .edgeFlagv = true,
    .end = true,
    .indexd = true,
    .indexdv = true,
    .indexf = true,
    .indexfv = true,
    .indexi = true,
    .indexiv = true,
    .indexs = true,
    .indexsv = true,
    .normal3b = true,
    .normal3bv = true,
    .normal3d = true,
    .normal3dv = true,
    .normal3f = true,
    .normal3fv = true,
    .normal3i = true,
    .normal3iv = true,
    .normal3s = true,
    .normal3sv = true,
    .rasterPos2d = true,
    .rasterPos2dv = true,
    .rasterPos2f = true,
    .rasterPos2fv = true,
    .rasterPos2i = true,
    .rasterPos2iv = true,
    .rasterPos2s = true,
    .rasterPos2sv = true,
    .rasterPos3d = true,
    .rasterPos3dv = true,
    .rasterPos3f = true,
    .rasterPos3fv = true,
    .rasterPos3i = true,
    .rasterPos3iv = true,
    .rasterPos3s = true,
    .rasterPos3sv = true,
    .rasterPos4d = true,
    .rasterPos4dv = true,
    .rasterPos4f = true,
    .rasterPos4fv = true,
    .rasterPos4i = true,
    .rasterPos4iv = true,
    .rasterPos4s = true,
    .rasterPos4sv = true,
    .rectd = true,
    .rectdv = true,
    .rectf = true,
    .rectfv = true,
    .recti = true,
    .rectiv = true,
    .rects = true,
    .rectsv = true,
    .texCoord1d = true,
    .texCoord1dv = true,
    .texCoord1f = true,
    .texCoord1fv = true,
    .texCoord1i = true,
    .texCoord1iv = true,
    .texCoord1s = true,
    .texCoord1sv = true,
    .texCoord2d = true,
    .texCoord2dv = true,
    .texCoord2f = true,
    .texCoord2fv = true,
    .texCoord2i = true,
    .texCoord2iv = true,
    .texCoord2s = true,
    .texCoord2sv = true,
    .texCoord3d = true,
    .texCoord3dv = true,
    .texCoord3f = true,
    .texCoord3fv = true,
    .texCoord3i = true,
    .texCoord3iv = true,
    .texCoord3s = true,
    .texCoord3sv = true,
    .texCoord4d = true,
    .texCoord4dv = true,
    .texCoord4f = true,
    .texCoord4fv = true,
    .texCoord4i = true,
    .texCoord4iv = true,
    .texCoord4s = true,
    .texCoord4sv = true,
    .vertex2d = true,
    .vertex2dv = true,
    .vertex2f = true,
    .vertex2fv = true,
    .vertex2i = true,
    .vertex2iv = true,
    .vertex2s = true,
    .vertex2sv = true,
    .vertex3d = true,
    .vertex3dv = true,
    .vertex3f = true,
    .vertex3fv = true,
    .vertex3i = true,
    .vertex3iv = true,
    .vertex3s = true,
    .vertex3sv = true,
    .vertex4d = true,
    .vertex4dv = true,
    .vertex4f = true,
    .vertex4fv = true,
    .vertex4i = true,
    .vertex4iv = true,
    .vertex4s = true,
    .vertex4sv = true,
    .clipPlane = true,
    .colorMaterial = true,
    .fogf = true,
    .fogfv = true,
    .fogi = true,
    .fogiv = true,
    .lightf = true,
    .lightfv = true,
    .lighti = true,
    .lightiv = true,
    .lightModelf = true,
    .lightModelfv = true,
    .lightModeli = true,
    .lightModeliv = true,
    .lineStipple = true,
    .materialf = true,
    .materialfv = true,
    .materiali = true,
    .materialiv = true,
    .polygonStipple = true,
    .shadeModel = true,
    .texEnvf = true,
    .texEnvfv = true,
    .texEnvi = true,
    .texEnviv = true,
    .texGend = true,
    .texGendv = true,
    .texGenf = true,
    .texGenfv = true,
    .texGeni = true,
    .texGeniv = true,
    .feedbackBuffer = true,
    .selectBuffer = true,
    .renderMode = true,
    .initNames = true,
    .loadName = true,
    .passThrough = true,
    .popName = true,
    .pushName = true,
    .clearAccum = true,
    .clearIndex = true,
    .indexMask = true,
    .accum = true,
    .popAttrib = true,
    .pushAttrib = true,
    .map1d = true,
    .map1f = true,
    .map2d = true,
    .map2f = true,
    .mapGrid1d = true,
    .mapGrid1f = true,
    .mapGrid2d = true,
    .mapGrid2f = true,
    .evalCoord1d = true,
    .evalCoord1dv = true,
    .evalCoord1f = true,
    .evalCoord1fv = true,
    .evalCoord2d = true,
    .evalCoord2dv = true,
    .evalCoord2f = true,
    .evalCoord2fv = true,
    .evalMesh1 = true,
    .evalPoint1 = true,
    .evalMesh2 = true,
    .evalPoint2 = true,
    .alphaFunc = true,
    .pixelZoom = true,
    .pixelTransferf = true,
    .pixelTransferi = true,
    .pixelMapfv = true,
    .pixelMapuiv = true,
    .pixelMapusv = true,
    .copyPixels = true,
    .drawPixels = true,
    .getClipPlane = true,
    .getLightfv = true,
    .getLightiv = true,
    .getMapdv = true,
    .getMapfv = true,
    .getMapiv = true,
    .getMaterialfv = true,
    .getMaterialiv = true,
    .getPixelMapfv = true,
    .getPixelMapuiv = true,
    .getPixelMapusv = true,
    .getPolygonStipple = true,
    .getTexEnvfv = true,
    .getTexEnviv = true,
    .getTexGendv = true,
    .getTexGenfv = true,
    .getTexGeniv = true,
    .isList = true,
    .frustum = true,
    .loadIdentity = true,
    .loadMatrixf = true,
    .loadMatrixd = true,
    .matrixMode = true,
    .multMatrixf = true,
    .multMatrixd = true,
    .ortho = true,
    .popMatrix = true,
    .pushMatrix = true,
    .rotated = true,
    .rotatef = true,
    .scaled = true,
    .scalef = true,
    .translated = true,
    .translatef = true,
    .drawArrays = true,
    .drawElements = true,
    .getPointerv = true,
    .polygonOffset = true,
    .copyTexImage1D = true,
    .copyTexImage2D = true,
    .copyTexSubImage1D = true,
    .copyTexSubImage2D = true,
    .texSubImage1D = true,
    .texSubImage2D = true,
    .bindTexture = true,
    .deleteTextures = true,
    .genTextures = true,
    .isTexture = true,
    .arrayElement = true,
    .colorPointer = true,
    .disableClientState = true,
    .edgeFlagPointer = true,
    .enableClientState = true,
    .indexPointer = true,
    .interleavedArrays = true,
    .normalPointer = true,
    .texCoordPointer = true,
    .vertexPointer = true,
    .areTexturesResident = true,
    .prioritizeTextures = true,
    .indexub = true,
    .indexubv = true,
    .popClientAttrib = true,
    .pushClientAttrib = true,
};

pub const gl12 = CommandFlags{
    .cullFace = true,
    .frontFace = true,
    .hint = true,
    .lineWidth = true,
    .pointSize = true,
    .polygonMode = true,
    .scissor = true,
    .texParameterf = true,
    .texParameterfv = true,
    .texParameteri = true,
    .texParameteriv = true,
    .texImage1D = true,
    .texImage2D = true,
    .drawBuffer = true,
    .clear = true,
    .clearColor = true,
    .clearStencil = true,
    .clearDepth = true,
    .stencilMask = true,
    .colorMask = true,
    .depthMask = true,
    .disable = true,
    .enable = true,
    .finish = true,
    .flush = true,
    .blendFunc = true,
    .logicOp = true,
    .stencilFunc = true,
    .stencilOp = true,
    .depthFunc = true,
    .pixelStoref = true,
    .pixelStorei = true,
    .readBuffer = true,
    .readPixels = true,
    .getBooleanv = true,
    .getDoublev = true,
    .getError = true,
    .getFloatv = true,
    .getIntegerv = true,
    .getString = true,
    .getTexImage = true,
    .getTexParameterfv = true,
    .getTexParameteriv = true,
    .getTexLevelParameterfv = true,
    .getTexLevelParameteriv = true,
    .isEnabled = true,
    .depthRange = true,
    .viewport = true,
    .newList = true,
    .endList = true,
    .callList = true,
    .callLists = true,
    .deleteLists = true,
    .genLists = true,
    .listBase = true,
    .begin = true,
    .bitmap = true,
    .color3b = true,
    .color3bv = true,
    .color3d = true,
    .color3dv = true,
    .color3f = true,
    .color3fv = true,
    .color3i = true,
    .color3iv = true,
    .color3s = true,
    .color3sv = true,
    .color3ub = true,
    .color3ubv = true,
    .color3ui = true,
    .color3uiv = true,
    .color3us = true,
    .color3usv = true,
    .color4b = true,
    .color4bv = true,
    .color4d = true,
    .color4dv = true,
    .color4f = true,
    .color4fv = true,
    .color4i = true,
    .color4iv = true,
    .color4s = true,
    .color4sv = true,
    .color4ub = true,
    .color4ubv = true,
    .color4ui = true,
    .color4uiv = true,
    .color4us = true,
    .color4usv = true,
    .edgeFlag = true,
    .edgeFlagv = true,
    .end = true,
    .indexd = true,
    .indexdv = true,
    .indexf = true,
    .indexfv = true,
    .indexi = true,
    .indexiv = true,
    .indexs = true,
    .indexsv = true,
    .normal3b = true,
    .normal3bv = true,
    .normal3d = true,
    .normal3dv = true,
    .normal3f = true,
    .normal3fv = true,
    .normal3i = true,
    .normal3iv = true,
    .normal3s = true,
    .normal3sv = true,
    .rasterPos2d = true,
    .rasterPos2dv = true,
    .rasterPos2f = true,
    .rasterPos2fv = true,
    .rasterPos2i = true,
    .rasterPos2iv = true,
    .rasterPos2s = true,
    .rasterPos2sv = true,
    .rasterPos3d = true,
    .rasterPos3dv = true,
    .rasterPos3f = true,
    .rasterPos3fv = true,
    .rasterPos3i = true,
    .rasterPos3iv = true,
    .rasterPos3s = true,
    .rasterPos3sv = true,
    .rasterPos4d = true,
    .rasterPos4dv = true,
    .rasterPos4f = true,
    .rasterPos4fv = true,
    .rasterPos4i = true,
    .rasterPos4iv = true,
    .rasterPos4s = true,
    .rasterPos4sv = true,
    .rectd = true,
    .rectdv = true,
    .rectf = true,
    .rectfv = true,
    .recti = true,
    .rectiv = true,
    .rects = true,
    .rectsv = true,
    .texCoord1d = true,
    .texCoord1dv = true,
    .texCoord1f = true,
    .texCoord1fv = true,
    .texCoord1i = true,
    .texCoord1iv = true,
    .texCoord1s = true,
    .texCoord1sv = true,
    .texCoord2d = true,
    .texCoord2dv = true,
    .texCoord2f = true,
    .texCoord2fv = true,
    .texCoord2i = true,
    .texCoord2iv = true,
    .texCoord2s = true,
    .texCoord2sv = true,
    .texCoord3d = true,
    .texCoord3dv = true,
    .texCoord3f = true,
    .texCoord3fv = true,
    .texCoord3i = true,
    .texCoord3iv = true,
    .texCoord3s = true,
    .texCoord3sv = true,
    .texCoord4d = true,
    .texCoord4dv = true,
    .texCoord4f = true,
    .texCoord4fv = true,
    .texCoord4i = true,
    .texCoord4iv = true,
    .texCoord4s = true,
    .texCoord4sv = true,
    .vertex2d = true,
    .vertex2dv = true,
    .vertex2f = true,
    .vertex2fv = true,
    .vertex2i = true,
    .vertex2iv = true,
    .vertex2s = true,
    .vertex2sv = true,
    .vertex3d = true,
    .vertex3dv = true,
    .vertex3f = true,
    .vertex3fv = true,
    .vertex3i = true,
    .vertex3iv = true,
    .vertex3s = true,
    .vertex3sv = true,
    .vertex4d = true,
    .vertex4dv = true,
    .vertex4f = true,
    .vertex4fv = true,
    .vertex4i = true,
    .vertex4iv = true,
    .vertex4s = true,
    .vertex4sv = true,
    .clipPlane = true,
    .colorMaterial = true,
    .fogf = true,
    .fogfv = true,
    .fogi = true,
    .fogiv = true,
    .lightf = true,
    .lightfv = true,
    .lighti = true,
    .lightiv = true,
    .lightModelf = true,
    .lightModelfv = true,
    .lightModeli = true,
    .lightModeliv = true,
    .lineStipple = true,
    .materialf = true,
    .materialfv = true,
    .materiali = true,
    .materialiv = true,
    .polygonStipple = true,
    .shadeModel = true,
    .texEnvf = true,
    .texEnvfv = true,
    .texEnvi = true,
    .texEnviv = true,
    .texGend = true,
    .texGendv = true,
    .texGenf = true,
    .texGenfv = true,
    .texGeni = true,
    .texGeniv = true,
    .feedbackBuffer = true,
    .selectBuffer = true,
    .renderMode = true,
    .initNames = true,
    .loadName = true,
    .passThrough = true,
    .popName = true,
    .pushName = true,
    .clearAccum = true,
    .clearIndex = true,
    .indexMask = true,
    .accum = true,
    .popAttrib = true,
    .pushAttrib = true,
    .map1d = true,
    .map1f = true,
    .map2d = true,
    .map2f = true,
    .mapGrid1d = true,
    .mapGrid1f = true,
    .mapGrid2d = true,
    .mapGrid2f = true,
    .evalCoord1d = true,
    .evalCoord1dv = true,
    .evalCoord1f = true,
    .evalCoord1fv = true,
    .evalCoord2d = true,
    .evalCoord2dv = true,
    .evalCoord2f = true,
    .evalCoord2fv = true,
    .evalMesh1 = true,
    .evalPoint1 = true,
    .evalMesh2 = true,
    .evalPoint2 = true,
    .alphaFunc = true,
    .pixelZoom = true,
    .pixelTransferf = true,
    .pixelTransferi = true,
    .pixelMapfv = true,
    .pixelMapuiv = true,
    .pixelMapusv = true,
    .copyPixels = true,
    .drawPixels = true,
    .getClipPlane = true,
    .getLightfv = true,
    .getLightiv = true,
    .getMapdv = true,
    .getMapfv = true,
    .getMapiv = true,
    .getMaterialfv = true,
    .getMaterialiv = true,
    .getPixelMapfv = true,
    .getPixelMapuiv = true,
    .getPixelMapusv = true,
    .getPolygonStipple = true,
    .getTexEnvfv = true,
    .getTexEnviv = true,
    .getTexGendv = true,
    .getTexGenfv = true,
    .getTexGeniv = true,
    .isList = true,
    .frustum = true,
    .loadIdentity = true,
    .loadMatrixf = true,
    .loadMatrixd = true,
    .matrixMode = true,
    .multMatrixf = true,
    .multMatrixd = true,
    .ortho = true,
    .popMatrix = true,
    .pushMatrix = true,
    .rotated = true,
    .rotatef = true,
    .scaled = true,
    .scalef = true,
    .translated = true,
    .translatef = true,
    .drawArrays = true,
    .drawElements = true,
    .getPointerv = true,
    .polygonOffset = true,
    .copyTexImage1D = true,
    .copyTexImage2D = true,
    .copyTexSubImage1D = true,
    .copyTexSubImage2D = true,
    .texSubImage1D = true,
    .texSubImage2D = true,
    .bindTexture = true,
    .deleteTextures = true,
    .genTextures = true,
    .isTexture = true,
    .arrayElement = true,
    .colorPointer = true,
    .disableClientState = true,
    .edgeFlagPointer = true,
    .enableClientState = true,
    .indexPointer = true,
    .interleavedArrays = true,
    .normalPointer = true,
    .texCoordPointer = true,
    .vertexPointer = true,
    .areTexturesResident = true,
    .prioritizeTextures = true,
    .indexub = true,
    .indexubv = true,
    .popClientAttrib = true,
    .pushClientAttrib = true,
    .drawRangeElements = true,
    .texImage3D = true,
    .texSubImage3D = true,
    .copyTexSubImage3D = true,
};

pub const gl13 = CommandFlags{
    .cullFace = true,
    .frontFace = true,
    .hint = true,
    .lineWidth = true,
    .pointSize = true,
    .polygonMode = true,
    .scissor = true,
    .texParameterf = true,
    .texParameterfv = true,
    .texParameteri = true,
    .texParameteriv = true,
    .texImage1D = true,
    .texImage2D = true,
    .drawBuffer = true,
    .clear = true,
    .clearColor = true,
    .clearStencil = true,
    .clearDepth = true,
    .stencilMask = true,
    .colorMask = true,
    .depthMask = true,
    .disable = true,
    .enable = true,
    .finish = true,
    .flush = true,
    .blendFunc = true,
    .logicOp = true,
    .stencilFunc = true,
    .stencilOp = true,
    .depthFunc = true,
    .pixelStoref = true,
    .pixelStorei = true,
    .readBuffer = true,
    .readPixels = true,
    .getBooleanv = true,
    .getDoublev = true,
    .getError = true,
    .getFloatv = true,
    .getIntegerv = true,
    .getString = true,
    .getTexImage = true,
    .getTexParameterfv = true,
    .getTexParameteriv = true,
    .getTexLevelParameterfv = true,
    .getTexLevelParameteriv = true,
    .isEnabled = true,
    .depthRange = true,
    .viewport = true,
    .newList = true,
    .endList = true,
    .callList = true,
    .callLists = true,
    .deleteLists = true,
    .genLists = true,
    .listBase = true,
    .begin = true,
    .bitmap = true,
    .color3b = true,
    .color3bv = true,
    .color3d = true,
    .color3dv = true,
    .color3f = true,
    .color3fv = true,
    .color3i = true,
    .color3iv = true,
    .color3s = true,
    .color3sv = true,
    .color3ub = true,
    .color3ubv = true,
    .color3ui = true,
    .color3uiv = true,
    .color3us = true,
    .color3usv = true,
    .color4b = true,
    .color4bv = true,
    .color4d = true,
    .color4dv = true,
    .color4f = true,
    .color4fv = true,
    .color4i = true,
    .color4iv = true,
    .color4s = true,
    .color4sv = true,
    .color4ub = true,
    .color4ubv = true,
    .color4ui = true,
    .color4uiv = true,
    .color4us = true,
    .color4usv = true,
    .edgeFlag = true,
    .edgeFlagv = true,
    .end = true,
    .indexd = true,
    .indexdv = true,
    .indexf = true,
    .indexfv = true,
    .indexi = true,
    .indexiv = true,
    .indexs = true,
    .indexsv = true,
    .normal3b = true,
    .normal3bv = true,
    .normal3d = true,
    .normal3dv = true,
    .normal3f = true,
    .normal3fv = true,
    .normal3i = true,
    .normal3iv = true,
    .normal3s = true,
    .normal3sv = true,
    .rasterPos2d = true,
    .rasterPos2dv = true,
    .rasterPos2f = true,
    .rasterPos2fv = true,
    .rasterPos2i = true,
    .rasterPos2iv = true,
    .rasterPos2s = true,
    .rasterPos2sv = true,
    .rasterPos3d = true,
    .rasterPos3dv = true,
    .rasterPos3f = true,
    .rasterPos3fv = true,
    .rasterPos3i = true,
    .rasterPos3iv = true,
    .rasterPos3s = true,
    .rasterPos3sv = true,
    .rasterPos4d = true,
    .rasterPos4dv = true,
    .rasterPos4f = true,
    .rasterPos4fv = true,
    .rasterPos4i = true,
    .rasterPos4iv = true,
    .rasterPos4s = true,
    .rasterPos4sv = true,
    .rectd = true,
    .rectdv = true,
    .rectf = true,
    .rectfv = true,
    .recti = true,
    .rectiv = true,
    .rects = true,
    .rectsv = true,
    .texCoord1d = true,
    .texCoord1dv = true,
    .texCoord1f = true,
    .texCoord1fv = true,
    .texCoord1i = true,
    .texCoord1iv = true,
    .texCoord1s = true,
    .texCoord1sv = true,
    .texCoord2d = true,
    .texCoord2dv = true,
    .texCoord2f = true,
    .texCoord2fv = true,
    .texCoord2i = true,
    .texCoord2iv = true,
    .texCoord2s = true,
    .texCoord2sv = true,
    .texCoord3d = true,
    .texCoord3dv = true,
    .texCoord3f = true,
    .texCoord3fv = true,
    .texCoord3i = true,
    .texCoord3iv = true,
    .texCoord3s = true,
    .texCoord3sv = true,
    .texCoord4d = true,
    .texCoord4dv = true,
    .texCoord4f = true,
    .texCoord4fv = true,
    .texCoord4i = true,
    .texCoord4iv = true,
    .texCoord4s = true,
    .texCoord4sv = true,
    .vertex2d = true,
    .vertex2dv = true,
    .vertex2f = true,
    .vertex2fv = true,
    .vertex2i = true,
    .vertex2iv = true,
    .vertex2s = true,
    .vertex2sv = true,
    .vertex3d = true,
    .vertex3dv = true,
    .vertex3f = true,
    .vertex3fv = true,
    .vertex3i = true,
    .vertex3iv = true,
    .vertex3s = true,
    .vertex3sv = true,
    .vertex4d = true,
    .vertex4dv = true,
    .vertex4f = true,
    .vertex4fv = true,
    .vertex4i = true,
    .vertex4iv = true,
    .vertex4s = true,
    .vertex4sv = true,
    .clipPlane = true,
    .colorMaterial = true,
    .fogf = true,
    .fogfv = true,
    .fogi = true,
    .fogiv = true,
    .lightf = true,
    .lightfv = true,
    .lighti = true,
    .lightiv = true,
    .lightModelf = true,
    .lightModelfv = true,
    .lightModeli = true,
    .lightModeliv = true,
    .lineStipple = true,
    .materialf = true,
    .materialfv = true,
    .materiali = true,
    .materialiv = true,
    .polygonStipple = true,
    .shadeModel = true,
    .texEnvf = true,
    .texEnvfv = true,
    .texEnvi = true,
    .texEnviv = true,
    .texGend = true,
    .texGendv = true,
    .texGenf = true,
    .texGenfv = true,
    .texGeni = true,
    .texGeniv = true,
    .feedbackBuffer = true,
    .selectBuffer = true,
    .renderMode = true,
    .initNames = true,
    .loadName = true,
    .passThrough = true,
    .popName = true,
    .pushName = true,
    .clearAccum = true,
    .clearIndex = true,
    .indexMask = true,
    .accum = true,
    .popAttrib = true,
    .pushAttrib = true,
    .map1d = true,
    .map1f = true,
    .map2d = true,
    .map2f = true,
    .mapGrid1d = true,
    .mapGrid1f = true,
    .mapGrid2d = true,
    .mapGrid2f = true,
    .evalCoord1d = true,
    .evalCoord1dv = true,
    .evalCoord1f = true,
    .evalCoord1fv = true,
    .evalCoord2d = true,
    .evalCoord2dv = true,
    .evalCoord2f = true,
    .evalCoord2fv = true,
    .evalMesh1 = true,
    .evalPoint1 = true,
    .evalMesh2 = true,
    .evalPoint2 = true,
    .alphaFunc = true,
    .pixelZoom = true,
    .pixelTransferf = true,
    .pixelTransferi = true,
    .pixelMapfv = true,
    .pixelMapuiv = true,
    .pixelMapusv = true,
    .copyPixels = true,
    .drawPixels = true,
    .getClipPlane = true,
    .getLightfv = true,
    .getLightiv = true,
    .getMapdv = true,
    .getMapfv = true,
    .getMapiv = true,
    .getMaterialfv = true,
    .getMaterialiv = true,
    .getPixelMapfv = true,
    .getPixelMapuiv = true,
    .getPixelMapusv = true,
    .getPolygonStipple = true,
    .getTexEnvfv = true,
    .getTexEnviv = true,
    .getTexGendv = true,
    .getTexGenfv = true,
    .getTexGeniv = true,
    .isList = true,
    .frustum = true,
    .loadIdentity = true,
    .loadMatrixf = true,
    .loadMatrixd = true,
    .matrixMode = true,
    .multMatrixf = true,
    .multMatrixd = true,
    .ortho = true,
    .popMatrix = true,
    .pushMatrix = true,
    .rotated = true,
    .rotatef = true,
    .scaled = true,
    .scalef = true,
    .translated = true,
    .translatef = true,
    .drawArrays = true,
    .drawElements = true,
    .getPointerv = true,
    .polygonOffset = true,
    .copyTexImage1D = true,
    .copyTexImage2D = true,
    .copyTexSubImage1D = true,
    .copyTexSubImage2D = true,
    .texSubImage1D = true,
    .texSubImage2D = true,
    .bindTexture = true,
    .deleteTextures = true,
    .genTextures = true,
    .isTexture = true,
    .arrayElement = true,
    .colorPointer = true,
    .disableClientState = true,
    .edgeFlagPointer = true,
    .enableClientState = true,
    .indexPointer = true,
    .interleavedArrays = true,
    .normalPointer = true,
    .texCoordPointer = true,
    .vertexPointer = true,
    .areTexturesResident = true,
    .prioritizeTextures = true,
    .indexub = true,
    .indexubv = true,
    .popClientAttrib = true,
    .pushClientAttrib = true,
    .drawRangeElements = true,
    .texImage3D = true,
    .texSubImage3D = true,
    .copyTexSubImage3D = true,
    .activeTexture = true,
    .sampleCoverage = true,
    .compressedTexImage3D = true,
    .compressedTexImage2D = true,
    .compressedTexImage1D = true,
    .compressedTexSubImage3D = true,
    .compressedTexSubImage2D = true,
    .compressedTexSubImage1D = true,
    .getCompressedTexImage = true,
    .clientActiveTexture = true,
    .multiTexCoord1d = true,
    .multiTexCoord1dv = true,
    .multiTexCoord1f = true,
    .multiTexCoord1fv = true,
    .multiTexCoord1i = true,
    .multiTexCoord1iv = true,
    .multiTexCoord1s = true,
    .multiTexCoord1sv = true,
    .multiTexCoord2d = true,
    .multiTexCoord2dv = true,
    .multiTexCoord2f = true,
    .multiTexCoord2fv = true,
    .multiTexCoord2i = true,
    .multiTexCoord2iv = true,
    .multiTexCoord2s = true,
    .multiTexCoord2sv = true,
    .multiTexCoord3d = true,
    .multiTexCoord3dv = true,
    .multiTexCoord3f = true,
    .multiTexCoord3fv = true,
    .multiTexCoord3i = true,
    .multiTexCoord3iv = true,
    .multiTexCoord3s = true,
    .multiTexCoord3sv = true,
    .multiTexCoord4d = true,
    .multiTexCoord4dv = true,
    .multiTexCoord4f = true,
    .multiTexCoord4fv = true,
    .multiTexCoord4i = true,
    .multiTexCoord4iv = true,
    .multiTexCoord4s = true,
    .multiTexCoord4sv = true,
    .loadTransposeMatrixf = true,
    .loadTransposeMatrixd = true,
    .multTransposeMatrixf = true,
    .multTransposeMatrixd = true,
};

pub const gl14 = CommandFlags{
    .cullFace = true,
    .frontFace = true,
    .hint = true,
    .lineWidth = true,
    .pointSize = true,
    .polygonMode = true,
    .scissor = true,
    .texParameterf = true,
    .texParameterfv = true,
    .texParameteri = true,
    .texParameteriv = true,
    .texImage1D = true,
    .texImage2D = true,
    .drawBuffer = true,
    .clear = true,
    .clearColor = true,
    .clearStencil = true,
    .clearDepth = true,
    .stencilMask = true,
    .colorMask = true,
    .depthMask = true,
    .disable = true,
    .enable = true,
    .finish = true,
    .flush = true,
    .blendFunc = true,
    .logicOp = true,
    .stencilFunc = true,
    .stencilOp = true,
    .depthFunc = true,
    .pixelStoref = true,
    .pixelStorei = true,
    .readBuffer = true,
    .readPixels = true,
    .getBooleanv = true,
    .getDoublev = true,
    .getError = true,
    .getFloatv = true,
    .getIntegerv = true,
    .getString = true,
    .getTexImage = true,
    .getTexParameterfv = true,
    .getTexParameteriv = true,
    .getTexLevelParameterfv = true,
    .getTexLevelParameteriv = true,
    .isEnabled = true,
    .depthRange = true,
    .viewport = true,
    .newList = true,
    .endList = true,
    .callList = true,
    .callLists = true,
    .deleteLists = true,
    .genLists = true,
    .listBase = true,
    .begin = true,
    .bitmap = true,
    .color3b = true,
    .color3bv = true,
    .color3d = true,
    .color3dv = true,
    .color3f = true,
    .color3fv = true,
    .color3i = true,
    .color3iv = true,
    .color3s = true,
    .color3sv = true,
    .color3ub = true,
    .color3ubv = true,
    .color3ui = true,
    .color3uiv = true,
    .color3us = true,
    .color3usv = true,
    .color4b = true,
    .color4bv = true,
    .color4d = true,
    .color4dv = true,
    .color4f = true,
    .color4fv = true,
    .color4i = true,
    .color4iv = true,
    .color4s = true,
    .color4sv = true,
    .color4ub = true,
    .color4ubv = true,
    .color4ui = true,
    .color4uiv = true,
    .color4us = true,
    .color4usv = true,
    .edgeFlag = true,
    .edgeFlagv = true,
    .end = true,
    .indexd = true,
    .indexdv = true,
    .indexf = true,
    .indexfv = true,
    .indexi = true,
    .indexiv = true,
    .indexs = true,
    .indexsv = true,
    .normal3b = true,
    .normal3bv = true,
    .normal3d = true,
    .normal3dv = true,
    .normal3f = true,
    .normal3fv = true,
    .normal3i = true,
    .normal3iv = true,
    .normal3s = true,
    .normal3sv = true,
    .rasterPos2d = true,
    .rasterPos2dv = true,
    .rasterPos2f = true,
    .rasterPos2fv = true,
    .rasterPos2i = true,
    .rasterPos2iv = true,
    .rasterPos2s = true,
    .rasterPos2sv = true,
    .rasterPos3d = true,
    .rasterPos3dv = true,
    .rasterPos3f = true,
    .rasterPos3fv = true,
    .rasterPos3i = true,
    .rasterPos3iv = true,
    .rasterPos3s = true,
    .rasterPos3sv = true,
    .rasterPos4d = true,
    .rasterPos4dv = true,
    .rasterPos4f = true,
    .rasterPos4fv = true,
    .rasterPos4i = true,
    .rasterPos4iv = true,
    .rasterPos4s = true,
    .rasterPos4sv = true,
    .rectd = true,
    .rectdv = true,
    .rectf = true,
    .rectfv = true,
    .recti = true,
    .rectiv = true,
    .rects = true,
    .rectsv = true,
    .texCoord1d = true,
    .texCoord1dv = true,
    .texCoord1f = true,
    .texCoord1fv = true,
    .texCoord1i = true,
    .texCoord1iv = true,
    .texCoord1s = true,
    .texCoord1sv = true,
    .texCoord2d = true,
    .texCoord2dv = true,
    .texCoord2f = true,
    .texCoord2fv = true,
    .texCoord2i = true,
    .texCoord2iv = true,
    .texCoord2s = true,
    .texCoord2sv = true,
    .texCoord3d = true,
    .texCoord3dv = true,
    .texCoord3f = true,
    .texCoord3fv = true,
    .texCoord3i = true,
    .texCoord3iv = true,
    .texCoord3s = true,
    .texCoord3sv = true,
    .texCoord4d = true,
    .texCoord4dv = true,
    .texCoord4f = true,
    .texCoord4fv = true,
    .texCoord4i = true,
    .texCoord4iv = true,
    .texCoord4s = true,
    .texCoord4sv = true,
    .vertex2d = true,
    .vertex2dv = true,
    .vertex2f = true,
    .vertex2fv = true,
    .vertex2i = true,
    .vertex2iv = true,
    .vertex2s = true,
    .vertex2sv = true,
    .vertex3d = true,
    .vertex3dv = true,
    .vertex3f = true,
    .vertex3fv = true,
    .vertex3i = true,
    .vertex3iv = true,
    .vertex3s = true,
    .vertex3sv = true,
    .vertex4d = true,
    .vertex4dv = true,
    .vertex4f = true,
    .vertex4fv = true,
    .vertex4i = true,
    .vertex4iv = true,
    .vertex4s = true,
    .vertex4sv = true,
    .clipPlane = true,
    .colorMaterial = true,
    .fogf = true,
    .fogfv = true,
    .fogi = true,
    .fogiv = true,
    .lightf = true,
    .lightfv = true,
    .lighti = true,
    .lightiv = true,
    .lightModelf = true,
    .lightModelfv = true,
    .lightModeli = true,
    .lightModeliv = true,
    .lineStipple = true,
    .materialf = true,
    .materialfv = true,
    .materiali = true,
    .materialiv = true,
    .polygonStipple = true,
    .shadeModel = true,
    .texEnvf = true,
    .texEnvfv = true,
    .texEnvi = true,
    .texEnviv = true,
    .texGend = true,
    .texGendv = true,
    .texGenf = true,
    .texGenfv = true,
    .texGeni = true,
    .texGeniv = true,
    .feedbackBuffer = true,
    .selectBuffer = true,
    .renderMode = true,
    .initNames = true,
    .loadName = true,
    .passThrough = true,
    .popName = true,
    .pushName = true,
    .clearAccum = true,
    .clearIndex = true,
    .indexMask = true,
    .accum = true,
    .popAttrib = true,
    .pushAttrib = true,
    .map1d = true,
    .map1f = true,
    .map2d = true,
    .map2f = true,
    .mapGrid1d = true,
    .mapGrid1f = true,
    .mapGrid2d = true,
    .mapGrid2f = true,
    .evalCoord1d = true,
    .evalCoord1dv = true,
    .evalCoord1f = true,
    .evalCoord1fv = true,
    .evalCoord2d = true,
    .evalCoord2dv = true,
    .evalCoord2f = true,
    .evalCoord2fv = true,
    .evalMesh1 = true,
    .evalPoint1 = true,
    .evalMesh2 = true,
    .evalPoint2 = true,
    .alphaFunc = true,
    .pixelZoom = true,
    .pixelTransferf = true,
    .pixelTransferi = true,
    .pixelMapfv = true,
    .pixelMapuiv = true,
    .pixelMapusv = true,
    .copyPixels = true,
    .drawPixels = true,
    .getClipPlane = true,
    .getLightfv = true,
    .getLightiv = true,
    .getMapdv = true,
    .getMapfv = true,
    .getMapiv = true,
    .getMaterialfv = true,
    .getMaterialiv = true,
    .getPixelMapfv = true,
    .getPixelMapuiv = true,
    .getPixelMapusv = true,
    .getPolygonStipple = true,
    .getTexEnvfv = true,
    .getTexEnviv = true,
    .getTexGendv = true,
    .getTexGenfv = true,
    .getTexGeniv = true,
    .isList = true,
    .frustum = true,
    .loadIdentity = true,
    .loadMatrixf = true,
    .loadMatrixd = true,
    .matrixMode = true,
    .multMatrixf = true,
    .multMatrixd = true,
    .ortho = true,
    .popMatrix = true,
    .pushMatrix = true,
    .rotated = true,
    .rotatef = true,
    .scaled = true,
    .scalef = true,
    .translated = true,
    .translatef = true,
    .drawArrays = true,
    .drawElements = true,
    .getPointerv = true,
    .polygonOffset = true,
    .copyTexImage1D = true,
    .copyTexImage2D = true,
    .copyTexSubImage1D = true,
    .copyTexSubImage2D = true,
    .texSubImage1D = true,
    .texSubImage2D = true,
    .bindTexture = true,
    .deleteTextures = true,
    .genTextures = true,
    .isTexture = true,
    .arrayElement = true,
    .colorPointer = true,
    .disableClientState = true,
    .edgeFlagPointer = true,
    .enableClientState = true,
    .indexPointer = true,
    .interleavedArrays = true,
    .normalPointer = true,
    .texCoordPointer = true,
    .vertexPointer = true,
    .areTexturesResident = true,
    .prioritizeTextures = true,
    .indexub = true,
    .indexubv = true,
    .popClientAttrib = true,
    .pushClientAttrib = true,
    .drawRangeElements = true,
    .texImage3D = true,
    .texSubImage3D = true,
    .copyTexSubImage3D = true,
    .activeTexture = true,
    .sampleCoverage = true,
    .compressedTexImage3D = true,
    .compressedTexImage2D = true,
    .compressedTexImage1D = true,
    .compressedTexSubImage3D = true,
    .compressedTexSubImage2D = true,
    .compressedTexSubImage1D = true,
    .getCompressedTexImage = true,
    .clientActiveTexture = true,
    .multiTexCoord1d = true,
    .multiTexCoord1dv = true,
    .multiTexCoord1f = true,
    .multiTexCoord1fv = true,
    .multiTexCoord1i = true,
    .multiTexCoord1iv = true,
    .multiTexCoord1s = true,
    .multiTexCoord1sv = true,
    .multiTexCoord2d = true,
    .multiTexCoord2dv = true,
    .multiTexCoord2f = true,
    .multiTexCoord2fv = true,
    .multiTexCoord2i = true,
    .multiTexCoord2iv = true,
    .multiTexCoord2s = true,
    .multiTexCoord2sv = true,
    .multiTexCoord3d = true,
    .multiTexCoord3dv = true,
    .multiTexCoord3f = true,
    .multiTexCoord3fv = true,
    .multiTexCoord3i = true,
    .multiTexCoord3iv = true,
    .multiTexCoord3s = true,
    .multiTexCoord3sv = true,
    .multiTexCoord4d = true,
    .multiTexCoord4dv = true,
    .multiTexCoord4f = true,
    .multiTexCoord4fv = true,
    .multiTexCoord4i = true,
    .multiTexCoord4iv = true,
    .multiTexCoord4s = true,
    .multiTexCoord4sv = true,
    .loadTransposeMatrixf = true,
    .loadTransposeMatrixd = true,
    .multTransposeMatrixf = true,
    .multTransposeMatrixd = true,
    .blendFuncSeparate = true,
    .multiDrawArrays = true,
    .multiDrawElements = true,
    .pointParameterf = true,
    .pointParameterfv = true,
    .pointParameteri = true,
    .pointParameteriv = true,
    .fogCoordf = true,
    .fogCoordfv = true,
    .fogCoordd = true,
    .fogCoorddv = true,
    .fogCoordPointer = true,
    .secondaryColor3b = true,
    .secondaryColor3bv = true,
    .secondaryColor3d = true,
    .secondaryColor3dv = true,
    .secondaryColor3f = true,
    .secondaryColor3fv = true,
    .secondaryColor3i = true,
    .secondaryColor3iv = true,
    .secondaryColor3s = true,
    .secondaryColor3sv = true,
    .secondaryColor3ub = true,
    .secondaryColor3ubv = true,
    .secondaryColor3ui = true,
    .secondaryColor3uiv = true,
    .secondaryColor3us = true,
    .secondaryColor3usv = true,
    .secondaryColorPointer = true,
    .windowPos2d = true,
    .windowPos2dv = true,
    .windowPos2f = true,
    .windowPos2fv = true,
    .windowPos2i = true,
    .windowPos2iv = true,
    .windowPos2s = true,
    .windowPos2sv = true,
    .windowPos3d = true,
    .windowPos3dv = true,
    .windowPos3f = true,
    .windowPos3fv = true,
    .windowPos3i = true,
    .windowPos3iv = true,
    .windowPos3s = true,
    .windowPos3sv = true,
    .blendColor = true,
    .blendEquation = true,
};

pub const gl15 = CommandFlags{
    .cullFace = true,
    .frontFace = true,
    .hint = true,
    .lineWidth = true,
    .pointSize = true,
    .polygonMode = true,
    .scissor = true,
    .texParameterf = true,
    .texParameterfv = true,
    .texParameteri = true,
    .texParameteriv = true,
    .texImage1D = true,
    .texImage2D = true,
    .drawBuffer = true,
    .clear = true,
    .clearColor = true,
    .clearStencil = true,
    .clearDepth = true,
    .stencilMask = true,
    .colorMask = true,
    .depthMask = true,
    .disable = true,
    .enable = true,
    .finish = true,
    .flush = true,
    .blendFunc = true,
    .logicOp = true,
    .stencilFunc = true,
    .stencilOp = true,
    .depthFunc = true,
    .pixelStoref = true,
    .pixelStorei = true,
    .readBuffer = true,
    .readPixels = true,
    .getBooleanv = true,
    .getDoublev = true,
    .getError = true,
    .getFloatv = true,
    .getIntegerv = true,
    .getString = true,
    .getTexImage = true,
    .getTexParameterfv = true,
    .getTexParameteriv = true,
    .getTexLevelParameterfv = true,
    .getTexLevelParameteriv = true,
    .isEnabled = true,
    .depthRange = true,
    .viewport = true,
    .newList = true,
    .endList = true,
    .callList = true,
    .callLists = true,
    .deleteLists = true,
    .genLists = true,
    .listBase = true,
    .begin = true,
    .bitmap = true,
    .color3b = true,
    .color3bv = true,
    .color3d = true,
    .color3dv = true,
    .color3f = true,
    .color3fv = true,
    .color3i = true,
    .color3iv = true,
    .color3s = true,
    .color3sv = true,
    .color3ub = true,
    .color3ubv = true,
    .color3ui = true,
    .color3uiv = true,
    .color3us = true,
    .color3usv = true,
    .color4b = true,
    .color4bv = true,
    .color4d = true,
    .color4dv = true,
    .color4f = true,
    .color4fv = true,
    .color4i = true,
    .color4iv = true,
    .color4s = true,
    .color4sv = true,
    .color4ub = true,
    .color4ubv = true,
    .color4ui = true,
    .color4uiv = true,
    .color4us = true,
    .color4usv = true,
    .edgeFlag = true,
    .edgeFlagv = true,
    .end = true,
    .indexd = true,
    .indexdv = true,
    .indexf = true,
    .indexfv = true,
    .indexi = true,
    .indexiv = true,
    .indexs = true,
    .indexsv = true,
    .normal3b = true,
    .normal3bv = true,
    .normal3d = true,
    .normal3dv = true,
    .normal3f = true,
    .normal3fv = true,
    .normal3i = true,
    .normal3iv = true,
    .normal3s = true,
    .normal3sv = true,
    .rasterPos2d = true,
    .rasterPos2dv = true,
    .rasterPos2f = true,
    .rasterPos2fv = true,
    .rasterPos2i = true,
    .rasterPos2iv = true,
    .rasterPos2s = true,
    .rasterPos2sv = true,
    .rasterPos3d = true,
    .rasterPos3dv = true,
    .rasterPos3f = true,
    .rasterPos3fv = true,
    .rasterPos3i = true,
    .rasterPos3iv = true,
    .rasterPos3s = true,
    .rasterPos3sv = true,
    .rasterPos4d = true,
    .rasterPos4dv = true,
    .rasterPos4f = true,
    .rasterPos4fv = true,
    .rasterPos4i = true,
    .rasterPos4iv = true,
    .rasterPos4s = true,
    .rasterPos4sv = true,
    .rectd = true,
    .rectdv = true,
    .rectf = true,
    .rectfv = true,
    .recti = true,
    .rectiv = true,
    .rects = true,
    .rectsv = true,
    .texCoord1d = true,
    .texCoord1dv = true,
    .texCoord1f = true,
    .texCoord1fv = true,
    .texCoord1i = true,
    .texCoord1iv = true,
    .texCoord1s = true,
    .texCoord1sv = true,
    .texCoord2d = true,
    .texCoord2dv = true,
    .texCoord2f = true,
    .texCoord2fv = true,
    .texCoord2i = true,
    .texCoord2iv = true,
    .texCoord2s = true,
    .texCoord2sv = true,
    .texCoord3d = true,
    .texCoord3dv = true,
    .texCoord3f = true,
    .texCoord3fv = true,
    .texCoord3i = true,
    .texCoord3iv = true,
    .texCoord3s = true,
    .texCoord3sv = true,
    .texCoord4d = true,
    .texCoord4dv = true,
    .texCoord4f = true,
    .texCoord4fv = true,
    .texCoord4i = true,
    .texCoord4iv = true,
    .texCoord4s = true,
    .texCoord4sv = true,
    .vertex2d = true,
    .vertex2dv = true,
    .vertex2f = true,
    .vertex2fv = true,
    .vertex2i = true,
    .vertex2iv = true,
    .vertex2s = true,
    .vertex2sv = true,
    .vertex3d = true,
    .vertex3dv = true,
    .vertex3f = true,
    .vertex3fv = true,
    .vertex3i = true,
    .vertex3iv = true,
    .vertex3s = true,
    .vertex3sv = true,
    .vertex4d = true,
    .vertex4dv = true,
    .vertex4f = true,
    .vertex4fv = true,
    .vertex4i = true,
    .vertex4iv = true,
    .vertex4s = true,
    .vertex4sv = true,
    .clipPlane = true,
    .colorMaterial = true,
    .fogf = true,
    .fogfv = true,
    .fogi = true,
    .fogiv = true,
    .lightf = true,
    .lightfv = true,
    .lighti = true,
    .lightiv = true,
    .lightModelf = true,
    .lightModelfv = true,
    .lightModeli = true,
    .lightModeliv = true,
    .lineStipple = true,
    .materialf = true,
    .materialfv = true,
    .materiali = true,
    .materialiv = true,
    .polygonStipple = true,
    .shadeModel = true,
    .texEnvf = true,
    .texEnvfv = true,
    .texEnvi = true,
    .texEnviv = true,
    .texGend = true,
    .texGendv = true,
    .texGenf = true,
    .texGenfv = true,
    .texGeni = true,
    .texGeniv = true,
    .feedbackBuffer = true,
    .selectBuffer = true,
    .renderMode = true,
    .initNames = true,
    .loadName = true,
    .passThrough = true,
    .popName = true,
    .pushName = true,
    .clearAccum = true,
    .clearIndex = true,
    .indexMask = true,
    .accum = true,
    .popAttrib = true,
    .pushAttrib = true,
    .map1d = true,
    .map1f = true,
    .map2d = true,
    .map2f = true,
    .mapGrid1d = true,
    .mapGrid1f = true,
    .mapGrid2d = true,
    .mapGrid2f = true,
    .evalCoord1d = true,
    .evalCoord1dv = true,
    .evalCoord1f = true,
    .evalCoord1fv = true,
    .evalCoord2d = true,
    .evalCoord2dv = true,
    .evalCoord2f = true,
    .evalCoord2fv = true,
    .evalMesh1 = true,
    .evalPoint1 = true,
    .evalMesh2 = true,
    .evalPoint2 = true,
    .alphaFunc = true,
    .pixelZoom = true,
    .pixelTransferf = true,
    .pixelTransferi = true,
    .pixelMapfv = true,
    .pixelMapuiv = true,
    .pixelMapusv = true,
    .copyPixels = true,
    .drawPixels = true,
    .getClipPlane = true,
    .getLightfv = true,
    .getLightiv = true,
    .getMapdv = true,
    .getMapfv = true,
    .getMapiv = true,
    .getMaterialfv = true,
    .getMaterialiv = true,
    .getPixelMapfv = true,
    .getPixelMapuiv = true,
    .getPixelMapusv = true,
    .getPolygonStipple = true,
    .getTexEnvfv = true,
    .getTexEnviv = true,
    .getTexGendv = true,
    .getTexGenfv = true,
    .getTexGeniv = true,
    .isList = true,
    .frustum = true,
    .loadIdentity = true,
    .loadMatrixf = true,
    .loadMatrixd = true,
    .matrixMode = true,
    .multMatrixf = true,
    .multMatrixd = true,
    .ortho = true,
    .popMatrix = true,
    .pushMatrix = true,
    .rotated = true,
    .rotatef = true,
    .scaled = true,
    .scalef = true,
    .translated = true,
    .translatef = true,
    .drawArrays = true,
    .drawElements = true,
    .getPointerv = true,
    .polygonOffset = true,
    .copyTexImage1D = true,
    .copyTexImage2D = true,
    .copyTexSubImage1D = true,
    .copyTexSubImage2D = true,
    .texSubImage1D = true,
    .texSubImage2D = true,
    .bindTexture = true,
    .deleteTextures = true,
    .genTextures = true,
    .isTexture = true,
    .arrayElement = true,
    .colorPointer = true,
    .disableClientState = true,
    .edgeFlagPointer = true,
    .enableClientState = true,
    .indexPointer = true,
    .interleavedArrays = true,
    .normalPointer = true,
    .texCoordPointer = true,
    .vertexPointer = true,
    .areTexturesResident = true,
    .prioritizeTextures = true,
    .indexub = true,
    .indexubv = true,
    .popClientAttrib = true,
    .pushClientAttrib = true,
    .drawRangeElements = true,
    .texImage3D = true,
    .texSubImage3D = true,
    .copyTexSubImage3D = true,
    .activeTexture = true,
    .sampleCoverage = true,
    .compressedTexImage3D = true,
    .compressedTexImage2D = true,
    .compressedTexImage1D = true,
    .compressedTexSubImage3D = true,
    .compressedTexSubImage2D = true,
    .compressedTexSubImage1D = true,
    .getCompressedTexImage = true,
    .clientActiveTexture = true,
    .multiTexCoord1d = true,
    .multiTexCoord1dv = true,
    .multiTexCoord1f = true,
    .multiTexCoord1fv = true,
    .multiTexCoord1i = true,
    .multiTexCoord1iv = true,
    .multiTexCoord1s = true,
    .multiTexCoord1sv = true,
    .multiTexCoord2d = true,
    .multiTexCoord2dv = true,
    .multiTexCoord2f = true,
    .multiTexCoord2fv = true,
    .multiTexCoord2i = true,
    .multiTexCoord2iv = true,
    .multiTexCoord2s = true,
    .multiTexCoord2sv = true,
    .multiTexCoord3d = true,
    .multiTexCoord3dv = true,
    .multiTexCoord3f = true,
    .multiTexCoord3fv = true,
    .multiTexCoord3i = true,
    .multiTexCoord3iv = true,
    .multiTexCoord3s = true,
    .multiTexCoord3sv = true,
    .multiTexCoord4d = true,
    .multiTexCoord4dv = true,
    .multiTexCoord4f = true,
    .multiTexCoord4fv = true,
    .multiTexCoord4i = true,
    .multiTexCoord4iv = true,
    .multiTexCoord4s = true,
    .multiTexCoord4sv = true,
    .loadTransposeMatrixf = true,
    .loadTransposeMatrixd = true,
    .multTransposeMatrixf = true,
    .multTransposeMatrixd = true,
    .blendFuncSeparate = true,
    .multiDrawArrays = true,
    .multiDrawElements = true,
    .pointParameterf = true,
    .pointParameterfv = true,
    .pointParameteri = true,
    .pointParameteriv = true,
    .fogCoordf = true,
    .fogCoordfv = true,
    .fogCoordd = true,
    .fogCoorddv = true,
    .fogCoordPointer = true,
    .secondaryColor3b = true,
    .secondaryColor3bv = true,
    .secondaryColor3d = true,
    .secondaryColor3dv = true,
    .secondaryColor3f = true,
    .secondaryColor3fv = true,
    .secondaryColor3i = true,
    .secondaryColor3iv = true,
    .secondaryColor3s = true,
    .secondaryColor3sv = true,
    .secondaryColor3ub = true,
    .secondaryColor3ubv = true,
    .secondaryColor3ui = true,
    .secondaryColor3uiv = true,
    .secondaryColor3us = true,
    .secondaryColor3usv = true,
    .secondaryColorPointer = true,
    .windowPos2d = true,
    .windowPos2dv = true,
    .windowPos2f = true,
    .windowPos2fv = true,
    .windowPos2i = true,
    .windowPos2iv = true,
    .windowPos2s = true,
    .windowPos2sv = true,
    .windowPos3d = true,
    .windowPos3dv = true,
    .windowPos3f = true,
    .windowPos3fv = true,
    .windowPos3i = true,
    .windowPos3iv = true,
    .windowPos3s = true,
    .windowPos3sv = true,
    .blendColor = true,
    .blendEquation = true,
    .genQueries = true,
    .deleteQueries = true,
    .isQuery = true,
    .beginQuery = true,
    .endQuery = true,
    .getQueryiv = true,
    .getQueryObjectiv = true,
    .getQueryObjectuiv = true,
    .bindBuffer = true,
    .deleteBuffers = true,
    .genBuffers = true,
    .isBuffer = true,
    .bufferData = true,
    .bufferSubData = true,
    .getBufferSubData = true,
    .mapBuffer = true,
    .unmapBuffer = true,
    .getBufferParameteriv = true,
    .getBufferPointerv = true,
};

pub const gl20 = CommandFlags{
    .cullFace = true,
    .frontFace = true,
    .hint = true,
    .lineWidth = true,
    .pointSize = true,
    .polygonMode = true,
    .scissor = true,
    .texParameterf = true,
    .texParameterfv = true,
    .texParameteri = true,
    .texParameteriv = true,
    .texImage1D = true,
    .texImage2D = true,
    .drawBuffer = true,
    .clear = true,
    .clearColor = true,
    .clearStencil = true,
    .clearDepth = true,
    .stencilMask = true,
    .colorMask = true,
    .depthMask = true,
    .disable = true,
    .enable = true,
    .finish = true,
    .flush = true,
    .blendFunc = true,
    .logicOp = true,
    .stencilFunc = true,
    .stencilOp = true,
    .depthFunc = true,
    .pixelStoref = true,
    .pixelStorei = true,
    .readBuffer = true,
    .readPixels = true,
    .getBooleanv = true,
    .getDoublev = true,
    .getError = true,
    .getFloatv = true,
    .getIntegerv = true,
    .getString = true,
    .getTexImage = true,
    .getTexParameterfv = true,
    .getTexParameteriv = true,
    .getTexLevelParameterfv = true,
    .getTexLevelParameteriv = true,
    .isEnabled = true,
    .depthRange = true,
    .viewport = true,
    .newList = true,
    .endList = true,
    .callList = true,
    .callLists = true,
    .deleteLists = true,
    .genLists = true,
    .listBase = true,
    .begin = true,
    .bitmap = true,
    .color3b = true,
    .color3bv = true,
    .color3d = true,
    .color3dv = true,
    .color3f = true,
    .color3fv = true,
    .color3i = true,
    .color3iv = true,
    .color3s = true,
    .color3sv = true,
    .color3ub = true,
    .color3ubv = true,
    .color3ui = true,
    .color3uiv = true,
    .color3us = true,
    .color3usv = true,
    .color4b = true,
    .color4bv = true,
    .color4d = true,
    .color4dv = true,
    .color4f = true,
    .color4fv = true,
    .color4i = true,
    .color4iv = true,
    .color4s = true,
    .color4sv = true,
    .color4ub = true,
    .color4ubv = true,
    .color4ui = true,
    .color4uiv = true,
    .color4us = true,
    .color4usv = true,
    .edgeFlag = true,
    .edgeFlagv = true,
    .end = true,
    .indexd = true,
    .indexdv = true,
    .indexf = true,
    .indexfv = true,
    .indexi = true,
    .indexiv = true,
    .indexs = true,
    .indexsv = true,
    .normal3b = true,
    .normal3bv = true,
    .normal3d = true,
    .normal3dv = true,
    .normal3f = true,
    .normal3fv = true,
    .normal3i = true,
    .normal3iv = true,
    .normal3s = true,
    .normal3sv = true,
    .rasterPos2d = true,
    .rasterPos2dv = true,
    .rasterPos2f = true,
    .rasterPos2fv = true,
    .rasterPos2i = true,
    .rasterPos2iv = true,
    .rasterPos2s = true,
    .rasterPos2sv = true,
    .rasterPos3d = true,
    .rasterPos3dv = true,
    .rasterPos3f = true,
    .rasterPos3fv = true,
    .rasterPos3i = true,
    .rasterPos3iv = true,
    .rasterPos3s = true,
    .rasterPos3sv = true,
    .rasterPos4d = true,
    .rasterPos4dv = true,
    .rasterPos4f = true,
    .rasterPos4fv = true,
    .rasterPos4i = true,
    .rasterPos4iv = true,
    .rasterPos4s = true,
    .rasterPos4sv = true,
    .rectd = true,
    .rectdv = true,
    .rectf = true,
    .rectfv = true,
    .recti = true,
    .rectiv = true,
    .rects = true,
    .rectsv = true,
    .texCoord1d = true,
    .texCoord1dv = true,
    .texCoord1f = true,
    .texCoord1fv = true,
    .texCoord1i = true,
    .texCoord1iv = true,
    .texCoord1s = true,
    .texCoord1sv = true,
    .texCoord2d = true,
    .texCoord2dv = true,
    .texCoord2f = true,
    .texCoord2fv = true,
    .texCoord2i = true,
    .texCoord2iv = true,
    .texCoord2s = true,
    .texCoord2sv = true,
    .texCoord3d = true,
    .texCoord3dv = true,
    .texCoord3f = true,
    .texCoord3fv = true,
    .texCoord3i = true,
    .texCoord3iv = true,
    .texCoord3s = true,
    .texCoord3sv = true,
    .texCoord4d = true,
    .texCoord4dv = true,
    .texCoord4f = true,
    .texCoord4fv = true,
    .texCoord4i = true,
    .texCoord4iv = true,
    .texCoord4s = true,
    .texCoord4sv = true,
    .vertex2d = true,
    .vertex2dv = true,
    .vertex2f = true,
    .vertex2fv = true,
    .vertex2i = true,
    .vertex2iv = true,
    .vertex2s = true,
    .vertex2sv = true,
    .vertex3d = true,
    .vertex3dv = true,
    .vertex3f = true,
    .vertex3fv = true,
    .vertex3i = true,
    .vertex3iv = true,
    .vertex3s = true,
    .vertex3sv = true,
    .vertex4d = true,
    .vertex4dv = true,
    .vertex4f = true,
    .vertex4fv = true,
    .vertex4i = true,
    .vertex4iv = true,
    .vertex4s = true,
    .vertex4sv = true,
    .clipPlane = true,
    .colorMaterial = true,
    .fogf = true,
    .fogfv = true,
    .fogi = true,
    .fogiv = true,
    .lightf = true,
    .lightfv = true,
    .lighti = true,
    .lightiv = true,
    .lightModelf = true,
    .lightModelfv = true,
    .lightModeli = true,
    .lightModeliv = true,
    .lineStipple = true,
    .materialf = true,
    .materialfv = true,
    .materiali = true,
    .materialiv = true,
    .polygonStipple = true,
    .shadeModel = true,
    .texEnvf = true,
    .texEnvfv = true,
    .texEnvi = true,
    .texEnviv = true,
    .texGend = true,
    .texGendv = true,
    .texGenf = true,
    .texGenfv = true,
    .texGeni = true,
    .texGeniv = true,
    .feedbackBuffer = true,
    .selectBuffer = true,
    .renderMode = true,
    .initNames = true,
    .loadName = true,
    .passThrough = true,
    .popName = true,
    .pushName = true,
    .clearAccum = true,
    .clearIndex = true,
    .indexMask = true,
    .accum = true,
    .popAttrib = true,
    .pushAttrib = true,
    .map1d = true,
    .map1f = true,
    .map2d = true,
    .map2f = true,
    .mapGrid1d = true,
    .mapGrid1f = true,
    .mapGrid2d = true,
    .mapGrid2f = true,
    .evalCoord1d = true,
    .evalCoord1dv = true,
    .evalCoord1f = true,
    .evalCoord1fv = true,
    .evalCoord2d = true,
    .evalCoord2dv = true,
    .evalCoord2f = true,
    .evalCoord2fv = true,
    .evalMesh1 = true,
    .evalPoint1 = true,
    .evalMesh2 = true,
    .evalPoint2 = true,
    .alphaFunc = true,
    .pixelZoom = true,
    .pixelTransferf = true,
    .pixelTransferi = true,
    .pixelMapfv = true,
    .pixelMapuiv = true,
    .pixelMapusv = true,
    .copyPixels = true,
    .drawPixels = true,
    .getClipPlane = true,
    .getLightfv = true,
    .getLightiv = true,
    .getMapdv = true,
    .getMapfv = true,
    .getMapiv = true,
    .getMaterialfv = true,
    .getMaterialiv = true,
    .getPixelMapfv = true,
    .getPixelMapuiv = true,
    .getPixelMapusv = true,
    .getPolygonStipple = true,
    .getTexEnvfv = true,
    .getTexEnviv = true,
    .getTexGendv = true,
    .getTexGenfv = true,
    .getTexGeniv = true,
    .isList = true,
    .frustum = true,
    .loadIdentity = true,
    .loadMatrixf = true,
    .loadMatrixd = true,
    .matrixMode = true,
    .multMatrixf = true,
    .multMatrixd = true,
    .ortho = true,
    .popMatrix = true,
    .pushMatrix = true,
    .rotated = true,
    .rotatef = true,
    .scaled = true,
    .scalef = true,
    .translated = true,
    .translatef = true,
    .drawArrays = true,
    .drawElements = true,
    .getPointerv = true,
    .polygonOffset = true,
    .copyTexImage1D = true,
    .copyTexImage2D = true,
    .copyTexSubImage1D = true,
    .copyTexSubImage2D = true,
    .texSubImage1D = true,
    .texSubImage2D = true,
    .bindTexture = true,
    .deleteTextures = true,
    .genTextures = true,
    .isTexture = true,
    .arrayElement = true,
    .colorPointer = true,
    .disableClientState = true,
    .edgeFlagPointer = true,
    .enableClientState = true,
    .indexPointer = true,
    .interleavedArrays = true,
    .normalPointer = true,
    .texCoordPointer = true,
    .vertexPointer = true,
    .areTexturesResident = true,
    .prioritizeTextures = true,
    .indexub = true,
    .indexubv = true,
    .popClientAttrib = true,
    .pushClientAttrib = true,
    .drawRangeElements = true,
    .texImage3D = true,
    .texSubImage3D = true,
    .copyTexSubImage3D = true,
    .activeTexture = true,
    .sampleCoverage = true,
    .compressedTexImage3D = true,
    .compressedTexImage2D = true,
    .compressedTexImage1D = true,
    .compressedTexSubImage3D = true,
    .compressedTexSubImage2D = true,
    .compressedTexSubImage1D = true,
    .getCompressedTexImage = true,
    .clientActiveTexture = true,
    .multiTexCoord1d = true,
    .multiTexCoord1dv = true,
    .multiTexCoord1f = true,
    .multiTexCoord1fv = true,
    .multiTexCoord1i = true,
    .multiTexCoord1iv = true,
    .multiTexCoord1s = true,
    .multiTexCoord1sv = true,
    .multiTexCoord2d = true,
    .multiTexCoord2dv = true,
    .multiTexCoord2f = true,
    .multiTexCoord2fv = true,
    .multiTexCoord2i = true,
    .multiTexCoord2iv = true,
    .multiTexCoord2s = true,
    .multiTexCoord2sv = true,
    .multiTexCoord3d = true,
    .multiTexCoord3dv = true,
    .multiTexCoord3f = true,
    .multiTexCoord3fv = true,
    .multiTexCoord3i = true,
    .multiTexCoord3iv = true,
    .multiTexCoord3s = true,
    .multiTexCoord3sv = true,
    .multiTexCoord4d = true,
    .multiTexCoord4dv = true,
    .multiTexCoord4f = true,
    .multiTexCoord4fv = true,
    .multiTexCoord4i = true,
    .multiTexCoord4iv = true,
    .multiTexCoord4s = true,
    .multiTexCoord4sv = true,
    .loadTransposeMatrixf = true,
    .loadTransposeMatrixd = true,
    .multTransposeMatrixf = true,
    .multTransposeMatrixd = true,
    .blendFuncSeparate = true,
    .multiDrawArrays = true,
    .multiDrawElements = true,
    .pointParameterf = true,
    .pointParameterfv = true,
    .pointParameteri = true,
    .pointParameteriv = true,
    .fogCoordf = true,
    .fogCoordfv = true,
    .fogCoordd = true,
    .fogCoorddv = true,
    .fogCoordPointer = true,
    .secondaryColor3b = true,
    .secondaryColor3bv = true,
    .secondaryColor3d = true,
    .secondaryColor3dv = true,
    .secondaryColor3f = true,
    .secondaryColor3fv = true,
    .secondaryColor3i = true,
    .secondaryColor3iv = true,
    .secondaryColor3s = true,
    .secondaryColor3sv = true,
    .secondaryColor3ub = true,
    .secondaryColor3ubv = true,
    .secondaryColor3ui = true,
    .secondaryColor3uiv = true,
    .secondaryColor3us = true,
    .secondaryColor3usv = true,
    .secondaryColorPointer = true,
    .windowPos2d = true,
    .windowPos2dv = true,
    .windowPos2f = true,
    .windowPos2fv = true,
    .windowPos2i = true,
    .windowPos2iv = true,
    .windowPos2s = true,
    .windowPos2sv = true,
    .windowPos3d = true,
    .windowPos3dv = true,
    .windowPos3f = true,
    .windowPos3fv = true,
    .windowPos3i = true,
    .windowPos3iv = true,
    .windowPos3s = true,
    .windowPos3sv = true,
    .blendColor = true,
    .blendEquation = true,
    .genQueries = true,
    .deleteQueries = true,
    .isQuery = true,
    .beginQuery = true,
    .endQuery = true,
    .getQueryiv = true,
    .getQueryObjectiv = true,
    .getQueryObjectuiv = true,
    .bindBuffer = true,
    .deleteBuffers = true,
    .genBuffers = true,
    .isBuffer = true,
    .bufferData = true,
    .bufferSubData = true,
    .getBufferSubData = true,
    .mapBuffer = true,
    .unmapBuffer = true,
    .getBufferParameteriv = true,
    .getBufferPointerv = true,
    .blendEquationSeparate = true,
    .drawBuffers = true,
    .stencilOpSeparate = true,
    .stencilFuncSeparate = true,
    .stencilMaskSeparate = true,
    .attachShader = true,
    .bindAttribLocation = true,
    .compileShader = true,
    .createProgram = true,
    .createShader = true,
    .deleteProgram = true,
    .deleteShader = true,
    .detachShader = true,
    .disableVertexAttribArray = true,
    .enableVertexAttribArray = true,
    .getActiveAttrib = true,
    .getActiveUniform = true,
    .getAttachedShaders = true,
    .getAttribLocation = true,
    .getProgramiv = true,
    .getProgramInfoLog = true,
    .getShaderiv = true,
    .getShaderInfoLog = true,
    .getShaderSource = true,
    .getUniformLocation = true,
    .getUniformfv = true,
    .getUniformiv = true,
    .getVertexAttribdv = true,
    .getVertexAttribfv = true,
    .getVertexAttribiv = true,
    .getVertexAttribPointerv = true,
    .isProgram = true,
    .isShader = true,
    .linkProgram = true,
    .shaderSource = true,
    .useProgram = true,
    .uniform1f = true,
    .uniform2f = true,
    .uniform3f = true,
    .uniform4f = true,
    .uniform1i = true,
    .uniform2i = true,
    .uniform3i = true,
    .uniform4i = true,
    .uniform1fv = true,
    .uniform2fv = true,
    .uniform3fv = true,
    .uniform4fv = true,
    .uniform1iv = true,
    .uniform2iv = true,
    .uniform3iv = true,
    .uniform4iv = true,
    .uniformMatrix2fv = true,
    .uniformMatrix3fv = true,
    .uniformMatrix4fv = true,
    .validateProgram = true,
    .vertexAttrib1d = true,
    .vertexAttrib1dv = true,
    .vertexAttrib1f = true,
    .vertexAttrib1fv = true,
    .vertexAttrib1s = true,
    .vertexAttrib1sv = true,
    .vertexAttrib2d = true,
    .vertexAttrib2dv = true,
    .vertexAttrib2f = true,
    .vertexAttrib2fv = true,
    .vertexAttrib2s = true,
    .vertexAttrib2sv = true,
    .vertexAttrib3d = true,
    .vertexAttrib3dv = true,
    .vertexAttrib3f = true,
    .vertexAttrib3fv = true,
    .vertexAttrib3s = true,
    .vertexAttrib3sv = true,
    .vertexAttrib4Nbv = true,
    .vertexAttrib4Niv = true,
    .vertexAttrib4Nsv = true,
    .vertexAttrib4Nub = true,
    .vertexAttrib4Nubv = true,
    .vertexAttrib4Nuiv = true,
    .vertexAttrib4Nusv = true,
    .vertexAttrib4bv = true,
    .vertexAttrib4d = true,
    .vertexAttrib4dv = true,
    .vertexAttrib4f = true,
    .vertexAttrib4fv = true,
    .vertexAttrib4iv = true,
    .vertexAttrib4s = true,
    .vertexAttrib4sv = true,
    .vertexAttrib4ubv = true,
    .vertexAttrib4uiv = true,
    .vertexAttrib4usv = true,
    .vertexAttribPointer = true,
};

pub const gl21 = CommandFlags{
    .cullFace = true,
    .frontFace = true,
    .hint = true,
    .lineWidth = true,
    .pointSize = true,
    .polygonMode = true,
    .scissor = true,
    .texParameterf = true,
    .texParameterfv = true,
    .texParameteri = true,
    .texParameteriv = true,
    .texImage1D = true,
    .texImage2D = true,
    .drawBuffer = true,
    .clear = true,
    .clearColor = true,
    .clearStencil = true,
    .clearDepth = true,
    .stencilMask = true,
    .colorMask = true,
    .depthMask = true,
    .disable = true,
    .enable = true,
    .finish = true,
    .flush = true,
    .blendFunc = true,
    .logicOp = true,
    .stencilFunc = true,
    .stencilOp = true,
    .depthFunc = true,
    .pixelStoref = true,
    .pixelStorei = true,
    .readBuffer = true,
    .readPixels = true,
    .getBooleanv = true,
    .getDoublev = true,
    .getError = true,
    .getFloatv = true,
    .getIntegerv = true,
    .getString = true,
    .getTexImage = true,
    .getTexParameterfv = true,
    .getTexParameteriv = true,
    .getTexLevelParameterfv = true,
    .getTexLevelParameteriv = true,
    .isEnabled = true,
    .depthRange = true,
    .viewport = true,
    .newList = true,
    .endList = true,
    .callList = true,
    .callLists = true,
    .deleteLists = true,
    .genLists = true,
    .listBase = true,
    .begin = true,
    .bitmap = true,
    .color3b = true,
    .color3bv = true,
    .color3d = true,
    .color3dv = true,
    .color3f = true,
    .color3fv = true,
    .color3i = true,
    .color3iv = true,
    .color3s = true,
    .color3sv = true,
    .color3ub = true,
    .color3ubv = true,
    .color3ui = true,
    .color3uiv = true,
    .color3us = true,
    .color3usv = true,
    .color4b = true,
    .color4bv = true,
    .color4d = true,
    .color4dv = true,
    .color4f = true,
    .color4fv = true,
    .color4i = true,
    .color4iv = true,
    .color4s = true,
    .color4sv = true,
    .color4ub = true,
    .color4ubv = true,
    .color4ui = true,
    .color4uiv = true,
    .color4us = true,
    .color4usv = true,
    .edgeFlag = true,
    .edgeFlagv = true,
    .end = true,
    .indexd = true,
    .indexdv = true,
    .indexf = true,
    .indexfv = true,
    .indexi = true,
    .indexiv = true,
    .indexs = true,
    .indexsv = true,
    .normal3b = true,
    .normal3bv = true,
    .normal3d = true,
    .normal3dv = true,
    .normal3f = true,
    .normal3fv = true,
    .normal3i = true,
    .normal3iv = true,
    .normal3s = true,
    .normal3sv = true,
    .rasterPos2d = true,
    .rasterPos2dv = true,
    .rasterPos2f = true,
    .rasterPos2fv = true,
    .rasterPos2i = true,
    .rasterPos2iv = true,
    .rasterPos2s = true,
    .rasterPos2sv = true,
    .rasterPos3d = true,
    .rasterPos3dv = true,
    .rasterPos3f = true,
    .rasterPos3fv = true,
    .rasterPos3i = true,
    .rasterPos3iv = true,
    .rasterPos3s = true,
    .rasterPos3sv = true,
    .rasterPos4d = true,
    .rasterPos4dv = true,
    .rasterPos4f = true,
    .rasterPos4fv = true,
    .rasterPos4i = true,
    .rasterPos4iv = true,
    .rasterPos4s = true,
    .rasterPos4sv = true,
    .rectd = true,
    .rectdv = true,
    .rectf = true,
    .rectfv = true,
    .recti = true,
    .rectiv = true,
    .rects = true,
    .rectsv = true,
    .texCoord1d = true,
    .texCoord1dv = true,
    .texCoord1f = true,
    .texCoord1fv = true,
    .texCoord1i = true,
    .texCoord1iv = true,
    .texCoord1s = true,
    .texCoord1sv = true,
    .texCoord2d = true,
    .texCoord2dv = true,
    .texCoord2f = true,
    .texCoord2fv = true,
    .texCoord2i = true,
    .texCoord2iv = true,
    .texCoord2s = true,
    .texCoord2sv = true,
    .texCoord3d = true,
    .texCoord3dv = true,
    .texCoord3f = true,
    .texCoord3fv = true,
    .texCoord3i = true,
    .texCoord3iv = true,
    .texCoord3s = true,
    .texCoord3sv = true,
    .texCoord4d = true,
    .texCoord4dv = true,
    .texCoord4f = true,
    .texCoord4fv = true,
    .texCoord4i = true,
    .texCoord4iv = true,
    .texCoord4s = true,
    .texCoord4sv = true,
    .vertex2d = true,
    .vertex2dv = true,
    .vertex2f = true,
    .vertex2fv = true,
    .vertex2i = true,
    .vertex2iv = true,
    .vertex2s = true,
    .vertex2sv = true,
    .vertex3d = true,
    .vertex3dv = true,
    .vertex3f = true,
    .vertex3fv = true,
    .vertex3i = true,
    .vertex3iv = true,
    .vertex3s = true,
    .vertex3sv = true,
    .vertex4d = true,
    .vertex4dv = true,
    .vertex4f = true,
    .vertex4fv = true,
    .vertex4i = true,
    .vertex4iv = true,
    .vertex4s = true,
    .vertex4sv = true,
    .clipPlane = true,
    .colorMaterial = true,
    .fogf = true,
    .fogfv = true,
    .fogi = true,
    .fogiv = true,
    .lightf = true,
    .lightfv = true,
    .lighti = true,
    .lightiv = true,
    .lightModelf = true,
    .lightModelfv = true,
    .lightModeli = true,
    .lightModeliv = true,
    .lineStipple = true,
    .materialf = true,
    .materialfv = true,
    .materiali = true,
    .materialiv = true,
    .polygonStipple = true,
    .shadeModel = true,
    .texEnvf = true,
    .texEnvfv = true,
    .texEnvi = true,
    .texEnviv = true,
    .texGend = true,
    .texGendv = true,
    .texGenf = true,
    .texGenfv = true,
    .texGeni = true,
    .texGeniv = true,
    .feedbackBuffer = true,
    .selectBuffer = true,
    .renderMode = true,
    .initNames = true,
    .loadName = true,
    .passThrough = true,
    .popName = true,
    .pushName = true,
    .clearAccum = true,
    .clearIndex = true,
    .indexMask = true,
    .accum = true,
    .popAttrib = true,
    .pushAttrib = true,
    .map1d = true,
    .map1f = true,
    .map2d = true,
    .map2f = true,
    .mapGrid1d = true,
    .mapGrid1f = true,
    .mapGrid2d = true,
    .mapGrid2f = true,
    .evalCoord1d = true,
    .evalCoord1dv = true,
    .evalCoord1f = true,
    .evalCoord1fv = true,
    .evalCoord2d = true,
    .evalCoord2dv = true,
    .evalCoord2f = true,
    .evalCoord2fv = true,
    .evalMesh1 = true,
    .evalPoint1 = true,
    .evalMesh2 = true,
    .evalPoint2 = true,
    .alphaFunc = true,
    .pixelZoom = true,
    .pixelTransferf = true,
    .pixelTransferi = true,
    .pixelMapfv = true,
    .pixelMapuiv = true,
    .pixelMapusv = true,
    .copyPixels = true,
    .drawPixels = true,
    .getClipPlane = true,
    .getLightfv = true,
    .getLightiv = true,
    .getMapdv = true,
    .getMapfv = true,
    .getMapiv = true,
    .getMaterialfv = true,
    .getMaterialiv = true,
    .getPixelMapfv = true,
    .getPixelMapuiv = true,
    .getPixelMapusv = true,
    .getPolygonStipple = true,
    .getTexEnvfv = true,
    .getTexEnviv = true,
    .getTexGendv = true,
    .getTexGenfv = true,
    .getTexGeniv = true,
    .isList = true,
    .frustum = true,
    .loadIdentity = true,
    .loadMatrixf = true,
    .loadMatrixd = true,
    .matrixMode = true,
    .multMatrixf = true,
    .multMatrixd = true,
    .ortho = true,
    .popMatrix = true,
    .pushMatrix = true,
    .rotated = true,
    .rotatef = true,
    .scaled = true,
    .scalef = true,
    .translated = true,
    .translatef = true,
    .drawArrays = true,
    .drawElements = true,
    .getPointerv = true,
    .polygonOffset = true,
    .copyTexImage1D = true,
    .copyTexImage2D = true,
    .copyTexSubImage1D = true,
    .copyTexSubImage2D = true,
    .texSubImage1D = true,
    .texSubImage2D = true,
    .bindTexture = true,
    .deleteTextures = true,
    .genTextures = true,
    .isTexture = true,
    .arrayElement = true,
    .colorPointer = true,
    .disableClientState = true,
    .edgeFlagPointer = true,
    .enableClientState = true,
    .indexPointer = true,
    .interleavedArrays = true,
    .normalPointer = true,
    .texCoordPointer = true,
    .vertexPointer = true,
    .areTexturesResident = true,
    .prioritizeTextures = true,
    .indexub = true,
    .indexubv = true,
    .popClientAttrib = true,
    .pushClientAttrib = true,
    .drawRangeElements = true,
    .texImage3D = true,
    .texSubImage3D = true,
    .copyTexSubImage3D = true,
    .activeTexture = true,
    .sampleCoverage = true,
    .compressedTexImage3D = true,
    .compressedTexImage2D = true,
    .compressedTexImage1D = true,
    .compressedTexSubImage3D = true,
    .compressedTexSubImage2D = true,
    .compressedTexSubImage1D = true,
    .getCompressedTexImage = true,
    .clientActiveTexture = true,
    .multiTexCoord1d = true,
    .multiTexCoord1dv = true,
    .multiTexCoord1f = true,
    .multiTexCoord1fv = true,
    .multiTexCoord1i = true,
    .multiTexCoord1iv = true,
    .multiTexCoord1s = true,
    .multiTexCoord1sv = true,
    .multiTexCoord2d = true,
    .multiTexCoord2dv = true,
    .multiTexCoord2f = true,
    .multiTexCoord2fv = true,
    .multiTexCoord2i = true,
    .multiTexCoord2iv = true,
    .multiTexCoord2s = true,
    .multiTexCoord2sv = true,
    .multiTexCoord3d = true,
    .multiTexCoord3dv = true,
    .multiTexCoord3f = true,
    .multiTexCoord3fv = true,
    .multiTexCoord3i = true,
    .multiTexCoord3iv = true,
    .multiTexCoord3s = true,
    .multiTexCoord3sv = true,
    .multiTexCoord4d = true,
    .multiTexCoord4dv = true,
    .multiTexCoord4f = true,
    .multiTexCoord4fv = true,
    .multiTexCoord4i = true,
    .multiTexCoord4iv = true,
    .multiTexCoord4s = true,
    .multiTexCoord4sv = true,
    .loadTransposeMatrixf = true,
    .loadTransposeMatrixd = true,
    .multTransposeMatrixf = true,
    .multTransposeMatrixd = true,
    .blendFuncSeparate = true,
    .multiDrawArrays = true,
    .multiDrawElements = true,
    .pointParameterf = true,
    .pointParameterfv = true,
    .pointParameteri = true,
    .pointParameteriv = true,
    .fogCoordf = true,
    .fogCoordfv = true,
    .fogCoordd = true,
    .fogCoorddv = true,
    .fogCoordPointer = true,
    .secondaryColor3b = true,
    .secondaryColor3bv = true,
    .secondaryColor3d = true,
    .secondaryColor3dv = true,
    .secondaryColor3f = true,
    .secondaryColor3fv = true,
    .secondaryColor3i = true,
    .secondaryColor3iv = true,
    .secondaryColor3s = true,
    .secondaryColor3sv = true,
    .secondaryColor3ub = true,
    .secondaryColor3ubv = true,
    .secondaryColor3ui = true,
    .secondaryColor3uiv = true,
    .secondaryColor3us = true,
    .secondaryColor3usv = true,
    .secondaryColorPointer = true,
    .windowPos2d = true,
    .windowPos2dv = true,
    .windowPos2f = true,
    .windowPos2fv = true,
    .windowPos2i = true,
    .windowPos2iv = true,
    .windowPos2s = true,
    .windowPos2sv = true,
    .windowPos3d = true,
    .windowPos3dv = true,
    .windowPos3f = true,
    .windowPos3fv = true,
    .windowPos3i = true,
    .windowPos3iv = true,
    .windowPos3s = true,
    .windowPos3sv = true,
    .blendColor = true,
    .blendEquation = true,
    .genQueries = true,
    .deleteQueries = true,
    .isQuery = true,
    .beginQuery = true,
    .endQuery = true,
    .getQueryiv = true,
    .getQueryObjectiv = true,
    .getQueryObjectuiv = true,
    .bindBuffer = true,
    .deleteBuffers = true,
    .genBuffers = true,
    .isBuffer = true,
    .bufferData = true,
    .bufferSubData = true,
    .getBufferSubData = true,
    .mapBuffer = true,
    .unmapBuffer = true,
    .getBufferParameteriv = true,
    .getBufferPointerv = true,
    .blendEquationSeparate = true,
    .drawBuffers = true,
    .stencilOpSeparate = true,
    .stencilFuncSeparate = true,
    .stencilMaskSeparate = true,
    .attachShader = true,
    .bindAttribLocation = true,
    .compileShader = true,
    .createProgram = true,
    .createShader = true,
    .deleteProgram = true,
    .deleteShader = true,
    .detachShader = true,
    .disableVertexAttribArray = true,
    .enableVertexAttribArray = true,
    .getActiveAttrib = true,
    .getActiveUniform = true,
    .getAttachedShaders = true,
    .getAttribLocation = true,
    .getProgramiv = true,
    .getProgramInfoLog = true,
    .getShaderiv = true,
    .getShaderInfoLog = true,
    .getShaderSource = true,
    .getUniformLocation = true,
    .getUniformfv = true,
    .getUniformiv = true,
    .getVertexAttribdv = true,
    .getVertexAttribfv = true,
    .getVertexAttribiv = true,
    .getVertexAttribPointerv = true,
    .isProgram = true,
    .isShader = true,
    .linkProgram = true,
    .shaderSource = true,
    .useProgram = true,
    .uniform1f = true,
    .uniform2f = true,
    .uniform3f = true,
    .uniform4f = true,
    .uniform1i = true,
    .uniform2i = true,
    .uniform3i = true,
    .uniform4i = true,
    .uniform1fv = true,
    .uniform2fv = true,
    .uniform3fv = true,
    .uniform4fv = true,
    .uniform1iv = true,
    .uniform2iv = true,
    .uniform3iv = true,
    .uniform4iv = true,
    .uniformMatrix2fv = true,
    .uniformMatrix3fv = true,
    .uniformMatrix4fv = true,
    .validateProgram = true,
    .vertexAttrib1d = true,
    .vertexAttrib1dv = true,
    .vertexAttrib1f = true,
    .vertexAttrib1fv = true,
    .vertexAttrib1s = true,
    .vertexAttrib1sv = true,
    .vertexAttrib2d = true,
    .vertexAttrib2dv = true,
    .vertexAttrib2f = true,
    .vertexAttrib2fv = true,
    .vertexAttrib2s = true,
    .vertexAttrib2sv = true,
    .vertexAttrib3d = true,
    .vertexAttrib3dv = true,
    .vertexAttrib3f = true,
    .vertexAttrib3fv = true,
    .vertexAttrib3s = true,
    .vertexAttrib3sv = true,
    .vertexAttrib4Nbv = true,
    .vertexAttrib4Niv = true,
    .vertexAttrib4Nsv = true,
    .vertexAttrib4Nub = true,
    .vertexAttrib4Nubv = true,
    .vertexAttrib4Nuiv = true,
    .vertexAttrib4Nusv = true,
    .vertexAttrib4bv = true,
    .vertexAttrib4d = true,
    .vertexAttrib4dv = true,
    .vertexAttrib4f = true,
    .vertexAttrib4fv = true,
    .vertexAttrib4iv = true,
    .vertexAttrib4s = true,
    .vertexAttrib4sv = true,
    .vertexAttrib4ubv = true,
    .vertexAttrib4uiv = true,
    .vertexAttrib4usv = true,
    .vertexAttribPointer = true,
    .uniformMatrix2x3fv = true,
    .uniformMatrix3x2fv = true,
    .uniformMatrix2x4fv = true,
    .uniformMatrix4x2fv = true,
    .uniformMatrix3x4fv = true,
    .uniformMatrix4x3fv = true,
};

pub const gl30 = CommandFlags{
    .cullFace = true,
    .frontFace = true,
    .hint = true,
    .lineWidth = true,
    .pointSize = true,
    .polygonMode = true,
    .scissor = true,
    .texParameterf = true,
    .texParameterfv = true,
    .texParameteri = true,
    .texParameteriv = true,
    .texImage1D = true,
    .texImage2D = true,
    .drawBuffer = true,
    .clear = true,
    .clearColor = true,
    .clearStencil = true,
    .clearDepth = true,
    .stencilMask = true,
    .colorMask = true,
    .depthMask = true,
    .disable = true,
    .enable = true,
    .finish = true,
    .flush = true,
    .blendFunc = true,
    .logicOp = true,
    .stencilFunc = true,
    .stencilOp = true,
    .depthFunc = true,
    .pixelStoref = true,
    .pixelStorei = true,
    .readBuffer = true,
    .readPixels = true,
    .getBooleanv = true,
    .getDoublev = true,
    .getError = true,
    .getFloatv = true,
    .getIntegerv = true,
    .getString = true,
    .getTexImage = true,
    .getTexParameterfv = true,
    .getTexParameteriv = true,
    .getTexLevelParameterfv = true,
    .getTexLevelParameteriv = true,
    .isEnabled = true,
    .depthRange = true,
    .viewport = true,
    .newList = true,
    .endList = true,
    .callList = true,
    .callLists = true,
    .deleteLists = true,
    .genLists = true,
    .listBase = true,
    .begin = true,
    .bitmap = true,
    .color3b = true,
    .color3bv = true,
    .color3d = true,
    .color3dv = true,
    .color3f = true,
    .color3fv = true,
    .color3i = true,
    .color3iv = true,
    .color3s = true,
    .color3sv = true,
    .color3ub = true,
    .color3ubv = true,
    .color3ui = true,
    .color3uiv = true,
    .color3us = true,
    .color3usv = true,
    .color4b = true,
    .color4bv = true,
    .color4d = true,
    .color4dv = true,
    .color4f = true,
    .color4fv = true,
    .color4i = true,
    .color4iv = true,
    .color4s = true,
    .color4sv = true,
    .color4ub = true,
    .color4ubv = true,
    .color4ui = true,
    .color4uiv = true,
    .color4us = true,
    .color4usv = true,
    .edgeFlag = true,
    .edgeFlagv = true,
    .end = true,
    .indexd = true,
    .indexdv = true,
    .indexf = true,
    .indexfv = true,
    .indexi = true,
    .indexiv = true,
    .indexs = true,
    .indexsv = true,
    .normal3b = true,
    .normal3bv = true,
    .normal3d = true,
    .normal3dv = true,
    .normal3f = true,
    .normal3fv = true,
    .normal3i = true,
    .normal3iv = true,
    .normal3s = true,
    .normal3sv = true,
    .rasterPos2d = true,
    .rasterPos2dv = true,
    .rasterPos2f = true,
    .rasterPos2fv = true,
    .rasterPos2i = true,
    .rasterPos2iv = true,
    .rasterPos2s = true,
    .rasterPos2sv = true,
    .rasterPos3d = true,
    .rasterPos3dv = true,
    .rasterPos3f = true,
    .rasterPos3fv = true,
    .rasterPos3i = true,
    .rasterPos3iv = true,
    .rasterPos3s = true,
    .rasterPos3sv = true,
    .rasterPos4d = true,
    .rasterPos4dv = true,
    .rasterPos4f = true,
    .rasterPos4fv = true,
    .rasterPos4i = true,
    .rasterPos4iv = true,
    .rasterPos4s = true,
    .rasterPos4sv = true,
    .rectd = true,
    .rectdv = true,
    .rectf = true,
    .rectfv = true,
    .recti = true,
    .rectiv = true,
    .rects = true,
    .rectsv = true,
    .texCoord1d = true,
    .texCoord1dv = true,
    .texCoord1f = true,
    .texCoord1fv = true,
    .texCoord1i = true,
    .texCoord1iv = true,
    .texCoord1s = true,
    .texCoord1sv = true,
    .texCoord2d = true,
    .texCoord2dv = true,
    .texCoord2f = true,
    .texCoord2fv = true,
    .texCoord2i = true,
    .texCoord2iv = true,
    .texCoord2s = true,
    .texCoord2sv = true,
    .texCoord3d = true,
    .texCoord3dv = true,
    .texCoord3f = true,
    .texCoord3fv = true,
    .texCoord3i = true,
    .texCoord3iv = true,
    .texCoord3s = true,
    .texCoord3sv = true,
    .texCoord4d = true,
    .texCoord4dv = true,
    .texCoord4f = true,
    .texCoord4fv = true,
    .texCoord4i = true,
    .texCoord4iv = true,
    .texCoord4s = true,
    .texCoord4sv = true,
    .vertex2d = true,
    .vertex2dv = true,
    .vertex2f = true,
    .vertex2fv = true,
    .vertex2i = true,
    .vertex2iv = true,
    .vertex2s = true,
    .vertex2sv = true,
    .vertex3d = true,
    .vertex3dv = true,
    .vertex3f = true,
    .vertex3fv = true,
    .vertex3i = true,
    .vertex3iv = true,
    .vertex3s = true,
    .vertex3sv = true,
    .vertex4d = true,
    .vertex4dv = true,
    .vertex4f = true,
    .vertex4fv = true,
    .vertex4i = true,
    .vertex4iv = true,
    .vertex4s = true,
    .vertex4sv = true,
    .clipPlane = true,
    .colorMaterial = true,
    .fogf = true,
    .fogfv = true,
    .fogi = true,
    .fogiv = true,
    .lightf = true,
    .lightfv = true,
    .lighti = true,
    .lightiv = true,
    .lightModelf = true,
    .lightModelfv = true,
    .lightModeli = true,
    .lightModeliv = true,
    .lineStipple = true,
    .materialf = true,
    .materialfv = true,
    .materiali = true,
    .materialiv = true,
    .polygonStipple = true,
    .shadeModel = true,
    .texEnvf = true,
    .texEnvfv = true,
    .texEnvi = true,
    .texEnviv = true,
    .texGend = true,
    .texGendv = true,
    .texGenf = true,
    .texGenfv = true,
    .texGeni = true,
    .texGeniv = true,
    .feedbackBuffer = true,
    .selectBuffer = true,
    .renderMode = true,
    .initNames = true,
    .loadName = true,
    .passThrough = true,
    .popName = true,
    .pushName = true,
    .clearAccum = true,
    .clearIndex = true,
    .indexMask = true,
    .accum = true,
    .popAttrib = true,
    .pushAttrib = true,
    .map1d = true,
    .map1f = true,
    .map2d = true,
    .map2f = true,
    .mapGrid1d = true,
    .mapGrid1f = true,
    .mapGrid2d = true,
    .mapGrid2f = true,
    .evalCoord1d = true,
    .evalCoord1dv = true,
    .evalCoord1f = true,
    .evalCoord1fv = true,
    .evalCoord2d = true,
    .evalCoord2dv = true,
    .evalCoord2f = true,
    .evalCoord2fv = true,
    .evalMesh1 = true,
    .evalPoint1 = true,
    .evalMesh2 = true,
    .evalPoint2 = true,
    .alphaFunc = true,
    .pixelZoom = true,
    .pixelTransferf = true,
    .pixelTransferi = true,
    .pixelMapfv = true,
    .pixelMapuiv = true,
    .pixelMapusv = true,
    .copyPixels = true,
    .drawPixels = true,
    .getClipPlane = true,
    .getLightfv = true,
    .getLightiv = true,
    .getMapdv = true,
    .getMapfv = true,
    .getMapiv = true,
    .getMaterialfv = true,
    .getMaterialiv = true,
    .getPixelMapfv = true,
    .getPixelMapuiv = true,
    .getPixelMapusv = true,
    .getPolygonStipple = true,
    .getTexEnvfv = true,
    .getTexEnviv = true,
    .getTexGendv = true,
    .getTexGenfv = true,
    .getTexGeniv = true,
    .isList = true,
    .frustum = true,
    .loadIdentity = true,
    .loadMatrixf = true,
    .loadMatrixd = true,
    .matrixMode = true,
    .multMatrixf = true,
    .multMatrixd = true,
    .ortho = true,
    .popMatrix = true,
    .pushMatrix = true,
    .rotated = true,
    .rotatef = true,
    .scaled = true,
    .scalef = true,
    .translated = true,
    .translatef = true,
    .drawArrays = true,
    .drawElements = true,
    .getPointerv = true,
    .polygonOffset = true,
    .copyTexImage1D = true,
    .copyTexImage2D = true,
    .copyTexSubImage1D = true,
    .copyTexSubImage2D = true,
    .texSubImage1D = true,
    .texSubImage2D = true,
    .bindTexture = true,
    .deleteTextures = true,
    .genTextures = true,
    .isTexture = true,
    .arrayElement = true,
    .colorPointer = true,
    .disableClientState = true,
    .edgeFlagPointer = true,
    .enableClientState = true,
    .indexPointer = true,
    .interleavedArrays = true,
    .normalPointer = true,
    .texCoordPointer = true,
    .vertexPointer = true,
    .areTexturesResident = true,
    .prioritizeTextures = true,
    .indexub = true,
    .indexubv = true,
    .popClientAttrib = true,
    .pushClientAttrib = true,
    .drawRangeElements = true,
    .texImage3D = true,
    .texSubImage3D = true,
    .copyTexSubImage3D = true,
    .activeTexture = true,
    .sampleCoverage = true,
    .compressedTexImage3D = true,
    .compressedTexImage2D = true,
    .compressedTexImage1D = true,
    .compressedTexSubImage3D = true,
    .compressedTexSubImage2D = true,
    .compressedTexSubImage1D = true,
    .getCompressedTexImage = true,
    .clientActiveTexture = true,
    .multiTexCoord1d = true,
    .multiTexCoord1dv = true,
    .multiTexCoord1f = true,
    .multiTexCoord1fv = true,
    .multiTexCoord1i = true,
    .multiTexCoord1iv = true,
    .multiTexCoord1s = true,
    .multiTexCoord1sv = true,
    .multiTexCoord2d = true,
    .multiTexCoord2dv = true,
    .multiTexCoord2f = true,
    .multiTexCoord2fv = true,
    .multiTexCoord2i = true,
    .multiTexCoord2iv = true,
    .multiTexCoord2s = true,
    .multiTexCoord2sv = true,
    .multiTexCoord3d = true,
    .multiTexCoord3dv = true,
    .multiTexCoord3f = true,
    .multiTexCoord3fv = true,
    .multiTexCoord3i = true,
    .multiTexCoord3iv = true,
    .multiTexCoord3s = true,
    .multiTexCoord3sv = true,
    .multiTexCoord4d = true,
    .multiTexCoord4dv = true,
    .multiTexCoord4f = true,
    .multiTexCoord4fv = true,
    .multiTexCoord4i = true,
    .multiTexCoord4iv = true,
    .multiTexCoord4s = true,
    .multiTexCoord4sv = true,
    .loadTransposeMatrixf = true,
    .loadTransposeMatrixd = true,
    .multTransposeMatrixf = true,
    .multTransposeMatrixd = true,
    .blendFuncSeparate = true,
    .multiDrawArrays = true,
    .multiDrawElements = true,
    .pointParameterf = true,
    .pointParameterfv = true,
    .pointParameteri = true,
    .pointParameteriv = true,
    .fogCoordf = true,
    .fogCoordfv = true,
    .fogCoordd = true,
    .fogCoorddv = true,
    .fogCoordPointer = true,
    .secondaryColor3b = true,
    .secondaryColor3bv = true,
    .secondaryColor3d = true,
    .secondaryColor3dv = true,
    .secondaryColor3f = true,
    .secondaryColor3fv = true,
    .secondaryColor3i = true,
    .secondaryColor3iv = true,
    .secondaryColor3s = true,
    .secondaryColor3sv = true,
    .secondaryColor3ub = true,
    .secondaryColor3ubv = true,
    .secondaryColor3ui = true,
    .secondaryColor3uiv = true,
    .secondaryColor3us = true,
    .secondaryColor3usv = true,
    .secondaryColorPointer = true,
    .windowPos2d = true,
    .windowPos2dv = true,
    .windowPos2f = true,
    .windowPos2fv = true,
    .windowPos2i = true,
    .windowPos2iv = true,
    .windowPos2s = true,
    .windowPos2sv = true,
    .windowPos3d = true,
    .windowPos3dv = true,
    .windowPos3f = true,
    .windowPos3fv = true,
    .windowPos3i = true,
    .windowPos3iv = true,
    .windowPos3s = true,
    .windowPos3sv = true,
    .blendColor = true,
    .blendEquation = true,
    .genQueries = true,
    .deleteQueries = true,
    .isQuery = true,
    .beginQuery = true,
    .endQuery = true,
    .getQueryiv = true,
    .getQueryObjectiv = true,
    .getQueryObjectuiv = true,
    .bindBuffer = true,
    .deleteBuffers = true,
    .genBuffers = true,
    .isBuffer = true,
    .bufferData = true,
    .bufferSubData = true,
    .getBufferSubData = true,
    .mapBuffer = true,
    .unmapBuffer = true,
    .getBufferParameteriv = true,
    .getBufferPointerv = true,
    .blendEquationSeparate = true,
    .drawBuffers = true,
    .stencilOpSeparate = true,
    .stencilFuncSeparate = true,
    .stencilMaskSeparate = true,
    .attachShader = true,
    .bindAttribLocation = true,
    .compileShader = true,
    .createProgram = true,
    .createShader = true,
    .deleteProgram = true,
    .deleteShader = true,
    .detachShader = true,
    .disableVertexAttribArray = true,
    .enableVertexAttribArray = true,
    .getActiveAttrib = true,
    .getActiveUniform = true,
    .getAttachedShaders = true,
    .getAttribLocation = true,
    .getProgramiv = true,
    .getProgramInfoLog = true,
    .getShaderiv = true,
    .getShaderInfoLog = true,
    .getShaderSource = true,
    .getUniformLocation = true,
    .getUniformfv = true,
    .getUniformiv = true,
    .getVertexAttribdv = true,
    .getVertexAttribfv = true,
    .getVertexAttribiv = true,
    .getVertexAttribPointerv = true,
    .isProgram = true,
    .isShader = true,
    .linkProgram = true,
    .shaderSource = true,
    .useProgram = true,
    .uniform1f = true,
    .uniform2f = true,
    .uniform3f = true,
    .uniform4f = true,
    .uniform1i = true,
    .uniform2i = true,
    .uniform3i = true,
    .uniform4i = true,
    .uniform1fv = true,
    .uniform2fv = true,
    .uniform3fv = true,
    .uniform4fv = true,
    .uniform1iv = true,
    .uniform2iv = true,
    .uniform3iv = true,
    .uniform4iv = true,
    .uniformMatrix2fv = true,
    .uniformMatrix3fv = true,
    .uniformMatrix4fv = true,
    .validateProgram = true,
    .vertexAttrib1d = true,
    .vertexAttrib1dv = true,
    .vertexAttrib1f = true,
    .vertexAttrib1fv = true,
    .vertexAttrib1s = true,
    .vertexAttrib1sv = true,
    .vertexAttrib2d = true,
    .vertexAttrib2dv = true,
    .vertexAttrib2f = true,
    .vertexAttrib2fv = true,
    .vertexAttrib2s = true,
    .vertexAttrib2sv = true,
    .vertexAttrib3d = true,
    .vertexAttrib3dv = true,
    .vertexAttrib3f = true,
    .vertexAttrib3fv = true,
    .vertexAttrib3s = true,
    .vertexAttrib3sv = true,
    .vertexAttrib4Nbv = true,
    .vertexAttrib4Niv = true,
    .vertexAttrib4Nsv = true,
    .vertexAttrib4Nub = true,
    .vertexAttrib4Nubv = true,
    .vertexAttrib4Nuiv = true,
    .vertexAttrib4Nusv = true,
    .vertexAttrib4bv = true,
    .vertexAttrib4d = true,
    .vertexAttrib4dv = true,
    .vertexAttrib4f = true,
    .vertexAttrib4fv = true,
    .vertexAttrib4iv = true,
    .vertexAttrib4s = true,
    .vertexAttrib4sv = true,
    .vertexAttrib4ubv = true,
    .vertexAttrib4uiv = true,
    .vertexAttrib4usv = true,
    .vertexAttribPointer = true,
    .uniformMatrix2x3fv = true,
    .uniformMatrix3x2fv = true,
    .uniformMatrix2x4fv = true,
    .uniformMatrix4x2fv = true,
    .uniformMatrix3x4fv = true,
    .uniformMatrix4x3fv = true,
    .colorMaski = true,
    .getBooleani_v = true,
    .getIntegeri_v = true,
    .enablei = true,
    .disablei = true,
    .isEnabledi = true,
    .beginTransformFeedback = true,
    .endTransformFeedback = true,
    .bindBufferRange = true,
    .bindBufferBase = true,
    .transformFeedbackVaryings = true,
    .getTransformFeedbackVarying = true,
    .clampColor = true,
    .beginConditionalRender = true,
    .endConditionalRender = true,
    .vertexAttribIPointer = true,
    .getVertexAttribIiv = true,
    .getVertexAttribIuiv = true,
    .vertexAttribI1i = true,
    .vertexAttribI2i = true,
    .vertexAttribI3i = true,
    .vertexAttribI4i = true,
    .vertexAttribI1ui = true,
    .vertexAttribI2ui = true,
    .vertexAttribI3ui = true,
    .vertexAttribI4ui = true,
    .vertexAttribI1iv = true,
    .vertexAttribI2iv = true,
    .vertexAttribI3iv = true,
    .vertexAttribI4iv = true,
    .vertexAttribI1uiv = true,
    .vertexAttribI2uiv = true,
    .vertexAttribI3uiv = true,
    .vertexAttribI4uiv = true,
    .vertexAttribI4bv = true,
    .vertexAttribI4sv = true,
    .vertexAttribI4ubv = true,
    .vertexAttribI4usv = true,
    .getUniformuiv = true,
    .bindFragDataLocation = true,
    .getFragDataLocation = true,
    .uniform1ui = true,
    .uniform2ui = true,
    .uniform3ui = true,
    .uniform4ui = true,
    .uniform1uiv = true,
    .uniform2uiv = true,
    .uniform3uiv = true,
    .uniform4uiv = true,
    .texParameterIiv = true,
    .texParameterIuiv = true,
    .getTexParameterIiv = true,
    .getTexParameterIuiv = true,
    .clearBufferiv = true,
    .clearBufferuiv = true,
    .clearBufferfv = true,
    .clearBufferfi = true,
    .getStringi = true,
    .isRenderbuffer = true,
    .bindRenderbuffer = true,
    .deleteRenderbuffers = true,
    .genRenderbuffers = true,
    .renderbufferStorage = true,
    .getRenderbufferParameteriv = true,
    .isFramebuffer = true,
    .bindFramebuffer = true,
    .deleteFramebuffers = true,
    .genFramebuffers = true,
    .checkFramebufferStatus = true,
    .framebufferTexture1D = true,
    .framebufferTexture2D = true,
    .framebufferTexture3D = true,
    .framebufferRenderbuffer = true,
    .getFramebufferAttachmentParameteriv = true,
    .generateMipmap = true,
    .blitFramebuffer = true,
    .renderbufferStorageMultisample = true,
    .framebufferTextureLayer = true,
    .mapBufferRange = true,
    .flushMappedBufferRange = true,
    .bindVertexArray = true,
    .deleteVertexArrays = true,
    .genVertexArrays = true,
    .isVertexArray = true,
};

pub const gl31 = CommandFlags{
    .cullFace = true,
    .frontFace = true,
    .hint = true,
    .lineWidth = true,
    .pointSize = true,
    .polygonMode = true,
    .scissor = true,
    .texParameterf = true,
    .texParameterfv = true,
    .texParameteri = true,
    .texParameteriv = true,
    .texImage1D = true,
    .texImage2D = true,
    .drawBuffer = true,
    .clear = true,
    .clearColor = true,
    .clearStencil = true,
    .clearDepth = true,
    .stencilMask = true,
    .colorMask = true,
    .depthMask = true,
    .disable = true,
    .enable = true,
    .finish = true,
    .flush = true,
    .blendFunc = true,
    .logicOp = true,
    .stencilFunc = true,
    .stencilOp = true,
    .depthFunc = true,
    .pixelStoref = true,
    .pixelStorei = true,
    .readBuffer = true,
    .readPixels = true,
    .getBooleanv = true,
    .getDoublev = true,
    .getError = true,
    .getFloatv = true,
    .getIntegerv = true,
    .getString = true,
    .getTexImage = true,
    .getTexParameterfv = true,
    .getTexParameteriv = true,
    .getTexLevelParameterfv = true,
    .getTexLevelParameteriv = true,
    .isEnabled = true,
    .depthRange = true,
    .viewport = true,
    .newList = true,
    .endList = true,
    .callList = true,
    .callLists = true,
    .deleteLists = true,
    .genLists = true,
    .listBase = true,
    .begin = true,
    .bitmap = true,
    .color3b = true,
    .color3bv = true,
    .color3d = true,
    .color3dv = true,
    .color3f = true,
    .color3fv = true,
    .color3i = true,
    .color3iv = true,
    .color3s = true,
    .color3sv = true,
    .color3ub = true,
    .color3ubv = true,
    .color3ui = true,
    .color3uiv = true,
    .color3us = true,
    .color3usv = true,
    .color4b = true,
    .color4bv = true,
    .color4d = true,
    .color4dv = true,
    .color4f = true,
    .color4fv = true,
    .color4i = true,
    .color4iv = true,
    .color4s = true,
    .color4sv = true,
    .color4ub = true,
    .color4ubv = true,
    .color4ui = true,
    .color4uiv = true,
    .color4us = true,
    .color4usv = true,
    .edgeFlag = true,
    .edgeFlagv = true,
    .end = true,
    .indexd = true,
    .indexdv = true,
    .indexf = true,
    .indexfv = true,
    .indexi = true,
    .indexiv = true,
    .indexs = true,
    .indexsv = true,
    .normal3b = true,
    .normal3bv = true,
    .normal3d = true,
    .normal3dv = true,
    .normal3f = true,
    .normal3fv = true,
    .normal3i = true,
    .normal3iv = true,
    .normal3s = true,
    .normal3sv = true,
    .rasterPos2d = true,
    .rasterPos2dv = true,
    .rasterPos2f = true,
    .rasterPos2fv = true,
    .rasterPos2i = true,
    .rasterPos2iv = true,
    .rasterPos2s = true,
    .rasterPos2sv = true,
    .rasterPos3d = true,
    .rasterPos3dv = true,
    .rasterPos3f = true,
    .rasterPos3fv = true,
    .rasterPos3i = true,
    .rasterPos3iv = true,
    .rasterPos3s = true,
    .rasterPos3sv = true,
    .rasterPos4d = true,
    .rasterPos4dv = true,
    .rasterPos4f = true,
    .rasterPos4fv = true,
    .rasterPos4i = true,
    .rasterPos4iv = true,
    .rasterPos4s = true,
    .rasterPos4sv = true,
    .rectd = true,
    .rectdv = true,
    .rectf = true,
    .rectfv = true,
    .recti = true,
    .rectiv = true,
    .rects = true,
    .rectsv = true,
    .texCoord1d = true,
    .texCoord1dv = true,
    .texCoord1f = true,
    .texCoord1fv = true,
    .texCoord1i = true,
    .texCoord1iv = true,
    .texCoord1s = true,
    .texCoord1sv = true,
    .texCoord2d = true,
    .texCoord2dv = true,
    .texCoord2f = true,
    .texCoord2fv = true,
    .texCoord2i = true,
    .texCoord2iv = true,
    .texCoord2s = true,
    .texCoord2sv = true,
    .texCoord3d = true,
    .texCoord3dv = true,
    .texCoord3f = true,
    .texCoord3fv = true,
    .texCoord3i = true,
    .texCoord3iv = true,
    .texCoord3s = true,
    .texCoord3sv = true,
    .texCoord4d = true,
    .texCoord4dv = true,
    .texCoord4f = true,
    .texCoord4fv = true,
    .texCoord4i = true,
    .texCoord4iv = true,
    .texCoord4s = true,
    .texCoord4sv = true,
    .vertex2d = true,
    .vertex2dv = true,
    .vertex2f = true,
    .vertex2fv = true,
    .vertex2i = true,
    .vertex2iv = true,
    .vertex2s = true,
    .vertex2sv = true,
    .vertex3d = true,
    .vertex3dv = true,
    .vertex3f = true,
    .vertex3fv = true,
    .vertex3i = true,
    .vertex3iv = true,
    .vertex3s = true,
    .vertex3sv = true,
    .vertex4d = true,
    .vertex4dv = true,
    .vertex4f = true,
    .vertex4fv = true,
    .vertex4i = true,
    .vertex4iv = true,
    .vertex4s = true,
    .vertex4sv = true,
    .clipPlane = true,
    .colorMaterial = true,
    .fogf = true,
    .fogfv = true,
    .fogi = true,
    .fogiv = true,
    .lightf = true,
    .lightfv = true,
    .lighti = true,
    .lightiv = true,
    .lightModelf = true,
    .lightModelfv = true,
    .lightModeli = true,
    .lightModeliv = true,
    .lineStipple = true,
    .materialf = true,
    .materialfv = true,
    .materiali = true,
    .materialiv = true,
    .polygonStipple = true,
    .shadeModel = true,
    .texEnvf = true,
    .texEnvfv = true,
    .texEnvi = true,
    .texEnviv = true,
    .texGend = true,
    .texGendv = true,
    .texGenf = true,
    .texGenfv = true,
    .texGeni = true,
    .texGeniv = true,
    .feedbackBuffer = true,
    .selectBuffer = true,
    .renderMode = true,
    .initNames = true,
    .loadName = true,
    .passThrough = true,
    .popName = true,
    .pushName = true,
    .clearAccum = true,
    .clearIndex = true,
    .indexMask = true,
    .accum = true,
    .popAttrib = true,
    .pushAttrib = true,
    .map1d = true,
    .map1f = true,
    .map2d = true,
    .map2f = true,
    .mapGrid1d = true,
    .mapGrid1f = true,
    .mapGrid2d = true,
    .mapGrid2f = true,
    .evalCoord1d = true,
    .evalCoord1dv = true,
    .evalCoord1f = true,
    .evalCoord1fv = true,
    .evalCoord2d = true,
    .evalCoord2dv = true,
    .evalCoord2f = true,
    .evalCoord2fv = true,
    .evalMesh1 = true,
    .evalPoint1 = true,
    .evalMesh2 = true,
    .evalPoint2 = true,
    .alphaFunc = true,
    .pixelZoom = true,
    .pixelTransferf = true,
    .pixelTransferi = true,
    .pixelMapfv = true,
    .pixelMapuiv = true,
    .pixelMapusv = true,
    .copyPixels = true,
    .drawPixels = true,
    .getClipPlane = true,
    .getLightfv = true,
    .getLightiv = true,
    .getMapdv = true,
    .getMapfv = true,
    .getMapiv = true,
    .getMaterialfv = true,
    .getMaterialiv = true,
    .getPixelMapfv = true,
    .getPixelMapuiv = true,
    .getPixelMapusv = true,
    .getPolygonStipple = true,
    .getTexEnvfv = true,
    .getTexEnviv = true,
    .getTexGendv = true,
    .getTexGenfv = true,
    .getTexGeniv = true,
    .isList = true,
    .frustum = true,
    .loadIdentity = true,
    .loadMatrixf = true,
    .loadMatrixd = true,
    .matrixMode = true,
    .multMatrixf = true,
    .multMatrixd = true,
    .ortho = true,
    .popMatrix = true,
    .pushMatrix = true,
    .rotated = true,
    .rotatef = true,
    .scaled = true,
    .scalef = true,
    .translated = true,
    .translatef = true,
    .drawArrays = true,
    .drawElements = true,
    .getPointerv = true,
    .polygonOffset = true,
    .copyTexImage1D = true,
    .copyTexImage2D = true,
    .copyTexSubImage1D = true,
    .copyTexSubImage2D = true,
    .texSubImage1D = true,
    .texSubImage2D = true,
    .bindTexture = true,
    .deleteTextures = true,
    .genTextures = true,
    .isTexture = true,
    .arrayElement = true,
    .colorPointer = true,
    .disableClientState = true,
    .edgeFlagPointer = true,
    .enableClientState = true,
    .indexPointer = true,
    .interleavedArrays = true,
    .normalPointer = true,
    .texCoordPointer = true,
    .vertexPointer = true,
    .areTexturesResident = true,
    .prioritizeTextures = true,
    .indexub = true,
    .indexubv = true,
    .popClientAttrib = true,
    .pushClientAttrib = true,
    .drawRangeElements = true,
    .texImage3D = true,
    .texSubImage3D = true,
    .copyTexSubImage3D = true,
    .activeTexture = true,
    .sampleCoverage = true,
    .compressedTexImage3D = true,
    .compressedTexImage2D = true,
    .compressedTexImage1D = true,
    .compressedTexSubImage3D = true,
    .compressedTexSubImage2D = true,
    .compressedTexSubImage1D = true,
    .getCompressedTexImage = true,
    .clientActiveTexture = true,
    .multiTexCoord1d = true,
    .multiTexCoord1dv = true,
    .multiTexCoord1f = true,
    .multiTexCoord1fv = true,
    .multiTexCoord1i = true,
    .multiTexCoord1iv = true,
    .multiTexCoord1s = true,
    .multiTexCoord1sv = true,
    .multiTexCoord2d = true,
    .multiTexCoord2dv = true,
    .multiTexCoord2f = true,
    .multiTexCoord2fv = true,
    .multiTexCoord2i = true,
    .multiTexCoord2iv = true,
    .multiTexCoord2s = true,
    .multiTexCoord2sv = true,
    .multiTexCoord3d = true,
    .multiTexCoord3dv = true,
    .multiTexCoord3f = true,
    .multiTexCoord3fv = true,
    .multiTexCoord3i = true,
    .multiTexCoord3iv = true,
    .multiTexCoord3s = true,
    .multiTexCoord3sv = true,
    .multiTexCoord4d = true,
    .multiTexCoord4dv = true,
    .multiTexCoord4f = true,
    .multiTexCoord4fv = true,
    .multiTexCoord4i = true,
    .multiTexCoord4iv = true,
    .multiTexCoord4s = true,
    .multiTexCoord4sv = true,
    .loadTransposeMatrixf = true,
    .loadTransposeMatrixd = true,
    .multTransposeMatrixf = true,
    .multTransposeMatrixd = true,
    .blendFuncSeparate = true,
    .multiDrawArrays = true,
    .multiDrawElements = true,
    .pointParameterf = true,
    .pointParameterfv = true,
    .pointParameteri = true,
    .pointParameteriv = true,
    .fogCoordf = true,
    .fogCoordfv = true,
    .fogCoordd = true,
    .fogCoorddv = true,
    .fogCoordPointer = true,
    .secondaryColor3b = true,
    .secondaryColor3bv = true,
    .secondaryColor3d = true,
    .secondaryColor3dv = true,
    .secondaryColor3f = true,
    .secondaryColor3fv = true,
    .secondaryColor3i = true,
    .secondaryColor3iv = true,
    .secondaryColor3s = true,
    .secondaryColor3sv = true,
    .secondaryColor3ub = true,
    .secondaryColor3ubv = true,
    .secondaryColor3ui = true,
    .secondaryColor3uiv = true,
    .secondaryColor3us = true,
    .secondaryColor3usv = true,
    .secondaryColorPointer = true,
    .windowPos2d = true,
    .windowPos2dv = true,
    .windowPos2f = true,
    .windowPos2fv = true,
    .windowPos2i = true,
    .windowPos2iv = true,
    .windowPos2s = true,
    .windowPos2sv = true,
    .windowPos3d = true,
    .windowPos3dv = true,
    .windowPos3f = true,
    .windowPos3fv = true,
    .windowPos3i = true,
    .windowPos3iv = true,
    .windowPos3s = true,
    .windowPos3sv = true,
    .blendColor = true,
    .blendEquation = true,
    .genQueries = true,
    .deleteQueries = true,
    .isQuery = true,
    .beginQuery = true,
    .endQuery = true,
    .getQueryiv = true,
    .getQueryObjectiv = true,
    .getQueryObjectuiv = true,
    .bindBuffer = true,
    .deleteBuffers = true,
    .genBuffers = true,
    .isBuffer = true,
    .bufferData = true,
    .bufferSubData = true,
    .getBufferSubData = true,
    .mapBuffer = true,
    .unmapBuffer = true,
    .getBufferParameteriv = true,
    .getBufferPointerv = true,
    .blendEquationSeparate = true,
    .drawBuffers = true,
    .stencilOpSeparate = true,
    .stencilFuncSeparate = true,
    .stencilMaskSeparate = true,
    .attachShader = true,
    .bindAttribLocation = true,
    .compileShader = true,
    .createProgram = true,
    .createShader = true,
    .deleteProgram = true,
    .deleteShader = true,
    .detachShader = true,
    .disableVertexAttribArray = true,
    .enableVertexAttribArray = true,
    .getActiveAttrib = true,
    .getActiveUniform = true,
    .getAttachedShaders = true,
    .getAttribLocation = true,
    .getProgramiv = true,
    .getProgramInfoLog = true,
    .getShaderiv = true,
    .getShaderInfoLog = true,
    .getShaderSource = true,
    .getUniformLocation = true,
    .getUniformfv = true,
    .getUniformiv = true,
    .getVertexAttribdv = true,
    .getVertexAttribfv = true,
    .getVertexAttribiv = true,
    .getVertexAttribPointerv = true,
    .isProgram = true,
    .isShader = true,
    .linkProgram = true,
    .shaderSource = true,
    .useProgram = true,
    .uniform1f = true,
    .uniform2f = true,
    .uniform3f = true,
    .uniform4f = true,
    .uniform1i = true,
    .uniform2i = true,
    .uniform3i = true,
    .uniform4i = true,
    .uniform1fv = true,
    .uniform2fv = true,
    .uniform3fv = true,
    .uniform4fv = true,
    .uniform1iv = true,
    .uniform2iv = true,
    .uniform3iv = true,
    .uniform4iv = true,
    .uniformMatrix2fv = true,
    .uniformMatrix3fv = true,
    .uniformMatrix4fv = true,
    .validateProgram = true,
    .vertexAttrib1d = true,
    .vertexAttrib1dv = true,
    .vertexAttrib1f = true,
    .vertexAttrib1fv = true,
    .vertexAttrib1s = true,
    .vertexAttrib1sv = true,
    .vertexAttrib2d = true,
    .vertexAttrib2dv = true,
    .vertexAttrib2f = true,
    .vertexAttrib2fv = true,
    .vertexAttrib2s = true,
    .vertexAttrib2sv = true,
    .vertexAttrib3d = true,
    .vertexAttrib3dv = true,
    .vertexAttrib3f = true,
    .vertexAttrib3fv = true,
    .vertexAttrib3s = true,
    .vertexAttrib3sv = true,
    .vertexAttrib4Nbv = true,
    .vertexAttrib4Niv = true,
    .vertexAttrib4Nsv = true,
    .vertexAttrib4Nub = true,
    .vertexAttrib4Nubv = true,
    .vertexAttrib4Nuiv = true,
    .vertexAttrib4Nusv = true,
    .vertexAttrib4bv = true,
    .vertexAttrib4d = true,
    .vertexAttrib4dv = true,
    .vertexAttrib4f = true,
    .vertexAttrib4fv = true,
    .vertexAttrib4iv = true,
    .vertexAttrib4s = true,
    .vertexAttrib4sv = true,
    .vertexAttrib4ubv = true,
    .vertexAttrib4uiv = true,
    .vertexAttrib4usv = true,
    .vertexAttribPointer = true,
    .uniformMatrix2x3fv = true,
    .uniformMatrix3x2fv = true,
    .uniformMatrix2x4fv = true,
    .uniformMatrix4x2fv = true,
    .uniformMatrix3x4fv = true,
    .uniformMatrix4x3fv = true,
    .colorMaski = true,
    .getBooleani_v = true,
    .getIntegeri_v = true,
    .enablei = true,
    .disablei = true,
    .isEnabledi = true,
    .beginTransformFeedback = true,
    .endTransformFeedback = true,
    .bindBufferRange = true,
    .bindBufferBase = true,
    .transformFeedbackVaryings = true,
    .getTransformFeedbackVarying = true,
    .clampColor = true,
    .beginConditionalRender = true,
    .endConditionalRender = true,
    .vertexAttribIPointer = true,
    .getVertexAttribIiv = true,
    .getVertexAttribIuiv = true,
    .vertexAttribI1i = true,
    .vertexAttribI2i = true,
    .vertexAttribI3i = true,
    .vertexAttribI4i = true,
    .vertexAttribI1ui = true,
    .vertexAttribI2ui = true,
    .vertexAttribI3ui = true,
    .vertexAttribI4ui = true,
    .vertexAttribI1iv = true,
    .vertexAttribI2iv = true,
    .vertexAttribI3iv = true,
    .vertexAttribI4iv = true,
    .vertexAttribI1uiv = true,
    .vertexAttribI2uiv = true,
    .vertexAttribI3uiv = true,
    .vertexAttribI4uiv = true,
    .vertexAttribI4bv = true,
    .vertexAttribI4sv = true,
    .vertexAttribI4ubv = true,
    .vertexAttribI4usv = true,
    .getUniformuiv = true,
    .bindFragDataLocation = true,
    .getFragDataLocation = true,
    .uniform1ui = true,
    .uniform2ui = true,
    .uniform3ui = true,
    .uniform4ui = true,
    .uniform1uiv = true,
    .uniform2uiv = true,
    .uniform3uiv = true,
    .uniform4uiv = true,
    .texParameterIiv = true,
    .texParameterIuiv = true,
    .getTexParameterIiv = true,
    .getTexParameterIuiv = true,
    .clearBufferiv = true,
    .clearBufferuiv = true,
    .clearBufferfv = true,
    .clearBufferfi = true,
    .getStringi = true,
    .isRenderbuffer = true,
    .bindRenderbuffer = true,
    .deleteRenderbuffers = true,
    .genRenderbuffers = true,
    .renderbufferStorage = true,
    .getRenderbufferParameteriv = true,
    .isFramebuffer = true,
    .bindFramebuffer = true,
    .deleteFramebuffers = true,
    .genFramebuffers = true,
    .checkFramebufferStatus = true,
    .framebufferTexture1D = true,
    .framebufferTexture2D = true,
    .framebufferTexture3D = true,
    .framebufferRenderbuffer = true,
    .getFramebufferAttachmentParameteriv = true,
    .generateMipmap = true,
    .blitFramebuffer = true,
    .renderbufferStorageMultisample = true,
    .framebufferTextureLayer = true,
    .mapBufferRange = true,
    .flushMappedBufferRange = true,
    .bindVertexArray = true,
    .deleteVertexArrays = true,
    .genVertexArrays = true,
    .isVertexArray = true,
    .drawArraysInstanced = true,
    .drawElementsInstanced = true,
    .texBuffer = true,
    .primitiveRestartIndex = true,
    .copyBufferSubData = true,
    .getUniformIndices = true,
    .getActiveUniformsiv = true,
    .getActiveUniformName = true,
    .getUniformBlockIndex = true,
    .getActiveUniformBlockiv = true,
    .getActiveUniformBlockName = true,
    .uniformBlockBinding = true,
};

pub const gl32 = CommandFlags{
    .cullFace = true,
    .frontFace = true,
    .hint = true,
    .lineWidth = true,
    .pointSize = true,
    .polygonMode = true,
    .scissor = true,
    .texParameterf = true,
    .texParameterfv = true,
    .texParameteri = true,
    .texParameteriv = true,
    .texImage1D = true,
    .texImage2D = true,
    .drawBuffer = true,
    .clear = true,
    .clearColor = true,
    .clearStencil = true,
    .clearDepth = true,
    .stencilMask = true,
    .colorMask = true,
    .depthMask = true,
    .disable = true,
    .enable = true,
    .finish = true,
    .flush = true,
    .blendFunc = true,
    .logicOp = true,
    .stencilFunc = true,
    .stencilOp = true,
    .depthFunc = true,
    .pixelStoref = true,
    .pixelStorei = true,
    .readBuffer = true,
    .readPixels = true,
    .getBooleanv = true,
    .getDoublev = true,
    .getError = true,
    .getFloatv = true,
    .getIntegerv = true,
    .getString = true,
    .getTexImage = true,
    .getTexParameterfv = true,
    .getTexParameteriv = true,
    .getTexLevelParameterfv = true,
    .getTexLevelParameteriv = true,
    .isEnabled = true,
    .depthRange = true,
    .viewport = true,
    .newList = true,
    .endList = true,
    .callList = true,
    .callLists = true,
    .deleteLists = true,
    .genLists = true,
    .listBase = true,
    .begin = true,
    .bitmap = true,
    .color3b = true,
    .color3bv = true,
    .color3d = true,
    .color3dv = true,
    .color3f = true,
    .color3fv = true,
    .color3i = true,
    .color3iv = true,
    .color3s = true,
    .color3sv = true,
    .color3ub = true,
    .color3ubv = true,
    .color3ui = true,
    .color3uiv = true,
    .color3us = true,
    .color3usv = true,
    .color4b = true,
    .color4bv = true,
    .color4d = true,
    .color4dv = true,
    .color4f = true,
    .color4fv = true,
    .color4i = true,
    .color4iv = true,
    .color4s = true,
    .color4sv = true,
    .color4ub = true,
    .color4ubv = true,
    .color4ui = true,
    .color4uiv = true,
    .color4us = true,
    .color4usv = true,
    .edgeFlag = true,
    .edgeFlagv = true,
    .end = true,
    .indexd = true,
    .indexdv = true,
    .indexf = true,
    .indexfv = true,
    .indexi = true,
    .indexiv = true,
    .indexs = true,
    .indexsv = true,
    .normal3b = true,
    .normal3bv = true,
    .normal3d = true,
    .normal3dv = true,
    .normal3f = true,
    .normal3fv = true,
    .normal3i = true,
    .normal3iv = true,
    .normal3s = true,
    .normal3sv = true,
    .rasterPos2d = true,
    .rasterPos2dv = true,
    .rasterPos2f = true,
    .rasterPos2fv = true,
    .rasterPos2i = true,
    .rasterPos2iv = true,
    .rasterPos2s = true,
    .rasterPos2sv = true,
    .rasterPos3d = true,
    .rasterPos3dv = true,
    .rasterPos3f = true,
    .rasterPos3fv = true,
    .rasterPos3i = true,
    .rasterPos3iv = true,
    .rasterPos3s = true,
    .rasterPos3sv = true,
    .rasterPos4d = true,
    .rasterPos4dv = true,
    .rasterPos4f = true,
    .rasterPos4fv = true,
    .rasterPos4i = true,
    .rasterPos4iv = true,
    .rasterPos4s = true,
    .rasterPos4sv = true,
    .rectd = true,
    .rectdv = true,
    .rectf = true,
    .rectfv = true,
    .recti = true,
    .rectiv = true,
    .rects = true,
    .rectsv = true,
    .texCoord1d = true,
    .texCoord1dv = true,
    .texCoord1f = true,
    .texCoord1fv = true,
    .texCoord1i = true,
    .texCoord1iv = true,
    .texCoord1s = true,
    .texCoord1sv = true,
    .texCoord2d = true,
    .texCoord2dv = true,
    .texCoord2f = true,
    .texCoord2fv = true,
    .texCoord2i = true,
    .texCoord2iv = true,
    .texCoord2s = true,
    .texCoord2sv = true,
    .texCoord3d = true,
    .texCoord3dv = true,
    .texCoord3f = true,
    .texCoord3fv = true,
    .texCoord3i = true,
    .texCoord3iv = true,
    .texCoord3s = true,
    .texCoord3sv = true,
    .texCoord4d = true,
    .texCoord4dv = true,
    .texCoord4f = true,
    .texCoord4fv = true,
    .texCoord4i = true,
    .texCoord4iv = true,
    .texCoord4s = true,
    .texCoord4sv = true,
    .vertex2d = true,
    .vertex2dv = true,
    .vertex2f = true,
    .vertex2fv = true,
    .vertex2i = true,
    .vertex2iv = true,
    .vertex2s = true,
    .vertex2sv = true,
    .vertex3d = true,
    .vertex3dv = true,
    .vertex3f = true,
    .vertex3fv = true,
    .vertex3i = true,
    .vertex3iv = true,
    .vertex3s = true,
    .vertex3sv = true,
    .vertex4d = true,
    .vertex4dv = true,
    .vertex4f = true,
    .vertex4fv = true,
    .vertex4i = true,
    .vertex4iv = true,
    .vertex4s = true,
    .vertex4sv = true,
    .clipPlane = true,
    .colorMaterial = true,
    .fogf = true,
    .fogfv = true,
    .fogi = true,
    .fogiv = true,
    .lightf = true,
    .lightfv = true,
    .lighti = true,
    .lightiv = true,
    .lightModelf = true,
    .lightModelfv = true,
    .lightModeli = true,
    .lightModeliv = true,
    .lineStipple = true,
    .materialf = true,
    .materialfv = true,
    .materiali = true,
    .materialiv = true,
    .polygonStipple = true,
    .shadeModel = true,
    .texEnvf = true,
    .texEnvfv = true,
    .texEnvi = true,
    .texEnviv = true,
    .texGend = true,
    .texGendv = true,
    .texGenf = true,
    .texGenfv = true,
    .texGeni = true,
    .texGeniv = true,
    .feedbackBuffer = true,
    .selectBuffer = true,
    .renderMode = true,
    .initNames = true,
    .loadName = true,
    .passThrough = true,
    .popName = true,
    .pushName = true,
    .clearAccum = true,
    .clearIndex = true,
    .indexMask = true,
    .accum = true,
    .popAttrib = true,
    .pushAttrib = true,
    .map1d = true,
    .map1f = true,
    .map2d = true,
    .map2f = true,
    .mapGrid1d = true,
    .mapGrid1f = true,
    .mapGrid2d = true,
    .mapGrid2f = true,
    .evalCoord1d = true,
    .evalCoord1dv = true,
    .evalCoord1f = true,
    .evalCoord1fv = true,
    .evalCoord2d = true,
    .evalCoord2dv = true,
    .evalCoord2f = true,
    .evalCoord2fv = true,
    .evalMesh1 = true,
    .evalPoint1 = true,
    .evalMesh2 = true,
    .evalPoint2 = true,
    .alphaFunc = true,
    .pixelZoom = true,
    .pixelTransferf = true,
    .pixelTransferi = true,
    .pixelMapfv = true,
    .pixelMapuiv = true,
    .pixelMapusv = true,
    .copyPixels = true,
    .drawPixels = true,
    .getClipPlane = true,
    .getLightfv = true,
    .getLightiv = true,
    .getMapdv = true,
    .getMapfv = true,
    .getMapiv = true,
    .getMaterialfv = true,
    .getMaterialiv = true,
    .getPixelMapfv = true,
    .getPixelMapuiv = true,
    .getPixelMapusv = true,
    .getPolygonStipple = true,
    .getTexEnvfv = true,
    .getTexEnviv = true,
    .getTexGendv = true,
    .getTexGenfv = true,
    .getTexGeniv = true,
    .isList = true,
    .frustum = true,
    .loadIdentity = true,
    .loadMatrixf = true,
    .loadMatrixd = true,
    .matrixMode = true,
    .multMatrixf = true,
    .multMatrixd = true,
    .ortho = true,
    .popMatrix = true,
    .pushMatrix = true,
    .rotated = true,
    .rotatef = true,
    .scaled = true,
    .scalef = true,
    .translated = true,
    .translatef = true,
    .drawArrays = true,
    .drawElements = true,
    .getPointerv = true,
    .polygonOffset = true,
    .copyTexImage1D = true,
    .copyTexImage2D = true,
    .copyTexSubImage1D = true,
    .copyTexSubImage2D = true,
    .texSubImage1D = true,
    .texSubImage2D = true,
    .bindTexture = true,
    .deleteTextures = true,
    .genTextures = true,
    .isTexture = true,
    .arrayElement = true,
    .colorPointer = true,
    .disableClientState = true,
    .edgeFlagPointer = true,
    .enableClientState = true,
    .indexPointer = true,
    .interleavedArrays = true,
    .normalPointer = true,
    .texCoordPointer = true,
    .vertexPointer = true,
    .areTexturesResident = true,
    .prioritizeTextures = true,
    .indexub = true,
    .indexubv = true,
    .popClientAttrib = true,
    .pushClientAttrib = true,
    .drawRangeElements = true,
    .texImage3D = true,
    .texSubImage3D = true,
    .copyTexSubImage3D = true,
    .activeTexture = true,
    .sampleCoverage = true,
    .compressedTexImage3D = true,
    .compressedTexImage2D = true,
    .compressedTexImage1D = true,
    .compressedTexSubImage3D = true,
    .compressedTexSubImage2D = true,
    .compressedTexSubImage1D = true,
    .getCompressedTexImage = true,
    .clientActiveTexture = true,
    .multiTexCoord1d = true,
    .multiTexCoord1dv = true,
    .multiTexCoord1f = true,
    .multiTexCoord1fv = true,
    .multiTexCoord1i = true,
    .multiTexCoord1iv = true,
    .multiTexCoord1s = true,
    .multiTexCoord1sv = true,
    .multiTexCoord2d = true,
    .multiTexCoord2dv = true,
    .multiTexCoord2f = true,
    .multiTexCoord2fv = true,
    .multiTexCoord2i = true,
    .multiTexCoord2iv = true,
    .multiTexCoord2s = true,
    .multiTexCoord2sv = true,
    .multiTexCoord3d = true,
    .multiTexCoord3dv = true,
    .multiTexCoord3f = true,
    .multiTexCoord3fv = true,
    .multiTexCoord3i = true,
    .multiTexCoord3iv = true,
    .multiTexCoord3s = true,
    .multiTexCoord3sv = true,
    .multiTexCoord4d = true,
    .multiTexCoord4dv = true,
    .multiTexCoord4f = true,
    .multiTexCoord4fv = true,
    .multiTexCoord4i = true,
    .multiTexCoord4iv = true,
    .multiTexCoord4s = true,
    .multiTexCoord4sv = true,
    .loadTransposeMatrixf = true,
    .loadTransposeMatrixd = true,
    .multTransposeMatrixf = true,
    .multTransposeMatrixd = true,
    .blendFuncSeparate = true,
    .multiDrawArrays = true,
    .multiDrawElements = true,
    .pointParameterf = true,
    .pointParameterfv = true,
    .pointParameteri = true,
    .pointParameteriv = true,
    .fogCoordf = true,
    .fogCoordfv = true,
    .fogCoordd = true,
    .fogCoorddv = true,
    .fogCoordPointer = true,
    .secondaryColor3b = true,
    .secondaryColor3bv = true,
    .secondaryColor3d = true,
    .secondaryColor3dv = true,
    .secondaryColor3f = true,
    .secondaryColor3fv = true,
    .secondaryColor3i = true,
    .secondaryColor3iv = true,
    .secondaryColor3s = true,
    .secondaryColor3sv = true,
    .secondaryColor3ub = true,
    .secondaryColor3ubv = true,
    .secondaryColor3ui = true,
    .secondaryColor3uiv = true,
    .secondaryColor3us = true,
    .secondaryColor3usv = true,
    .secondaryColorPointer = true,
    .windowPos2d = true,
    .windowPos2dv = true,
    .windowPos2f = true,
    .windowPos2fv = true,
    .windowPos2i = true,
    .windowPos2iv = true,
    .windowPos2s = true,
    .windowPos2sv = true,
    .windowPos3d = true,
    .windowPos3dv = true,
    .windowPos3f = true,
    .windowPos3fv = true,
    .windowPos3i = true,
    .windowPos3iv = true,
    .windowPos3s = true,
    .windowPos3sv = true,
    .blendColor = true,
    .blendEquation = true,
    .genQueries = true,
    .deleteQueries = true,
    .isQuery = true,
    .beginQuery = true,
    .endQuery = true,
    .getQueryiv = true,
    .getQueryObjectiv = true,
    .getQueryObjectuiv = true,
    .bindBuffer = true,
    .deleteBuffers = true,
    .genBuffers = true,
    .isBuffer = true,
    .bufferData = true,
    .bufferSubData = true,
    .getBufferSubData = true,
    .mapBuffer = true,
    .unmapBuffer = true,
    .getBufferParameteriv = true,
    .getBufferPointerv = true,
    .blendEquationSeparate = true,
    .drawBuffers = true,
    .stencilOpSeparate = true,
    .stencilFuncSeparate = true,
    .stencilMaskSeparate = true,
    .attachShader = true,
    .bindAttribLocation = true,
    .compileShader = true,
    .createProgram = true,
    .createShader = true,
    .deleteProgram = true,
    .deleteShader = true,
    .detachShader = true,
    .disableVertexAttribArray = true,
    .enableVertexAttribArray = true,
    .getActiveAttrib = true,
    .getActiveUniform = true,
    .getAttachedShaders = true,
    .getAttribLocation = true,
    .getProgramiv = true,
    .getProgramInfoLog = true,
    .getShaderiv = true,
    .getShaderInfoLog = true,
    .getShaderSource = true,
    .getUniformLocation = true,
    .getUniformfv = true,
    .getUniformiv = true,
    .getVertexAttribdv = true,
    .getVertexAttribfv = true,
    .getVertexAttribiv = true,
    .getVertexAttribPointerv = true,
    .isProgram = true,
    .isShader = true,
    .linkProgram = true,
    .shaderSource = true,
    .useProgram = true,
    .uniform1f = true,
    .uniform2f = true,
    .uniform3f = true,
    .uniform4f = true,
    .uniform1i = true,
    .uniform2i = true,
    .uniform3i = true,
    .uniform4i = true,
    .uniform1fv = true,
    .uniform2fv = true,
    .uniform3fv = true,
    .uniform4fv = true,
    .uniform1iv = true,
    .uniform2iv = true,
    .uniform3iv = true,
    .uniform4iv = true,
    .uniformMatrix2fv = true,
    .uniformMatrix3fv = true,
    .uniformMatrix4fv = true,
    .validateProgram = true,
    .vertexAttrib1d = true,
    .vertexAttrib1dv = true,
    .vertexAttrib1f = true,
    .vertexAttrib1fv = true,
    .vertexAttrib1s = true,
    .vertexAttrib1sv = true,
    .vertexAttrib2d = true,
    .vertexAttrib2dv = true,
    .vertexAttrib2f = true,
    .vertexAttrib2fv = true,
    .vertexAttrib2s = true,
    .vertexAttrib2sv = true,
    .vertexAttrib3d = true,
    .vertexAttrib3dv = true,
    .vertexAttrib3f = true,
    .vertexAttrib3fv = true,
    .vertexAttrib3s = true,
    .vertexAttrib3sv = true,
    .vertexAttrib4Nbv = true,
    .vertexAttrib4Niv = true,
    .vertexAttrib4Nsv = true,
    .vertexAttrib4Nub = true,
    .vertexAttrib4Nubv = true,
    .vertexAttrib4Nuiv = true,
    .vertexAttrib4Nusv = true,
    .vertexAttrib4bv = true,
    .vertexAttrib4d = true,
    .vertexAttrib4dv = true,
    .vertexAttrib4f = true,
    .vertexAttrib4fv = true,
    .vertexAttrib4iv = true,
    .vertexAttrib4s = true,
    .vertexAttrib4sv = true,
    .vertexAttrib4ubv = true,
    .vertexAttrib4uiv = true,
    .vertexAttrib4usv = true,
    .vertexAttribPointer = true,
    .uniformMatrix2x3fv = true,
    .uniformMatrix3x2fv = true,
    .uniformMatrix2x4fv = true,
    .uniformMatrix4x2fv = true,
    .uniformMatrix3x4fv = true,
    .uniformMatrix4x3fv = true,
    .colorMaski = true,
    .getBooleani_v = true,
    .getIntegeri_v = true,
    .enablei = true,
    .disablei = true,
    .isEnabledi = true,
    .beginTransformFeedback = true,
    .endTransformFeedback = true,
    .bindBufferRange = true,
    .bindBufferBase = true,
    .transformFeedbackVaryings = true,
    .getTransformFeedbackVarying = true,
    .clampColor = true,
    .beginConditionalRender = true,
    .endConditionalRender = true,
    .vertexAttribIPointer = true,
    .getVertexAttribIiv = true,
    .getVertexAttribIuiv = true,
    .vertexAttribI1i = true,
    .vertexAttribI2i = true,
    .vertexAttribI3i = true,
    .vertexAttribI4i = true,
    .vertexAttribI1ui = true,
    .vertexAttribI2ui = true,
    .vertexAttribI3ui = true,
    .vertexAttribI4ui = true,
    .vertexAttribI1iv = true,
    .vertexAttribI2iv = true,
    .vertexAttribI3iv = true,
    .vertexAttribI4iv = true,
    .vertexAttribI1uiv = true,
    .vertexAttribI2uiv = true,
    .vertexAttribI3uiv = true,
    .vertexAttribI4uiv = true,
    .vertexAttribI4bv = true,
    .vertexAttribI4sv = true,
    .vertexAttribI4ubv = true,
    .vertexAttribI4usv = true,
    .getUniformuiv = true,
    .bindFragDataLocation = true,
    .getFragDataLocation = true,
    .uniform1ui = true,
    .uniform2ui = true,
    .uniform3ui = true,
    .uniform4ui = true,
    .uniform1uiv = true,
    .uniform2uiv = true,
    .uniform3uiv = true,
    .uniform4uiv = true,
    .texParameterIiv = true,
    .texParameterIuiv = true,
    .getTexParameterIiv = true,
    .getTexParameterIuiv = true,
    .clearBufferiv = true,
    .clearBufferuiv = true,
    .clearBufferfv = true,
    .clearBufferfi = true,
    .getStringi = true,
    .isRenderbuffer = true,
    .bindRenderbuffer = true,
    .deleteRenderbuffers = true,
    .genRenderbuffers = true,
    .renderbufferStorage = true,
    .getRenderbufferParameteriv = true,
    .isFramebuffer = true,
    .bindFramebuffer = true,
    .deleteFramebuffers = true,
    .genFramebuffers = true,
    .checkFramebufferStatus = true,
    .framebufferTexture1D = true,
    .framebufferTexture2D = true,
    .framebufferTexture3D = true,
    .framebufferRenderbuffer = true,
    .getFramebufferAttachmentParameteriv = true,
    .generateMipmap = true,
    .blitFramebuffer = true,
    .renderbufferStorageMultisample = true,
    .framebufferTextureLayer = true,
    .mapBufferRange = true,
    .flushMappedBufferRange = true,
    .bindVertexArray = true,
    .deleteVertexArrays = true,
    .genVertexArrays = true,
    .isVertexArray = true,
    .drawArraysInstanced = true,
    .drawElementsInstanced = true,
    .texBuffer = true,
    .primitiveRestartIndex = true,
    .copyBufferSubData = true,
    .getUniformIndices = true,
    .getActiveUniformsiv = true,
    .getActiveUniformName = true,
    .getUniformBlockIndex = true,
    .getActiveUniformBlockiv = true,
    .getActiveUniformBlockName = true,
    .uniformBlockBinding = true,
    .drawElementsBaseVertex = true,
    .drawRangeElementsBaseVertex = true,
    .drawElementsInstancedBaseVertex = true,
    .multiDrawElementsBaseVertex = true,
    .provokingVertex = true,
    .fenceSync = true,
    .isSync = true,
    .deleteSync = true,
    .clientWaitSync = true,
    .waitSync = true,
    .getInteger64v = true,
    .getSynciv = true,
    .getInteger64i_v = true,
    .getBufferParameteri64v = true,
    .framebufferTexture = true,
    .texImage2DMultisample = true,
    .texImage3DMultisample = true,
    .getMultisamplefv = true,
    .sampleMaski = true,
};

pub const gl33 = CommandFlags{
    .cullFace = true,
    .frontFace = true,
    .hint = true,
    .lineWidth = true,
    .pointSize = true,
    .polygonMode = true,
    .scissor = true,
    .texParameterf = true,
    .texParameterfv = true,
    .texParameteri = true,
    .texParameteriv = true,
    .texImage1D = true,
    .texImage2D = true,
    .drawBuffer = true,
    .clear = true,
    .clearColor = true,
    .clearStencil = true,
    .clearDepth = true,
    .stencilMask = true,
    .colorMask = true,
    .depthMask = true,
    .disable = true,
    .enable = true,
    .finish = true,
    .flush = true,
    .blendFunc = true,
    .logicOp = true,
    .stencilFunc = true,
    .stencilOp = true,
    .depthFunc = true,
    .pixelStoref = true,
    .pixelStorei = true,
    .readBuffer = true,
    .readPixels = true,
    .getBooleanv = true,
    .getDoublev = true,
    .getError = true,
    .getFloatv = true,
    .getIntegerv = true,
    .getString = true,
    .getTexImage = true,
    .getTexParameterfv = true,
    .getTexParameteriv = true,
    .getTexLevelParameterfv = true,
    .getTexLevelParameteriv = true,
    .isEnabled = true,
    .depthRange = true,
    .viewport = true,
    .newList = true,
    .endList = true,
    .callList = true,
    .callLists = true,
    .deleteLists = true,
    .genLists = true,
    .listBase = true,
    .begin = true,
    .bitmap = true,
    .color3b = true,
    .color3bv = true,
    .color3d = true,
    .color3dv = true,
    .color3f = true,
    .color3fv = true,
    .color3i = true,
    .color3iv = true,
    .color3s = true,
    .color3sv = true,
    .color3ub = true,
    .color3ubv = true,
    .color3ui = true,
    .color3uiv = true,
    .color3us = true,
    .color3usv = true,
    .color4b = true,
    .color4bv = true,
    .color4d = true,
    .color4dv = true,
    .color4f = true,
    .color4fv = true,
    .color4i = true,
    .color4iv = true,
    .color4s = true,
    .color4sv = true,
    .color4ub = true,
    .color4ubv = true,
    .color4ui = true,
    .color4uiv = true,
    .color4us = true,
    .color4usv = true,
    .edgeFlag = true,
    .edgeFlagv = true,
    .end = true,
    .indexd = true,
    .indexdv = true,
    .indexf = true,
    .indexfv = true,
    .indexi = true,
    .indexiv = true,
    .indexs = true,
    .indexsv = true,
    .normal3b = true,
    .normal3bv = true,
    .normal3d = true,
    .normal3dv = true,
    .normal3f = true,
    .normal3fv = true,
    .normal3i = true,
    .normal3iv = true,
    .normal3s = true,
    .normal3sv = true,
    .rasterPos2d = true,
    .rasterPos2dv = true,
    .rasterPos2f = true,
    .rasterPos2fv = true,
    .rasterPos2i = true,
    .rasterPos2iv = true,
    .rasterPos2s = true,
    .rasterPos2sv = true,
    .rasterPos3d = true,
    .rasterPos3dv = true,
    .rasterPos3f = true,
    .rasterPos3fv = true,
    .rasterPos3i = true,
    .rasterPos3iv = true,
    .rasterPos3s = true,
    .rasterPos3sv = true,
    .rasterPos4d = true,
    .rasterPos4dv = true,
    .rasterPos4f = true,
    .rasterPos4fv = true,
    .rasterPos4i = true,
    .rasterPos4iv = true,
    .rasterPos4s = true,
    .rasterPos4sv = true,
    .rectd = true,
    .rectdv = true,
    .rectf = true,
    .rectfv = true,
    .recti = true,
    .rectiv = true,
    .rects = true,
    .rectsv = true,
    .texCoord1d = true,
    .texCoord1dv = true,
    .texCoord1f = true,
    .texCoord1fv = true,
    .texCoord1i = true,
    .texCoord1iv = true,
    .texCoord1s = true,
    .texCoord1sv = true,
    .texCoord2d = true,
    .texCoord2dv = true,
    .texCoord2f = true,
    .texCoord2fv = true,
    .texCoord2i = true,
    .texCoord2iv = true,
    .texCoord2s = true,
    .texCoord2sv = true,
    .texCoord3d = true,
    .texCoord3dv = true,
    .texCoord3f = true,
    .texCoord3fv = true,
    .texCoord3i = true,
    .texCoord3iv = true,
    .texCoord3s = true,
    .texCoord3sv = true,
    .texCoord4d = true,
    .texCoord4dv = true,
    .texCoord4f = true,
    .texCoord4fv = true,
    .texCoord4i = true,
    .texCoord4iv = true,
    .texCoord4s = true,
    .texCoord4sv = true,
    .vertex2d = true,
    .vertex2dv = true,
    .vertex2f = true,
    .vertex2fv = true,
    .vertex2i = true,
    .vertex2iv = true,
    .vertex2s = true,
    .vertex2sv = true,
    .vertex3d = true,
    .vertex3dv = true,
    .vertex3f = true,
    .vertex3fv = true,
    .vertex3i = true,
    .vertex3iv = true,
    .vertex3s = true,
    .vertex3sv = true,
    .vertex4d = true,
    .vertex4dv = true,
    .vertex4f = true,
    .vertex4fv = true,
    .vertex4i = true,
    .vertex4iv = true,
    .vertex4s = true,
    .vertex4sv = true,
    .clipPlane = true,
    .colorMaterial = true,
    .fogf = true,
    .fogfv = true,
    .fogi = true,
    .fogiv = true,
    .lightf = true,
    .lightfv = true,
    .lighti = true,
    .lightiv = true,
    .lightModelf = true,
    .lightModelfv = true,
    .lightModeli = true,
    .lightModeliv = true,
    .lineStipple = true,
    .materialf = true,
    .materialfv = true,
    .materiali = true,
    .materialiv = true,
    .polygonStipple = true,
    .shadeModel = true,
    .texEnvf = true,
    .texEnvfv = true,
    .texEnvi = true,
    .texEnviv = true,
    .texGend = true,
    .texGendv = true,
    .texGenf = true,
    .texGenfv = true,
    .texGeni = true,
    .texGeniv = true,
    .feedbackBuffer = true,
    .selectBuffer = true,
    .renderMode = true,
    .initNames = true,
    .loadName = true,
    .passThrough = true,
    .popName = true,
    .pushName = true,
    .clearAccum = true,
    .clearIndex = true,
    .indexMask = true,
    .accum = true,
    .popAttrib = true,
    .pushAttrib = true,
    .map1d = true,
    .map1f = true,
    .map2d = true,
    .map2f = true,
    .mapGrid1d = true,
    .mapGrid1f = true,
    .mapGrid2d = true,
    .mapGrid2f = true,
    .evalCoord1d = true,
    .evalCoord1dv = true,
    .evalCoord1f = true,
    .evalCoord1fv = true,
    .evalCoord2d = true,
    .evalCoord2dv = true,
    .evalCoord2f = true,
    .evalCoord2fv = true,
    .evalMesh1 = true,
    .evalPoint1 = true,
    .evalMesh2 = true,
    .evalPoint2 = true,
    .alphaFunc = true,
    .pixelZoom = true,
    .pixelTransferf = true,
    .pixelTransferi = true,
    .pixelMapfv = true,
    .pixelMapuiv = true,
    .pixelMapusv = true,
    .copyPixels = true,
    .drawPixels = true,
    .getClipPlane = true,
    .getLightfv = true,
    .getLightiv = true,
    .getMapdv = true,
    .getMapfv = true,
    .getMapiv = true,
    .getMaterialfv = true,
    .getMaterialiv = true,
    .getPixelMapfv = true,
    .getPixelMapuiv = true,
    .getPixelMapusv = true,
    .getPolygonStipple = true,
    .getTexEnvfv = true,
    .getTexEnviv = true,
    .getTexGendv = true,
    .getTexGenfv = true,
    .getTexGeniv = true,
    .isList = true,
    .frustum = true,
    .loadIdentity = true,
    .loadMatrixf = true,
    .loadMatrixd = true,
    .matrixMode = true,
    .multMatrixf = true,
    .multMatrixd = true,
    .ortho = true,
    .popMatrix = true,
    .pushMatrix = true,
    .rotated = true,
    .rotatef = true,
    .scaled = true,
    .scalef = true,
    .translated = true,
    .translatef = true,
    .drawArrays = true,
    .drawElements = true,
    .getPointerv = true,
    .polygonOffset = true,
    .copyTexImage1D = true,
    .copyTexImage2D = true,
    .copyTexSubImage1D = true,
    .copyTexSubImage2D = true,
    .texSubImage1D = true,
    .texSubImage2D = true,
    .bindTexture = true,
    .deleteTextures = true,
    .genTextures = true,
    .isTexture = true,
    .arrayElement = true,
    .colorPointer = true,
    .disableClientState = true,
    .edgeFlagPointer = true,
    .enableClientState = true,
    .indexPointer = true,
    .interleavedArrays = true,
    .normalPointer = true,
    .texCoordPointer = true,
    .vertexPointer = true,
    .areTexturesResident = true,
    .prioritizeTextures = true,
    .indexub = true,
    .indexubv = true,
    .popClientAttrib = true,
    .pushClientAttrib = true,
    .drawRangeElements = true,
    .texImage3D = true,
    .texSubImage3D = true,
    .copyTexSubImage3D = true,
    .activeTexture = true,
    .sampleCoverage = true,
    .compressedTexImage3D = true,
    .compressedTexImage2D = true,
    .compressedTexImage1D = true,
    .compressedTexSubImage3D = true,
    .compressedTexSubImage2D = true,
    .compressedTexSubImage1D = true,
    .getCompressedTexImage = true,
    .clientActiveTexture = true,
    .multiTexCoord1d = true,
    .multiTexCoord1dv = true,
    .multiTexCoord1f = true,
    .multiTexCoord1fv = true,
    .multiTexCoord1i = true,
    .multiTexCoord1iv = true,
    .multiTexCoord1s = true,
    .multiTexCoord1sv = true,
    .multiTexCoord2d = true,
    .multiTexCoord2dv = true,
    .multiTexCoord2f = true,
    .multiTexCoord2fv = true,
    .multiTexCoord2i = true,
    .multiTexCoord2iv = true,
    .multiTexCoord2s = true,
    .multiTexCoord2sv = true,
    .multiTexCoord3d = true,
    .multiTexCoord3dv = true,
    .multiTexCoord3f = true,
    .multiTexCoord3fv = true,
    .multiTexCoord3i = true,
    .multiTexCoord3iv = true,
    .multiTexCoord3s = true,
    .multiTexCoord3sv = true,
    .multiTexCoord4d = true,
    .multiTexCoord4dv = true,
    .multiTexCoord4f = true,
    .multiTexCoord4fv = true,
    .multiTexCoord4i = true,
    .multiTexCoord4iv = true,
    .multiTexCoord4s = true,
    .multiTexCoord4sv = true,
    .loadTransposeMatrixf = true,
    .loadTransposeMatrixd = true,
    .multTransposeMatrixf = true,
    .multTransposeMatrixd = true,
    .blendFuncSeparate = true,
    .multiDrawArrays = true,
    .multiDrawElements = true,
    .pointParameterf = true,
    .pointParameterfv = true,
    .pointParameteri = true,
    .pointParameteriv = true,
    .fogCoordf = true,
    .fogCoordfv = true,
    .fogCoordd = true,
    .fogCoorddv = true,
    .fogCoordPointer = true,
    .secondaryColor3b = true,
    .secondaryColor3bv = true,
    .secondaryColor3d = true,
    .secondaryColor3dv = true,
    .secondaryColor3f = true,
    .secondaryColor3fv = true,
    .secondaryColor3i = true,
    .secondaryColor3iv = true,
    .secondaryColor3s = true,
    .secondaryColor3sv = true,
    .secondaryColor3ub = true,
    .secondaryColor3ubv = true,
    .secondaryColor3ui = true,
    .secondaryColor3uiv = true,
    .secondaryColor3us = true,
    .secondaryColor3usv = true,
    .secondaryColorPointer = true,
    .windowPos2d = true,
    .windowPos2dv = true,
    .windowPos2f = true,
    .windowPos2fv = true,
    .windowPos2i = true,
    .windowPos2iv = true,
    .windowPos2s = true,
    .windowPos2sv = true,
    .windowPos3d = true,
    .windowPos3dv = true,
    .windowPos3f = true,
    .windowPos3fv = true,
    .windowPos3i = true,
    .windowPos3iv = true,
    .windowPos3s = true,
    .windowPos3sv = true,
    .blendColor = true,
    .blendEquation = true,
    .genQueries = true,
    .deleteQueries = true,
    .isQuery = true,
    .beginQuery = true,
    .endQuery = true,
    .getQueryiv = true,
    .getQueryObjectiv = true,
    .getQueryObjectuiv = true,
    .bindBuffer = true,
    .deleteBuffers = true,
    .genBuffers = true,
    .isBuffer = true,
    .bufferData = true,
    .bufferSubData = true,
    .getBufferSubData = true,
    .mapBuffer = true,
    .unmapBuffer = true,
    .getBufferParameteriv = true,
    .getBufferPointerv = true,
    .blendEquationSeparate = true,
    .drawBuffers = true,
    .stencilOpSeparate = true,
    .stencilFuncSeparate = true,
    .stencilMaskSeparate = true,
    .attachShader = true,
    .bindAttribLocation = true,
    .compileShader = true,
    .createProgram = true,
    .createShader = true,
    .deleteProgram = true,
    .deleteShader = true,
    .detachShader = true,
    .disableVertexAttribArray = true,
    .enableVertexAttribArray = true,
    .getActiveAttrib = true,
    .getActiveUniform = true,
    .getAttachedShaders = true,
    .getAttribLocation = true,
    .getProgramiv = true,
    .getProgramInfoLog = true,
    .getShaderiv = true,
    .getShaderInfoLog = true,
    .getShaderSource = true,
    .getUniformLocation = true,
    .getUniformfv = true,
    .getUniformiv = true,
    .getVertexAttribdv = true,
    .getVertexAttribfv = true,
    .getVertexAttribiv = true,
    .getVertexAttribPointerv = true,
    .isProgram = true,
    .isShader = true,
    .linkProgram = true,
    .shaderSource = true,
    .useProgram = true,
    .uniform1f = true,
    .uniform2f = true,
    .uniform3f = true,
    .uniform4f = true,
    .uniform1i = true,
    .uniform2i = true,
    .uniform3i = true,
    .uniform4i = true,
    .uniform1fv = true,
    .uniform2fv = true,
    .uniform3fv = true,
    .uniform4fv = true,
    .uniform1iv = true,
    .uniform2iv = true,
    .uniform3iv = true,
    .uniform4iv = true,
    .uniformMatrix2fv = true,
    .uniformMatrix3fv = true,
    .uniformMatrix4fv = true,
    .validateProgram = true,
    .vertexAttrib1d = true,
    .vertexAttrib1dv = true,
    .vertexAttrib1f = true,
    .vertexAttrib1fv = true,
    .vertexAttrib1s = true,
    .vertexAttrib1sv = true,
    .vertexAttrib2d = true,
    .vertexAttrib2dv = true,
    .vertexAttrib2f = true,
    .vertexAttrib2fv = true,
    .vertexAttrib2s = true,
    .vertexAttrib2sv = true,
    .vertexAttrib3d = true,
    .vertexAttrib3dv = true,
    .vertexAttrib3f = true,
    .vertexAttrib3fv = true,
    .vertexAttrib3s = true,
    .vertexAttrib3sv = true,
    .vertexAttrib4Nbv = true,
    .vertexAttrib4Niv = true,
    .vertexAttrib4Nsv = true,
    .vertexAttrib4Nub = true,
    .vertexAttrib4Nubv = true,
    .vertexAttrib4Nuiv = true,
    .vertexAttrib4Nusv = true,
    .vertexAttrib4bv = true,
    .vertexAttrib4d = true,
    .vertexAttrib4dv = true,
    .vertexAttrib4f = true,
    .vertexAttrib4fv = true,
    .vertexAttrib4iv = true,
    .vertexAttrib4s = true,
    .vertexAttrib4sv = true,
    .vertexAttrib4ubv = true,
    .vertexAttrib4uiv = true,
    .vertexAttrib4usv = true,
    .vertexAttribPointer = true,
    .uniformMatrix2x3fv = true,
    .uniformMatrix3x2fv = true,
    .uniformMatrix2x4fv = true,
    .uniformMatrix4x2fv = true,
    .uniformMatrix3x4fv = true,
    .uniformMatrix4x3fv = true,
    .colorMaski = true,
    .getBooleani_v = true,
    .getIntegeri_v = true,
    .enablei = true,
    .disablei = true,
    .isEnabledi = true,
    .beginTransformFeedback = true,
    .endTransformFeedback = true,
    .bindBufferRange = true,
    .bindBufferBase = true,
    .transformFeedbackVaryings = true,
    .getTransformFeedbackVarying = true,
    .clampColor = true,
    .beginConditionalRender = true,
    .endConditionalRender = true,
    .vertexAttribIPointer = true,
    .getVertexAttribIiv = true,
    .getVertexAttribIuiv = true,
    .vertexAttribI1i = true,
    .vertexAttribI2i = true,
    .vertexAttribI3i = true,
    .vertexAttribI4i = true,
    .vertexAttribI1ui = true,
    .vertexAttribI2ui = true,
    .vertexAttribI3ui = true,
    .vertexAttribI4ui = true,
    .vertexAttribI1iv = true,
    .vertexAttribI2iv = true,
    .vertexAttribI3iv = true,
    .vertexAttribI4iv = true,
    .vertexAttribI1uiv = true,
    .vertexAttribI2uiv = true,
    .vertexAttribI3uiv = true,
    .vertexAttribI4uiv = true,
    .vertexAttribI4bv = true,
    .vertexAttribI4sv = true,
    .vertexAttribI4ubv = true,
    .vertexAttribI4usv = true,
    .getUniformuiv = true,
    .bindFragDataLocation = true,
    .getFragDataLocation = true,
    .uniform1ui = true,
    .uniform2ui = true,
    .uniform3ui = true,
    .uniform4ui = true,
    .uniform1uiv = true,
    .uniform2uiv = true,
    .uniform3uiv = true,
    .uniform4uiv = true,
    .texParameterIiv = true,
    .texParameterIuiv = true,
    .getTexParameterIiv = true,
    .getTexParameterIuiv = true,
    .clearBufferiv = true,
    .clearBufferuiv = true,
    .clearBufferfv = true,
    .clearBufferfi = true,
    .getStringi = true,
    .isRenderbuffer = true,
    .bindRenderbuffer = true,
    .deleteRenderbuffers = true,
    .genRenderbuffers = true,
    .renderbufferStorage = true,
    .getRenderbufferParameteriv = true,
    .isFramebuffer = true,
    .bindFramebuffer = true,
    .deleteFramebuffers = true,
    .genFramebuffers = true,
    .checkFramebufferStatus = true,
    .framebufferTexture1D = true,
    .framebufferTexture2D = true,
    .framebufferTexture3D = true,
    .framebufferRenderbuffer = true,
    .getFramebufferAttachmentParameteriv = true,
    .generateMipmap = true,
    .blitFramebuffer = true,
    .renderbufferStorageMultisample = true,
    .framebufferTextureLayer = true,
    .mapBufferRange = true,
    .flushMappedBufferRange = true,
    .bindVertexArray = true,
    .deleteVertexArrays = true,
    .genVertexArrays = true,
    .isVertexArray = true,
    .drawArraysInstanced = true,
    .drawElementsInstanced = true,
    .texBuffer = true,
    .primitiveRestartIndex = true,
    .copyBufferSubData = true,
    .getUniformIndices = true,
    .getActiveUniformsiv = true,
    .getActiveUniformName = true,
    .getUniformBlockIndex = true,
    .getActiveUniformBlockiv = true,
    .getActiveUniformBlockName = true,
    .uniformBlockBinding = true,
    .drawElementsBaseVertex = true,
    .drawRangeElementsBaseVertex = true,
    .drawElementsInstancedBaseVertex = true,
    .multiDrawElementsBaseVertex = true,
    .provokingVertex = true,
    .fenceSync = true,
    .isSync = true,
    .deleteSync = true,
    .clientWaitSync = true,
    .waitSync = true,
    .getInteger64v = true,
    .getSynciv = true,
    .getInteger64i_v = true,
    .getBufferParameteri64v = true,
    .framebufferTexture = true,
    .texImage2DMultisample = true,
    .texImage3DMultisample = true,
    .getMultisamplefv = true,
    .sampleMaski = true,
    .bindFragDataLocationIndexed = true,
    .getFragDataIndex = true,
    .genSamplers = true,
    .deleteSamplers = true,
    .isSampler = true,
    .bindSampler = true,
    .samplerParameteri = true,
    .samplerParameteriv = true,
    .samplerParameterf = true,
    .samplerParameterfv = true,
    .samplerParameterIiv = true,
    .samplerParameterIuiv = true,
    .getSamplerParameteriv = true,
    .getSamplerParameterIiv = true,
    .getSamplerParameterfv = true,
    .getSamplerParameterIuiv = true,
    .queryCounter = true,
    .getQueryObjecti64v = true,
    .getQueryObjectui64v = true,
    .vertexAttribDivisor = true,
    .vertexAttribP1ui = true,
    .vertexAttribP1uiv = true,
    .vertexAttribP2ui = true,
    .vertexAttribP2uiv = true,
    .vertexAttribP3ui = true,
    .vertexAttribP3uiv = true,
    .vertexAttribP4ui = true,
    .vertexAttribP4uiv = true,
    .vertexP2ui = true,
    .vertexP2uiv = true,
    .vertexP3ui = true,
    .vertexP3uiv = true,
    .vertexP4ui = true,
    .vertexP4uiv = true,
    .texCoordP1ui = true,
    .texCoordP1uiv = true,
    .texCoordP2ui = true,
    .texCoordP2uiv = true,
    .texCoordP3ui = true,
    .texCoordP3uiv = true,
    .texCoordP4ui = true,
    .texCoordP4uiv = true,
    .multiTexCoordP1ui = true,
    .multiTexCoordP1uiv = true,
    .multiTexCoordP2ui = true,
    .multiTexCoordP2uiv = true,
    .multiTexCoordP3ui = true,
    .multiTexCoordP3uiv = true,
    .multiTexCoordP4ui = true,
    .multiTexCoordP4uiv = true,
    .normalP3ui = true,
    .normalP3uiv = true,
    .colorP3ui = true,
    .colorP3uiv = true,
    .colorP4ui = true,
    .colorP4uiv = true,
    .secondaryColorP3ui = true,
    .secondaryColorP3uiv = true,
};

pub const gl40 = CommandFlags{
    .cullFace = true,
    .frontFace = true,
    .hint = true,
    .lineWidth = true,
    .pointSize = true,
    .polygonMode = true,
    .scissor = true,
    .texParameterf = true,
    .texParameterfv = true,
    .texParameteri = true,
    .texParameteriv = true,
    .texImage1D = true,
    .texImage2D = true,
    .drawBuffer = true,
    .clear = true,
    .clearColor = true,
    .clearStencil = true,
    .clearDepth = true,
    .stencilMask = true,
    .colorMask = true,
    .depthMask = true,
    .disable = true,
    .enable = true,
    .finish = true,
    .flush = true,
    .blendFunc = true,
    .logicOp = true,
    .stencilFunc = true,
    .stencilOp = true,
    .depthFunc = true,
    .pixelStoref = true,
    .pixelStorei = true,
    .readBuffer = true,
    .readPixels = true,
    .getBooleanv = true,
    .getDoublev = true,
    .getError = true,
    .getFloatv = true,
    .getIntegerv = true,
    .getString = true,
    .getTexImage = true,
    .getTexParameterfv = true,
    .getTexParameteriv = true,
    .getTexLevelParameterfv = true,
    .getTexLevelParameteriv = true,
    .isEnabled = true,
    .depthRange = true,
    .viewport = true,
    .newList = true,
    .endList = true,
    .callList = true,
    .callLists = true,
    .deleteLists = true,
    .genLists = true,
    .listBase = true,
    .begin = true,
    .bitmap = true,
    .color3b = true,
    .color3bv = true,
    .color3d = true,
    .color3dv = true,
    .color3f = true,
    .color3fv = true,
    .color3i = true,
    .color3iv = true,
    .color3s = true,
    .color3sv = true,
    .color3ub = true,
    .color3ubv = true,
    .color3ui = true,
    .color3uiv = true,
    .color3us = true,
    .color3usv = true,
    .color4b = true,
    .color4bv = true,
    .color4d = true,
    .color4dv = true,
    .color4f = true,
    .color4fv = true,
    .color4i = true,
    .color4iv = true,
    .color4s = true,
    .color4sv = true,
    .color4ub = true,
    .color4ubv = true,
    .color4ui = true,
    .color4uiv = true,
    .color4us = true,
    .color4usv = true,
    .edgeFlag = true,
    .edgeFlagv = true,
    .end = true,
    .indexd = true,
    .indexdv = true,
    .indexf = true,
    .indexfv = true,
    .indexi = true,
    .indexiv = true,
    .indexs = true,
    .indexsv = true,
    .normal3b = true,
    .normal3bv = true,
    .normal3d = true,
    .normal3dv = true,
    .normal3f = true,
    .normal3fv = true,
    .normal3i = true,
    .normal3iv = true,
    .normal3s = true,
    .normal3sv = true,
    .rasterPos2d = true,
    .rasterPos2dv = true,
    .rasterPos2f = true,
    .rasterPos2fv = true,
    .rasterPos2i = true,
    .rasterPos2iv = true,
    .rasterPos2s = true,
    .rasterPos2sv = true,
    .rasterPos3d = true,
    .rasterPos3dv = true,
    .rasterPos3f = true,
    .rasterPos3fv = true,
    .rasterPos3i = true,
    .rasterPos3iv = true,
    .rasterPos3s = true,
    .rasterPos3sv = true,
    .rasterPos4d = true,
    .rasterPos4dv = true,
    .rasterPos4f = true,
    .rasterPos4fv = true,
    .rasterPos4i = true,
    .rasterPos4iv = true,
    .rasterPos4s = true,
    .rasterPos4sv = true,
    .rectd = true,
    .rectdv = true,
    .rectf = true,
    .rectfv = true,
    .recti = true,
    .rectiv = true,
    .rects = true,
    .rectsv = true,
    .texCoord1d = true,
    .texCoord1dv = true,
    .texCoord1f = true,
    .texCoord1fv = true,
    .texCoord1i = true,
    .texCoord1iv = true,
    .texCoord1s = true,
    .texCoord1sv = true,
    .texCoord2d = true,
    .texCoord2dv = true,
    .texCoord2f = true,
    .texCoord2fv = true,
    .texCoord2i = true,
    .texCoord2iv = true,
    .texCoord2s = true,
    .texCoord2sv = true,
    .texCoord3d = true,
    .texCoord3dv = true,
    .texCoord3f = true,
    .texCoord3fv = true,
    .texCoord3i = true,
    .texCoord3iv = true,
    .texCoord3s = true,
    .texCoord3sv = true,
    .texCoord4d = true,
    .texCoord4dv = true,
    .texCoord4f = true,
    .texCoord4fv = true,
    .texCoord4i = true,
    .texCoord4iv = true,
    .texCoord4s = true,
    .texCoord4sv = true,
    .vertex2d = true,
    .vertex2dv = true,
    .vertex2f = true,
    .vertex2fv = true,
    .vertex2i = true,
    .vertex2iv = true,
    .vertex2s = true,
    .vertex2sv = true,
    .vertex3d = true,
    .vertex3dv = true,
    .vertex3f = true,
    .vertex3fv = true,
    .vertex3i = true,
    .vertex3iv = true,
    .vertex3s = true,
    .vertex3sv = true,
    .vertex4d = true,
    .vertex4dv = true,
    .vertex4f = true,
    .vertex4fv = true,
    .vertex4i = true,
    .vertex4iv = true,
    .vertex4s = true,
    .vertex4sv = true,
    .clipPlane = true,
    .colorMaterial = true,
    .fogf = true,
    .fogfv = true,
    .fogi = true,
    .fogiv = true,
    .lightf = true,
    .lightfv = true,
    .lighti = true,
    .lightiv = true,
    .lightModelf = true,
    .lightModelfv = true,
    .lightModeli = true,
    .lightModeliv = true,
    .lineStipple = true,
    .materialf = true,
    .materialfv = true,
    .materiali = true,
    .materialiv = true,
    .polygonStipple = true,
    .shadeModel = true,
    .texEnvf = true,
    .texEnvfv = true,
    .texEnvi = true,
    .texEnviv = true,
    .texGend = true,
    .texGendv = true,
    .texGenf = true,
    .texGenfv = true,
    .texGeni = true,
    .texGeniv = true,
    .feedbackBuffer = true,
    .selectBuffer = true,
    .renderMode = true,
    .initNames = true,
    .loadName = true,
    .passThrough = true,
    .popName = true,
    .pushName = true,
    .clearAccum = true,
    .clearIndex = true,
    .indexMask = true,
    .accum = true,
    .popAttrib = true,
    .pushAttrib = true,
    .map1d = true,
    .map1f = true,
    .map2d = true,
    .map2f = true,
    .mapGrid1d = true,
    .mapGrid1f = true,
    .mapGrid2d = true,
    .mapGrid2f = true,
    .evalCoord1d = true,
    .evalCoord1dv = true,
    .evalCoord1f = true,
    .evalCoord1fv = true,
    .evalCoord2d = true,
    .evalCoord2dv = true,
    .evalCoord2f = true,
    .evalCoord2fv = true,
    .evalMesh1 = true,
    .evalPoint1 = true,
    .evalMesh2 = true,
    .evalPoint2 = true,
    .alphaFunc = true,
    .pixelZoom = true,
    .pixelTransferf = true,
    .pixelTransferi = true,
    .pixelMapfv = true,
    .pixelMapuiv = true,
    .pixelMapusv = true,
    .copyPixels = true,
    .drawPixels = true,
    .getClipPlane = true,
    .getLightfv = true,
    .getLightiv = true,
    .getMapdv = true,
    .getMapfv = true,
    .getMapiv = true,
    .getMaterialfv = true,
    .getMaterialiv = true,
    .getPixelMapfv = true,
    .getPixelMapuiv = true,
    .getPixelMapusv = true,
    .getPolygonStipple = true,
    .getTexEnvfv = true,
    .getTexEnviv = true,
    .getTexGendv = true,
    .getTexGenfv = true,
    .getTexGeniv = true,
    .isList = true,
    .frustum = true,
    .loadIdentity = true,
    .loadMatrixf = true,
    .loadMatrixd = true,
    .matrixMode = true,
    .multMatrixf = true,
    .multMatrixd = true,
    .ortho = true,
    .popMatrix = true,
    .pushMatrix = true,
    .rotated = true,
    .rotatef = true,
    .scaled = true,
    .scalef = true,
    .translated = true,
    .translatef = true,
    .drawArrays = true,
    .drawElements = true,
    .getPointerv = true,
    .polygonOffset = true,
    .copyTexImage1D = true,
    .copyTexImage2D = true,
    .copyTexSubImage1D = true,
    .copyTexSubImage2D = true,
    .texSubImage1D = true,
    .texSubImage2D = true,
    .bindTexture = true,
    .deleteTextures = true,
    .genTextures = true,
    .isTexture = true,
    .arrayElement = true,
    .colorPointer = true,
    .disableClientState = true,
    .edgeFlagPointer = true,
    .enableClientState = true,
    .indexPointer = true,
    .interleavedArrays = true,
    .normalPointer = true,
    .texCoordPointer = true,
    .vertexPointer = true,
    .areTexturesResident = true,
    .prioritizeTextures = true,
    .indexub = true,
    .indexubv = true,
    .popClientAttrib = true,
    .pushClientAttrib = true,
    .drawRangeElements = true,
    .texImage3D = true,
    .texSubImage3D = true,
    .copyTexSubImage3D = true,
    .activeTexture = true,
    .sampleCoverage = true,
    .compressedTexImage3D = true,
    .compressedTexImage2D = true,
    .compressedTexImage1D = true,
    .compressedTexSubImage3D = true,
    .compressedTexSubImage2D = true,
    .compressedTexSubImage1D = true,
    .getCompressedTexImage = true,
    .clientActiveTexture = true,
    .multiTexCoord1d = true,
    .multiTexCoord1dv = true,
    .multiTexCoord1f = true,
    .multiTexCoord1fv = true,
    .multiTexCoord1i = true,
    .multiTexCoord1iv = true,
    .multiTexCoord1s = true,
    .multiTexCoord1sv = true,
    .multiTexCoord2d = true,
    .multiTexCoord2dv = true,
    .multiTexCoord2f = true,
    .multiTexCoord2fv = true,
    .multiTexCoord2i = true,
    .multiTexCoord2iv = true,
    .multiTexCoord2s = true,
    .multiTexCoord2sv = true,
    .multiTexCoord3d = true,
    .multiTexCoord3dv = true,
    .multiTexCoord3f = true,
    .multiTexCoord3fv = true,
    .multiTexCoord3i = true,
    .multiTexCoord3iv = true,
    .multiTexCoord3s = true,
    .multiTexCoord3sv = true,
    .multiTexCoord4d = true,
    .multiTexCoord4dv = true,
    .multiTexCoord4f = true,
    .multiTexCoord4fv = true,
    .multiTexCoord4i = true,
    .multiTexCoord4iv = true,
    .multiTexCoord4s = true,
    .multiTexCoord4sv = true,
    .loadTransposeMatrixf = true,
    .loadTransposeMatrixd = true,
    .multTransposeMatrixf = true,
    .multTransposeMatrixd = true,
    .blendFuncSeparate = true,
    .multiDrawArrays = true,
    .multiDrawElements = true,
    .pointParameterf = true,
    .pointParameterfv = true,
    .pointParameteri = true,
    .pointParameteriv = true,
    .fogCoordf = true,
    .fogCoordfv = true,
    .fogCoordd = true,
    .fogCoorddv = true,
    .fogCoordPointer = true,
    .secondaryColor3b = true,
    .secondaryColor3bv = true,
    .secondaryColor3d = true,
    .secondaryColor3dv = true,
    .secondaryColor3f = true,
    .secondaryColor3fv = true,
    .secondaryColor3i = true,
    .secondaryColor3iv = true,
    .secondaryColor3s = true,
    .secondaryColor3sv = true,
    .secondaryColor3ub = true,
    .secondaryColor3ubv = true,
    .secondaryColor3ui = true,
    .secondaryColor3uiv = true,
    .secondaryColor3us = true,
    .secondaryColor3usv = true,
    .secondaryColorPointer = true,
    .windowPos2d = true,
    .windowPos2dv = true,
    .windowPos2f = true,
    .windowPos2fv = true,
    .windowPos2i = true,
    .windowPos2iv = true,
    .windowPos2s = true,
    .windowPos2sv = true,
    .windowPos3d = true,
    .windowPos3dv = true,
    .windowPos3f = true,
    .windowPos3fv = true,
    .windowPos3i = true,
    .windowPos3iv = true,
    .windowPos3s = true,
    .windowPos3sv = true,
    .blendColor = true,
    .blendEquation = true,
    .genQueries = true,
    .deleteQueries = true,
    .isQuery = true,
    .beginQuery = true,
    .endQuery = true,
    .getQueryiv = true,
    .getQueryObjectiv = true,
    .getQueryObjectuiv = true,
    .bindBuffer = true,
    .deleteBuffers = true,
    .genBuffers = true,
    .isBuffer = true,
    .bufferData = true,
    .bufferSubData = true,
    .getBufferSubData = true,
    .mapBuffer = true,
    .unmapBuffer = true,
    .getBufferParameteriv = true,
    .getBufferPointerv = true,
    .blendEquationSeparate = true,
    .drawBuffers = true,
    .stencilOpSeparate = true,
    .stencilFuncSeparate = true,
    .stencilMaskSeparate = true,
    .attachShader = true,
    .bindAttribLocation = true,
    .compileShader = true,
    .createProgram = true,
    .createShader = true,
    .deleteProgram = true,
    .deleteShader = true,
    .detachShader = true,
    .disableVertexAttribArray = true,
    .enableVertexAttribArray = true,
    .getActiveAttrib = true,
    .getActiveUniform = true,
    .getAttachedShaders = true,
    .getAttribLocation = true,
    .getProgramiv = true,
    .getProgramInfoLog = true,
    .getShaderiv = true,
    .getShaderInfoLog = true,
    .getShaderSource = true,
    .getUniformLocation = true,
    .getUniformfv = true,
    .getUniformiv = true,
    .getVertexAttribdv = true,
    .getVertexAttribfv = true,
    .getVertexAttribiv = true,
    .getVertexAttribPointerv = true,
    .isProgram = true,
    .isShader = true,
    .linkProgram = true,
    .shaderSource = true,
    .useProgram = true,
    .uniform1f = true,
    .uniform2f = true,
    .uniform3f = true,
    .uniform4f = true,
    .uniform1i = true,
    .uniform2i = true,
    .uniform3i = true,
    .uniform4i = true,
    .uniform1fv = true,
    .uniform2fv = true,
    .uniform3fv = true,
    .uniform4fv = true,
    .uniform1iv = true,
    .uniform2iv = true,
    .uniform3iv = true,
    .uniform4iv = true,
    .uniformMatrix2fv = true,
    .uniformMatrix3fv = true,
    .uniformMatrix4fv = true,
    .validateProgram = true,
    .vertexAttrib1d = true,
    .vertexAttrib1dv = true,
    .vertexAttrib1f = true,
    .vertexAttrib1fv = true,
    .vertexAttrib1s = true,
    .vertexAttrib1sv = true,
    .vertexAttrib2d = true,
    .vertexAttrib2dv = true,
    .vertexAttrib2f = true,
    .vertexAttrib2fv = true,
    .vertexAttrib2s = true,
    .vertexAttrib2sv = true,
    .vertexAttrib3d = true,
    .vertexAttrib3dv = true,
    .vertexAttrib3f = true,
    .vertexAttrib3fv = true,
    .vertexAttrib3s = true,
    .vertexAttrib3sv = true,
    .vertexAttrib4Nbv = true,
    .vertexAttrib4Niv = true,
    .vertexAttrib4Nsv = true,
    .vertexAttrib4Nub = true,
    .vertexAttrib4Nubv = true,
    .vertexAttrib4Nuiv = true,
    .vertexAttrib4Nusv = true,
    .vertexAttrib4bv = true,
    .vertexAttrib4d = true,
    .vertexAttrib4dv = true,
    .vertexAttrib4f = true,
    .vertexAttrib4fv = true,
    .vertexAttrib4iv = true,
    .vertexAttrib4s = true,
    .vertexAttrib4sv = true,
    .vertexAttrib4ubv = true,
    .vertexAttrib4uiv = true,
    .vertexAttrib4usv = true,
    .vertexAttribPointer = true,
    .uniformMatrix2x3fv = true,
    .uniformMatrix3x2fv = true,
    .uniformMatrix2x4fv = true,
    .uniformMatrix4x2fv = true,
    .uniformMatrix3x4fv = true,
    .uniformMatrix4x3fv = true,
    .colorMaski = true,
    .getBooleani_v = true,
    .getIntegeri_v = true,
    .enablei = true,
    .disablei = true,
    .isEnabledi = true,
    .beginTransformFeedback = true,
    .endTransformFeedback = true,
    .bindBufferRange = true,
    .bindBufferBase = true,
    .transformFeedbackVaryings = true,
    .getTransformFeedbackVarying = true,
    .clampColor = true,
    .beginConditionalRender = true,
    .endConditionalRender = true,
    .vertexAttribIPointer = true,
    .getVertexAttribIiv = true,
    .getVertexAttribIuiv = true,
    .vertexAttribI1i = true,
    .vertexAttribI2i = true,
    .vertexAttribI3i = true,
    .vertexAttribI4i = true,
    .vertexAttribI1ui = true,
    .vertexAttribI2ui = true,
    .vertexAttribI3ui = true,
    .vertexAttribI4ui = true,
    .vertexAttribI1iv = true,
    .vertexAttribI2iv = true,
    .vertexAttribI3iv = true,
    .vertexAttribI4iv = true,
    .vertexAttribI1uiv = true,
    .vertexAttribI2uiv = true,
    .vertexAttribI3uiv = true,
    .vertexAttribI4uiv = true,
    .vertexAttribI4bv = true,
    .vertexAttribI4sv = true,
    .vertexAttribI4ubv = true,
    .vertexAttribI4usv = true,
    .getUniformuiv = true,
    .bindFragDataLocation = true,
    .getFragDataLocation = true,
    .uniform1ui = true,
    .uniform2ui = true,
    .uniform3ui = true,
    .uniform4ui = true,
    .uniform1uiv = true,
    .uniform2uiv = true,
    .uniform3uiv = true,
    .uniform4uiv = true,
    .texParameterIiv = true,
    .texParameterIuiv = true,
    .getTexParameterIiv = true,
    .getTexParameterIuiv = true,
    .clearBufferiv = true,
    .clearBufferuiv = true,
    .clearBufferfv = true,
    .clearBufferfi = true,
    .getStringi = true,
    .isRenderbuffer = true,
    .bindRenderbuffer = true,
    .deleteRenderbuffers = true,
    .genRenderbuffers = true,
    .renderbufferStorage = true,
    .getRenderbufferParameteriv = true,
    .isFramebuffer = true,
    .bindFramebuffer = true,
    .deleteFramebuffers = true,
    .genFramebuffers = true,
    .checkFramebufferStatus = true,
    .framebufferTexture1D = true,
    .framebufferTexture2D = true,
    .framebufferTexture3D = true,
    .framebufferRenderbuffer = true,
    .getFramebufferAttachmentParameteriv = true,
    .generateMipmap = true,
    .blitFramebuffer = true,
    .renderbufferStorageMultisample = true,
    .framebufferTextureLayer = true,
    .mapBufferRange = true,
    .flushMappedBufferRange = true,
    .bindVertexArray = true,
    .deleteVertexArrays = true,
    .genVertexArrays = true,
    .isVertexArray = true,
    .drawArraysInstanced = true,
    .drawElementsInstanced = true,
    .texBuffer = true,
    .primitiveRestartIndex = true,
    .copyBufferSubData = true,
    .getUniformIndices = true,
    .getActiveUniformsiv = true,
    .getActiveUniformName = true,
    .getUniformBlockIndex = true,
    .getActiveUniformBlockiv = true,
    .getActiveUniformBlockName = true,
    .uniformBlockBinding = true,
    .drawElementsBaseVertex = true,
    .drawRangeElementsBaseVertex = true,
    .drawElementsInstancedBaseVertex = true,
    .multiDrawElementsBaseVertex = true,
    .provokingVertex = true,
    .fenceSync = true,
    .isSync = true,
    .deleteSync = true,
    .clientWaitSync = true,
    .waitSync = true,
    .getInteger64v = true,
    .getSynciv = true,
    .getInteger64i_v = true,
    .getBufferParameteri64v = true,
    .framebufferTexture = true,
    .texImage2DMultisample = true,
    .texImage3DMultisample = true,
    .getMultisamplefv = true,
    .sampleMaski = true,
    .bindFragDataLocationIndexed = true,
    .getFragDataIndex = true,
    .genSamplers = true,
    .deleteSamplers = true,
    .isSampler = true,
    .bindSampler = true,
    .samplerParameteri = true,
    .samplerParameteriv = true,
    .samplerParameterf = true,
    .samplerParameterfv = true,
    .samplerParameterIiv = true,
    .samplerParameterIuiv = true,
    .getSamplerParameteriv = true,
    .getSamplerParameterIiv = true,
    .getSamplerParameterfv = true,
    .getSamplerParameterIuiv = true,
    .queryCounter = true,
    .getQueryObjecti64v = true,
    .getQueryObjectui64v = true,
    .vertexAttribDivisor = true,
    .vertexAttribP1ui = true,
    .vertexAttribP1uiv = true,
    .vertexAttribP2ui = true,
    .vertexAttribP2uiv = true,
    .vertexAttribP3ui = true,
    .vertexAttribP3uiv = true,
    .vertexAttribP4ui = true,
    .vertexAttribP4uiv = true,
    .vertexP2ui = true,
    .vertexP2uiv = true,
    .vertexP3ui = true,
    .vertexP3uiv = true,
    .vertexP4ui = true,
    .vertexP4uiv = true,
    .texCoordP1ui = true,
    .texCoordP1uiv = true,
    .texCoordP2ui = true,
    .texCoordP2uiv = true,
    .texCoordP3ui = true,
    .texCoordP3uiv = true,
    .texCoordP4ui = true,
    .texCoordP4uiv = true,
    .multiTexCoordP1ui = true,
    .multiTexCoordP1uiv = true,
    .multiTexCoordP2ui = true,
    .multiTexCoordP2uiv = true,
    .multiTexCoordP3ui = true,
    .multiTexCoordP3uiv = true,
    .multiTexCoordP4ui = true,
    .multiTexCoordP4uiv = true,
    .normalP3ui = true,
    .normalP3uiv = true,
    .colorP3ui = true,
    .colorP3uiv = true,
    .colorP4ui = true,
    .colorP4uiv = true,
    .secondaryColorP3ui = true,
    .secondaryColorP3uiv = true,
    .minSampleShading = true,
    .blendEquationi = true,
    .blendEquationSeparatei = true,
    .blendFunci = true,
    .blendFuncSeparatei = true,
    .drawArraysIndirect = true,
    .drawElementsIndirect = true,
    .uniform1d = true,
    .uniform2d = true,
    .uniform3d = true,
    .uniform4d = true,
    .uniform1dv = true,
    .uniform2dv = true,
    .uniform3dv = true,
    .uniform4dv = true,
    .uniformMatrix2dv = true,
    .uniformMatrix3dv = true,
    .uniformMatrix4dv = true,
    .uniformMatrix2x3dv = true,
    .uniformMatrix2x4dv = true,
    .uniformMatrix3x2dv = true,
    .uniformMatrix3x4dv = true,
    .uniformMatrix4x2dv = true,
    .uniformMatrix4x3dv = true,
    .getUniformdv = true,
    .getSubroutineUniformLocation = true,
    .getSubroutineIndex = true,
    .getActiveSubroutineUniformiv = true,
    .getActiveSubroutineUniformName = true,
    .getActiveSubroutineName = true,
    .uniformSubroutinesuiv = true,
    .getUniformSubroutineuiv = true,
    .getProgramStageiv = true,
    .patchParameteri = true,
    .patchParameterfv = true,
    .bindTransformFeedback = true,
    .deleteTransformFeedbacks = true,
    .genTransformFeedbacks = true,
    .isTransformFeedback = true,
    .pauseTransformFeedback = true,
    .resumeTransformFeedback = true,
    .drawTransformFeedback = true,
    .drawTransformFeedbackStream = true,
    .beginQueryIndexed = true,
    .endQueryIndexed = true,
    .getQueryIndexediv = true,
};

pub const gl41 = CommandFlags{
    .cullFace = true,
    .frontFace = true,
    .hint = true,
    .lineWidth = true,
    .pointSize = true,
    .polygonMode = true,
    .scissor = true,
    .texParameterf = true,
    .texParameterfv = true,
    .texParameteri = true,
    .texParameteriv = true,
    .texImage1D = true,
    .texImage2D = true,
    .drawBuffer = true,
    .clear = true,
    .clearColor = true,
    .clearStencil = true,
    .clearDepth = true,
    .stencilMask = true,
    .colorMask = true,
    .depthMask = true,
    .disable = true,
    .enable = true,
    .finish = true,
    .flush = true,
    .blendFunc = true,
    .logicOp = true,
    .stencilFunc = true,
    .stencilOp = true,
    .depthFunc = true,
    .pixelStoref = true,
    .pixelStorei = true,
    .readBuffer = true,
    .readPixels = true,
    .getBooleanv = true,
    .getDoublev = true,
    .getError = true,
    .getFloatv = true,
    .getIntegerv = true,
    .getString = true,
    .getTexImage = true,
    .getTexParameterfv = true,
    .getTexParameteriv = true,
    .getTexLevelParameterfv = true,
    .getTexLevelParameteriv = true,
    .isEnabled = true,
    .depthRange = true,
    .viewport = true,
    .newList = true,
    .endList = true,
    .callList = true,
    .callLists = true,
    .deleteLists = true,
    .genLists = true,
    .listBase = true,
    .begin = true,
    .bitmap = true,
    .color3b = true,
    .color3bv = true,
    .color3d = true,
    .color3dv = true,
    .color3f = true,
    .color3fv = true,
    .color3i = true,
    .color3iv = true,
    .color3s = true,
    .color3sv = true,
    .color3ub = true,
    .color3ubv = true,
    .color3ui = true,
    .color3uiv = true,
    .color3us = true,
    .color3usv = true,
    .color4b = true,
    .color4bv = true,
    .color4d = true,
    .color4dv = true,
    .color4f = true,
    .color4fv = true,
    .color4i = true,
    .color4iv = true,
    .color4s = true,
    .color4sv = true,
    .color4ub = true,
    .color4ubv = true,
    .color4ui = true,
    .color4uiv = true,
    .color4us = true,
    .color4usv = true,
    .edgeFlag = true,
    .edgeFlagv = true,
    .end = true,
    .indexd = true,
    .indexdv = true,
    .indexf = true,
    .indexfv = true,
    .indexi = true,
    .indexiv = true,
    .indexs = true,
    .indexsv = true,
    .normal3b = true,
    .normal3bv = true,
    .normal3d = true,
    .normal3dv = true,
    .normal3f = true,
    .normal3fv = true,
    .normal3i = true,
    .normal3iv = true,
    .normal3s = true,
    .normal3sv = true,
    .rasterPos2d = true,
    .rasterPos2dv = true,
    .rasterPos2f = true,
    .rasterPos2fv = true,
    .rasterPos2i = true,
    .rasterPos2iv = true,
    .rasterPos2s = true,
    .rasterPos2sv = true,
    .rasterPos3d = true,
    .rasterPos3dv = true,
    .rasterPos3f = true,
    .rasterPos3fv = true,
    .rasterPos3i = true,
    .rasterPos3iv = true,
    .rasterPos3s = true,
    .rasterPos3sv = true,
    .rasterPos4d = true,
    .rasterPos4dv = true,
    .rasterPos4f = true,
    .rasterPos4fv = true,
    .rasterPos4i = true,
    .rasterPos4iv = true,
    .rasterPos4s = true,
    .rasterPos4sv = true,
    .rectd = true,
    .rectdv = true,
    .rectf = true,
    .rectfv = true,
    .recti = true,
    .rectiv = true,
    .rects = true,
    .rectsv = true,
    .texCoord1d = true,
    .texCoord1dv = true,
    .texCoord1f = true,
    .texCoord1fv = true,
    .texCoord1i = true,
    .texCoord1iv = true,
    .texCoord1s = true,
    .texCoord1sv = true,
    .texCoord2d = true,
    .texCoord2dv = true,
    .texCoord2f = true,
    .texCoord2fv = true,
    .texCoord2i = true,
    .texCoord2iv = true,
    .texCoord2s = true,
    .texCoord2sv = true,
    .texCoord3d = true,
    .texCoord3dv = true,
    .texCoord3f = true,
    .texCoord3fv = true,
    .texCoord3i = true,
    .texCoord3iv = true,
    .texCoord3s = true,
    .texCoord3sv = true,
    .texCoord4d = true,
    .texCoord4dv = true,
    .texCoord4f = true,
    .texCoord4fv = true,
    .texCoord4i = true,
    .texCoord4iv = true,
    .texCoord4s = true,
    .texCoord4sv = true,
    .vertex2d = true,
    .vertex2dv = true,
    .vertex2f = true,
    .vertex2fv = true,
    .vertex2i = true,
    .vertex2iv = true,
    .vertex2s = true,
    .vertex2sv = true,
    .vertex3d = true,
    .vertex3dv = true,
    .vertex3f = true,
    .vertex3fv = true,
    .vertex3i = true,
    .vertex3iv = true,
    .vertex3s = true,
    .vertex3sv = true,
    .vertex4d = true,
    .vertex4dv = true,
    .vertex4f = true,
    .vertex4fv = true,
    .vertex4i = true,
    .vertex4iv = true,
    .vertex4s = true,
    .vertex4sv = true,
    .clipPlane = true,
    .colorMaterial = true,
    .fogf = true,
    .fogfv = true,
    .fogi = true,
    .fogiv = true,
    .lightf = true,
    .lightfv = true,
    .lighti = true,
    .lightiv = true,
    .lightModelf = true,
    .lightModelfv = true,
    .lightModeli = true,
    .lightModeliv = true,
    .lineStipple = true,
    .materialf = true,
    .materialfv = true,
    .materiali = true,
    .materialiv = true,
    .polygonStipple = true,
    .shadeModel = true,
    .texEnvf = true,
    .texEnvfv = true,
    .texEnvi = true,
    .texEnviv = true,
    .texGend = true,
    .texGendv = true,
    .texGenf = true,
    .texGenfv = true,
    .texGeni = true,
    .texGeniv = true,
    .feedbackBuffer = true,
    .selectBuffer = true,
    .renderMode = true,
    .initNames = true,
    .loadName = true,
    .passThrough = true,
    .popName = true,
    .pushName = true,
    .clearAccum = true,
    .clearIndex = true,
    .indexMask = true,
    .accum = true,
    .popAttrib = true,
    .pushAttrib = true,
    .map1d = true,
    .map1f = true,
    .map2d = true,
    .map2f = true,
    .mapGrid1d = true,
    .mapGrid1f = true,
    .mapGrid2d = true,
    .mapGrid2f = true,
    .evalCoord1d = true,
    .evalCoord1dv = true,
    .evalCoord1f = true,
    .evalCoord1fv = true,
    .evalCoord2d = true,
    .evalCoord2dv = true,
    .evalCoord2f = true,
    .evalCoord2fv = true,
    .evalMesh1 = true,
    .evalPoint1 = true,
    .evalMesh2 = true,
    .evalPoint2 = true,
    .alphaFunc = true,
    .pixelZoom = true,
    .pixelTransferf = true,
    .pixelTransferi = true,
    .pixelMapfv = true,
    .pixelMapuiv = true,
    .pixelMapusv = true,
    .copyPixels = true,
    .drawPixels = true,
    .getClipPlane = true,
    .getLightfv = true,
    .getLightiv = true,
    .getMapdv = true,
    .getMapfv = true,
    .getMapiv = true,
    .getMaterialfv = true,
    .getMaterialiv = true,
    .getPixelMapfv = true,
    .getPixelMapuiv = true,
    .getPixelMapusv = true,
    .getPolygonStipple = true,
    .getTexEnvfv = true,
    .getTexEnviv = true,
    .getTexGendv = true,
    .getTexGenfv = true,
    .getTexGeniv = true,
    .isList = true,
    .frustum = true,
    .loadIdentity = true,
    .loadMatrixf = true,
    .loadMatrixd = true,
    .matrixMode = true,
    .multMatrixf = true,
    .multMatrixd = true,
    .ortho = true,
    .popMatrix = true,
    .pushMatrix = true,
    .rotated = true,
    .rotatef = true,
    .scaled = true,
    .scalef = true,
    .translated = true,
    .translatef = true,
    .drawArrays = true,
    .drawElements = true,
    .getPointerv = true,
    .polygonOffset = true,
    .copyTexImage1D = true,
    .copyTexImage2D = true,
    .copyTexSubImage1D = true,
    .copyTexSubImage2D = true,
    .texSubImage1D = true,
    .texSubImage2D = true,
    .bindTexture = true,
    .deleteTextures = true,
    .genTextures = true,
    .isTexture = true,
    .arrayElement = true,
    .colorPointer = true,
    .disableClientState = true,
    .edgeFlagPointer = true,
    .enableClientState = true,
    .indexPointer = true,
    .interleavedArrays = true,
    .normalPointer = true,
    .texCoordPointer = true,
    .vertexPointer = true,
    .areTexturesResident = true,
    .prioritizeTextures = true,
    .indexub = true,
    .indexubv = true,
    .popClientAttrib = true,
    .pushClientAttrib = true,
    .drawRangeElements = true,
    .texImage3D = true,
    .texSubImage3D = true,
    .copyTexSubImage3D = true,
    .activeTexture = true,
    .sampleCoverage = true,
    .compressedTexImage3D = true,
    .compressedTexImage2D = true,
    .compressedTexImage1D = true,
    .compressedTexSubImage3D = true,
    .compressedTexSubImage2D = true,
    .compressedTexSubImage1D = true,
    .getCompressedTexImage = true,
    .clientActiveTexture = true,
    .multiTexCoord1d = true,
    .multiTexCoord1dv = true,
    .multiTexCoord1f = true,
    .multiTexCoord1fv = true,
    .multiTexCoord1i = true,
    .multiTexCoord1iv = true,
    .multiTexCoord1s = true,
    .multiTexCoord1sv = true,
    .multiTexCoord2d = true,
    .multiTexCoord2dv = true,
    .multiTexCoord2f = true,
    .multiTexCoord2fv = true,
    .multiTexCoord2i = true,
    .multiTexCoord2iv = true,
    .multiTexCoord2s = true,
    .multiTexCoord2sv = true,
    .multiTexCoord3d = true,
    .multiTexCoord3dv = true,
    .multiTexCoord3f = true,
    .multiTexCoord3fv = true,
    .multiTexCoord3i = true,
    .multiTexCoord3iv = true,
    .multiTexCoord3s = true,
    .multiTexCoord3sv = true,
    .multiTexCoord4d = true,
    .multiTexCoord4dv = true,
    .multiTexCoord4f = true,
    .multiTexCoord4fv = true,
    .multiTexCoord4i = true,
    .multiTexCoord4iv = true,
    .multiTexCoord4s = true,
    .multiTexCoord4sv = true,
    .loadTransposeMatrixf = true,
    .loadTransposeMatrixd = true,
    .multTransposeMatrixf = true,
    .multTransposeMatrixd = true,
    .blendFuncSeparate = true,
    .multiDrawArrays = true,
    .multiDrawElements = true,
    .pointParameterf = true,
    .pointParameterfv = true,
    .pointParameteri = true,
    .pointParameteriv = true,
    .fogCoordf = true,
    .fogCoordfv = true,
    .fogCoordd = true,
    .fogCoorddv = true,
    .fogCoordPointer = true,
    .secondaryColor3b = true,
    .secondaryColor3bv = true,
    .secondaryColor3d = true,
    .secondaryColor3dv = true,
    .secondaryColor3f = true,
    .secondaryColor3fv = true,
    .secondaryColor3i = true,
    .secondaryColor3iv = true,
    .secondaryColor3s = true,
    .secondaryColor3sv = true,
    .secondaryColor3ub = true,
    .secondaryColor3ubv = true,
    .secondaryColor3ui = true,
    .secondaryColor3uiv = true,
    .secondaryColor3us = true,
    .secondaryColor3usv = true,
    .secondaryColorPointer = true,
    .windowPos2d = true,
    .windowPos2dv = true,
    .windowPos2f = true,
    .windowPos2fv = true,
    .windowPos2i = true,
    .windowPos2iv = true,
    .windowPos2s = true,
    .windowPos2sv = true,
    .windowPos3d = true,
    .windowPos3dv = true,
    .windowPos3f = true,
    .windowPos3fv = true,
    .windowPos3i = true,
    .windowPos3iv = true,
    .windowPos3s = true,
    .windowPos3sv = true,
    .blendColor = true,
    .blendEquation = true,
    .genQueries = true,
    .deleteQueries = true,
    .isQuery = true,
    .beginQuery = true,
    .endQuery = true,
    .getQueryiv = true,
    .getQueryObjectiv = true,
    .getQueryObjectuiv = true,
    .bindBuffer = true,
    .deleteBuffers = true,
    .genBuffers = true,
    .isBuffer = true,
    .bufferData = true,
    .bufferSubData = true,
    .getBufferSubData = true,
    .mapBuffer = true,
    .unmapBuffer = true,
    .getBufferParameteriv = true,
    .getBufferPointerv = true,
    .blendEquationSeparate = true,
    .drawBuffers = true,
    .stencilOpSeparate = true,
    .stencilFuncSeparate = true,
    .stencilMaskSeparate = true,
    .attachShader = true,
    .bindAttribLocation = true,
    .compileShader = true,
    .createProgram = true,
    .createShader = true,
    .deleteProgram = true,
    .deleteShader = true,
    .detachShader = true,
    .disableVertexAttribArray = true,
    .enableVertexAttribArray = true,
    .getActiveAttrib = true,
    .getActiveUniform = true,
    .getAttachedShaders = true,
    .getAttribLocation = true,
    .getProgramiv = true,
    .getProgramInfoLog = true,
    .getShaderiv = true,
    .getShaderInfoLog = true,
    .getShaderSource = true,
    .getUniformLocation = true,
    .getUniformfv = true,
    .getUniformiv = true,
    .getVertexAttribdv = true,
    .getVertexAttribfv = true,
    .getVertexAttribiv = true,
    .getVertexAttribPointerv = true,
    .isProgram = true,
    .isShader = true,
    .linkProgram = true,
    .shaderSource = true,
    .useProgram = true,
    .uniform1f = true,
    .uniform2f = true,
    .uniform3f = true,
    .uniform4f = true,
    .uniform1i = true,
    .uniform2i = true,
    .uniform3i = true,
    .uniform4i = true,
    .uniform1fv = true,
    .uniform2fv = true,
    .uniform3fv = true,
    .uniform4fv = true,
    .uniform1iv = true,
    .uniform2iv = true,
    .uniform3iv = true,
    .uniform4iv = true,
    .uniformMatrix2fv = true,
    .uniformMatrix3fv = true,
    .uniformMatrix4fv = true,
    .validateProgram = true,
    .vertexAttrib1d = true,
    .vertexAttrib1dv = true,
    .vertexAttrib1f = true,
    .vertexAttrib1fv = true,
    .vertexAttrib1s = true,
    .vertexAttrib1sv = true,
    .vertexAttrib2d = true,
    .vertexAttrib2dv = true,
    .vertexAttrib2f = true,
    .vertexAttrib2fv = true,
    .vertexAttrib2s = true,
    .vertexAttrib2sv = true,
    .vertexAttrib3d = true,
    .vertexAttrib3dv = true,
    .vertexAttrib3f = true,
    .vertexAttrib3fv = true,
    .vertexAttrib3s = true,
    .vertexAttrib3sv = true,
    .vertexAttrib4Nbv = true,
    .vertexAttrib4Niv = true,
    .vertexAttrib4Nsv = true,
    .vertexAttrib4Nub = true,
    .vertexAttrib4Nubv = true,
    .vertexAttrib4Nuiv = true,
    .vertexAttrib4Nusv = true,
    .vertexAttrib4bv = true,
    .vertexAttrib4d = true,
    .vertexAttrib4dv = true,
    .vertexAttrib4f = true,
    .vertexAttrib4fv = true,
    .vertexAttrib4iv = true,
    .vertexAttrib4s = true,
    .vertexAttrib4sv = true,
    .vertexAttrib4ubv = true,
    .vertexAttrib4uiv = true,
    .vertexAttrib4usv = true,
    .vertexAttribPointer = true,
    .uniformMatrix2x3fv = true,
    .uniformMatrix3x2fv = true,
    .uniformMatrix2x4fv = true,
    .uniformMatrix4x2fv = true,
    .uniformMatrix3x4fv = true,
    .uniformMatrix4x3fv = true,
    .colorMaski = true,
    .getBooleani_v = true,
    .getIntegeri_v = true,
    .enablei = true,
    .disablei = true,
    .isEnabledi = true,
    .beginTransformFeedback = true,
    .endTransformFeedback = true,
    .bindBufferRange = true,
    .bindBufferBase = true,
    .transformFeedbackVaryings = true,
    .getTransformFeedbackVarying = true,
    .clampColor = true,
    .beginConditionalRender = true,
    .endConditionalRender = true,
    .vertexAttribIPointer = true,
    .getVertexAttribIiv = true,
    .getVertexAttribIuiv = true,
    .vertexAttribI1i = true,
    .vertexAttribI2i = true,
    .vertexAttribI3i = true,
    .vertexAttribI4i = true,
    .vertexAttribI1ui = true,
    .vertexAttribI2ui = true,
    .vertexAttribI3ui = true,
    .vertexAttribI4ui = true,
    .vertexAttribI1iv = true,
    .vertexAttribI2iv = true,
    .vertexAttribI3iv = true,
    .vertexAttribI4iv = true,
    .vertexAttribI1uiv = true,
    .vertexAttribI2uiv = true,
    .vertexAttribI3uiv = true,
    .vertexAttribI4uiv = true,
    .vertexAttribI4bv = true,
    .vertexAttribI4sv = true,
    .vertexAttribI4ubv = true,
    .vertexAttribI4usv = true,
    .getUniformuiv = true,
    .bindFragDataLocation = true,
    .getFragDataLocation = true,
    .uniform1ui = true,
    .uniform2ui = true,
    .uniform3ui = true,
    .uniform4ui = true,
    .uniform1uiv = true,
    .uniform2uiv = true,
    .uniform3uiv = true,
    .uniform4uiv = true,
    .texParameterIiv = true,
    .texParameterIuiv = true,
    .getTexParameterIiv = true,
    .getTexParameterIuiv = true,
    .clearBufferiv = true,
    .clearBufferuiv = true,
    .clearBufferfv = true,
    .clearBufferfi = true,
    .getStringi = true,
    .isRenderbuffer = true,
    .bindRenderbuffer = true,
    .deleteRenderbuffers = true,
    .genRenderbuffers = true,
    .renderbufferStorage = true,
    .getRenderbufferParameteriv = true,
    .isFramebuffer = true,
    .bindFramebuffer = true,
    .deleteFramebuffers = true,
    .genFramebuffers = true,
    .checkFramebufferStatus = true,
    .framebufferTexture1D = true,
    .framebufferTexture2D = true,
    .framebufferTexture3D = true,
    .framebufferRenderbuffer = true,
    .getFramebufferAttachmentParameteriv = true,
    .generateMipmap = true,
    .blitFramebuffer = true,
    .renderbufferStorageMultisample = true,
    .framebufferTextureLayer = true,
    .mapBufferRange = true,
    .flushMappedBufferRange = true,
    .bindVertexArray = true,
    .deleteVertexArrays = true,
    .genVertexArrays = true,
    .isVertexArray = true,
    .drawArraysInstanced = true,
    .drawElementsInstanced = true,
    .texBuffer = true,
    .primitiveRestartIndex = true,
    .copyBufferSubData = true,
    .getUniformIndices = true,
    .getActiveUniformsiv = true,
    .getActiveUniformName = true,
    .getUniformBlockIndex = true,
    .getActiveUniformBlockiv = true,
    .getActiveUniformBlockName = true,
    .uniformBlockBinding = true,
    .drawElementsBaseVertex = true,
    .drawRangeElementsBaseVertex = true,
    .drawElementsInstancedBaseVertex = true,
    .multiDrawElementsBaseVertex = true,
    .provokingVertex = true,
    .fenceSync = true,
    .isSync = true,
    .deleteSync = true,
    .clientWaitSync = true,
    .waitSync = true,
    .getInteger64v = true,
    .getSynciv = true,
    .getInteger64i_v = true,
    .getBufferParameteri64v = true,
    .framebufferTexture = true,
    .texImage2DMultisample = true,
    .texImage3DMultisample = true,
    .getMultisamplefv = true,
    .sampleMaski = true,
    .bindFragDataLocationIndexed = true,
    .getFragDataIndex = true,
    .genSamplers = true,
    .deleteSamplers = true,
    .isSampler = true,
    .bindSampler = true,
    .samplerParameteri = true,
    .samplerParameteriv = true,
    .samplerParameterf = true,
    .samplerParameterfv = true,
    .samplerParameterIiv = true,
    .samplerParameterIuiv = true,
    .getSamplerParameteriv = true,
    .getSamplerParameterIiv = true,
    .getSamplerParameterfv = true,
    .getSamplerParameterIuiv = true,
    .queryCounter = true,
    .getQueryObjecti64v = true,
    .getQueryObjectui64v = true,
    .vertexAttribDivisor = true,
    .vertexAttribP1ui = true,
    .vertexAttribP1uiv = true,
    .vertexAttribP2ui = true,
    .vertexAttribP2uiv = true,
    .vertexAttribP3ui = true,
    .vertexAttribP3uiv = true,
    .vertexAttribP4ui = true,
    .vertexAttribP4uiv = true,
    .vertexP2ui = true,
    .vertexP2uiv = true,
    .vertexP3ui = true,
    .vertexP3uiv = true,
    .vertexP4ui = true,
    .vertexP4uiv = true,
    .texCoordP1ui = true,
    .texCoordP1uiv = true,
    .texCoordP2ui = true,
    .texCoordP2uiv = true,
    .texCoordP3ui = true,
    .texCoordP3uiv = true,
    .texCoordP4ui = true,
    .texCoordP4uiv = true,
    .multiTexCoordP1ui = true,
    .multiTexCoordP1uiv = true,
    .multiTexCoordP2ui = true,
    .multiTexCoordP2uiv = true,
    .multiTexCoordP3ui = true,
    .multiTexCoordP3uiv = true,
    .multiTexCoordP4ui = true,
    .multiTexCoordP4uiv = true,
    .normalP3ui = true,
    .normalP3uiv = true,
    .colorP3ui = true,
    .colorP3uiv = true,
    .colorP4ui = true,
    .colorP4uiv = true,
    .secondaryColorP3ui = true,
    .secondaryColorP3uiv = true,
    .minSampleShading = true,
    .blendEquationi = true,
    .blendEquationSeparatei = true,
    .blendFunci = true,
    .blendFuncSeparatei = true,
    .drawArraysIndirect = true,
    .drawElementsIndirect = true,
    .uniform1d = true,
    .uniform2d = true,
    .uniform3d = true,
    .uniform4d = true,
    .uniform1dv = true,
    .uniform2dv = true,
    .uniform3dv = true,
    .uniform4dv = true,
    .uniformMatrix2dv = true,
    .uniformMatrix3dv = true,
    .uniformMatrix4dv = true,
    .uniformMatrix2x3dv = true,
    .uniformMatrix2x4dv = true,
    .uniformMatrix3x2dv = true,
    .uniformMatrix3x4dv = true,
    .uniformMatrix4x2dv = true,
    .uniformMatrix4x3dv = true,
    .getUniformdv = true,
    .getSubroutineUniformLocation = true,
    .getSubroutineIndex = true,
    .getActiveSubroutineUniformiv = true,
    .getActiveSubroutineUniformName = true,
    .getActiveSubroutineName = true,
    .uniformSubroutinesuiv = true,
    .getUniformSubroutineuiv = true,
    .getProgramStageiv = true,
    .patchParameteri = true,
    .patchParameterfv = true,
    .bindTransformFeedback = true,
    .deleteTransformFeedbacks = true,
    .genTransformFeedbacks = true,
    .isTransformFeedback = true,
    .pauseTransformFeedback = true,
    .resumeTransformFeedback = true,
    .drawTransformFeedback = true,
    .drawTransformFeedbackStream = true,
    .beginQueryIndexed = true,
    .endQueryIndexed = true,
    .getQueryIndexediv = true,
    .releaseShaderCompiler = true,
    .shaderBinary = true,
    .getShaderPrecisionFormat = true,
    .depthRangef = true,
    .clearDepthf = true,
    .getProgramBinary = true,
    .programBinary = true,
    .programParameteri = true,
    .useProgramStages = true,
    .activeShaderProgram = true,
    .createShaderProgramv = true,
    .bindProgramPipeline = true,
    .deleteProgramPipelines = true,
    .genProgramPipelines = true,
    .isProgramPipeline = true,
    .getProgramPipelineiv = true,
    .programUniform1i = true,
    .programUniform1iv = true,
    .programUniform1f = true,
    .programUniform1fv = true,
    .programUniform1d = true,
    .programUniform1dv = true,
    .programUniform1ui = true,
    .programUniform1uiv = true,
    .programUniform2i = true,
    .programUniform2iv = true,
    .programUniform2f = true,
    .programUniform2fv = true,
    .programUniform2d = true,
    .programUniform2dv = true,
    .programUniform2ui = true,
    .programUniform2uiv = true,
    .programUniform3i = true,
    .programUniform3iv = true,
    .programUniform3f = true,
    .programUniform3fv = true,
    .programUniform3d = true,
    .programUniform3dv = true,
    .programUniform3ui = true,
    .programUniform3uiv = true,
    .programUniform4i = true,
    .programUniform4iv = true,
    .programUniform4f = true,
    .programUniform4fv = true,
    .programUniform4d = true,
    .programUniform4dv = true,
    .programUniform4ui = true,
    .programUniform4uiv = true,
    .programUniformMatrix2fv = true,
    .programUniformMatrix3fv = true,
    .programUniformMatrix4fv = true,
    .programUniformMatrix2dv = true,
    .programUniformMatrix3dv = true,
    .programUniformMatrix4dv = true,
    .programUniformMatrix2x3fv = true,
    .programUniformMatrix3x2fv = true,
    .programUniformMatrix2x4fv = true,
    .programUniformMatrix4x2fv = true,
    .programUniformMatrix3x4fv = true,
    .programUniformMatrix4x3fv = true,
    .programUniformMatrix2x3dv = true,
    .programUniformMatrix3x2dv = true,
    .programUniformMatrix2x4dv = true,
    .programUniformMatrix4x2dv = true,
    .programUniformMatrix3x4dv = true,
    .programUniformMatrix4x3dv = true,
    .validateProgramPipeline = true,
    .getProgramPipelineInfoLog = true,
    .vertexAttribL1d = true,
    .vertexAttribL2d = true,
    .vertexAttribL3d = true,
    .vertexAttribL4d = true,
    .vertexAttribL1dv = true,
    .vertexAttribL2dv = true,
    .vertexAttribL3dv = true,
    .vertexAttribL4dv = true,
    .vertexAttribLPointer = true,
    .getVertexAttribLdv = true,
    .viewportArrayv = true,
    .viewportIndexedf = true,
    .viewportIndexedfv = true,
    .scissorArrayv = true,
    .scissorIndexed = true,
    .scissorIndexedv = true,
    .depthRangeArrayv = true,
    .depthRangeIndexed = true,
    .getFloati_v = true,
    .getDoublei_v = true,
};

pub const gl42 = CommandFlags{
    .cullFace = true,
    .frontFace = true,
    .hint = true,
    .lineWidth = true,
    .pointSize = true,
    .polygonMode = true,
    .scissor = true,
    .texParameterf = true,
    .texParameterfv = true,
    .texParameteri = true,
    .texParameteriv = true,
    .texImage1D = true,
    .texImage2D = true,
    .drawBuffer = true,
    .clear = true,
    .clearColor = true,
    .clearStencil = true,
    .clearDepth = true,
    .stencilMask = true,
    .colorMask = true,
    .depthMask = true,
    .disable = true,
    .enable = true,
    .finish = true,
    .flush = true,
    .blendFunc = true,
    .logicOp = true,
    .stencilFunc = true,
    .stencilOp = true,
    .depthFunc = true,
    .pixelStoref = true,
    .pixelStorei = true,
    .readBuffer = true,
    .readPixels = true,
    .getBooleanv = true,
    .getDoublev = true,
    .getError = true,
    .getFloatv = true,
    .getIntegerv = true,
    .getString = true,
    .getTexImage = true,
    .getTexParameterfv = true,
    .getTexParameteriv = true,
    .getTexLevelParameterfv = true,
    .getTexLevelParameteriv = true,
    .isEnabled = true,
    .depthRange = true,
    .viewport = true,
    .newList = true,
    .endList = true,
    .callList = true,
    .callLists = true,
    .deleteLists = true,
    .genLists = true,
    .listBase = true,
    .begin = true,
    .bitmap = true,
    .color3b = true,
    .color3bv = true,
    .color3d = true,
    .color3dv = true,
    .color3f = true,
    .color3fv = true,
    .color3i = true,
    .color3iv = true,
    .color3s = true,
    .color3sv = true,
    .color3ub = true,
    .color3ubv = true,
    .color3ui = true,
    .color3uiv = true,
    .color3us = true,
    .color3usv = true,
    .color4b = true,
    .color4bv = true,
    .color4d = true,
    .color4dv = true,
    .color4f = true,
    .color4fv = true,
    .color4i = true,
    .color4iv = true,
    .color4s = true,
    .color4sv = true,
    .color4ub = true,
    .color4ubv = true,
    .color4ui = true,
    .color4uiv = true,
    .color4us = true,
    .color4usv = true,
    .edgeFlag = true,
    .edgeFlagv = true,
    .end = true,
    .indexd = true,
    .indexdv = true,
    .indexf = true,
    .indexfv = true,
    .indexi = true,
    .indexiv = true,
    .indexs = true,
    .indexsv = true,
    .normal3b = true,
    .normal3bv = true,
    .normal3d = true,
    .normal3dv = true,
    .normal3f = true,
    .normal3fv = true,
    .normal3i = true,
    .normal3iv = true,
    .normal3s = true,
    .normal3sv = true,
    .rasterPos2d = true,
    .rasterPos2dv = true,
    .rasterPos2f = true,
    .rasterPos2fv = true,
    .rasterPos2i = true,
    .rasterPos2iv = true,
    .rasterPos2s = true,
    .rasterPos2sv = true,
    .rasterPos3d = true,
    .rasterPos3dv = true,
    .rasterPos3f = true,
    .rasterPos3fv = true,
    .rasterPos3i = true,
    .rasterPos3iv = true,
    .rasterPos3s = true,
    .rasterPos3sv = true,
    .rasterPos4d = true,
    .rasterPos4dv = true,
    .rasterPos4f = true,
    .rasterPos4fv = true,
    .rasterPos4i = true,
    .rasterPos4iv = true,
    .rasterPos4s = true,
    .rasterPos4sv = true,
    .rectd = true,
    .rectdv = true,
    .rectf = true,
    .rectfv = true,
    .recti = true,
    .rectiv = true,
    .rects = true,
    .rectsv = true,
    .texCoord1d = true,
    .texCoord1dv = true,
    .texCoord1f = true,
    .texCoord1fv = true,
    .texCoord1i = true,
    .texCoord1iv = true,
    .texCoord1s = true,
    .texCoord1sv = true,
    .texCoord2d = true,
    .texCoord2dv = true,
    .texCoord2f = true,
    .texCoord2fv = true,
    .texCoord2i = true,
    .texCoord2iv = true,
    .texCoord2s = true,
    .texCoord2sv = true,
    .texCoord3d = true,
    .texCoord3dv = true,
    .texCoord3f = true,
    .texCoord3fv = true,
    .texCoord3i = true,
    .texCoord3iv = true,
    .texCoord3s = true,
    .texCoord3sv = true,
    .texCoord4d = true,
    .texCoord4dv = true,
    .texCoord4f = true,
    .texCoord4fv = true,
    .texCoord4i = true,
    .texCoord4iv = true,
    .texCoord4s = true,
    .texCoord4sv = true,
    .vertex2d = true,
    .vertex2dv = true,
    .vertex2f = true,
    .vertex2fv = true,
    .vertex2i = true,
    .vertex2iv = true,
    .vertex2s = true,
    .vertex2sv = true,
    .vertex3d = true,
    .vertex3dv = true,
    .vertex3f = true,
    .vertex3fv = true,
    .vertex3i = true,
    .vertex3iv = true,
    .vertex3s = true,
    .vertex3sv = true,
    .vertex4d = true,
    .vertex4dv = true,
    .vertex4f = true,
    .vertex4fv = true,
    .vertex4i = true,
    .vertex4iv = true,
    .vertex4s = true,
    .vertex4sv = true,
    .clipPlane = true,
    .colorMaterial = true,
    .fogf = true,
    .fogfv = true,
    .fogi = true,
    .fogiv = true,
    .lightf = true,
    .lightfv = true,
    .lighti = true,
    .lightiv = true,
    .lightModelf = true,
    .lightModelfv = true,
    .lightModeli = true,
    .lightModeliv = true,
    .lineStipple = true,
    .materialf = true,
    .materialfv = true,
    .materiali = true,
    .materialiv = true,
    .polygonStipple = true,
    .shadeModel = true,
    .texEnvf = true,
    .texEnvfv = true,
    .texEnvi = true,
    .texEnviv = true,
    .texGend = true,
    .texGendv = true,
    .texGenf = true,
    .texGenfv = true,
    .texGeni = true,
    .texGeniv = true,
    .feedbackBuffer = true,
    .selectBuffer = true,
    .renderMode = true,
    .initNames = true,
    .loadName = true,
    .passThrough = true,
    .popName = true,
    .pushName = true,
    .clearAccum = true,
    .clearIndex = true,
    .indexMask = true,
    .accum = true,
    .popAttrib = true,
    .pushAttrib = true,
    .map1d = true,
    .map1f = true,
    .map2d = true,
    .map2f = true,
    .mapGrid1d = true,
    .mapGrid1f = true,
    .mapGrid2d = true,
    .mapGrid2f = true,
    .evalCoord1d = true,
    .evalCoord1dv = true,
    .evalCoord1f = true,
    .evalCoord1fv = true,
    .evalCoord2d = true,
    .evalCoord2dv = true,
    .evalCoord2f = true,
    .evalCoord2fv = true,
    .evalMesh1 = true,
    .evalPoint1 = true,
    .evalMesh2 = true,
    .evalPoint2 = true,
    .alphaFunc = true,
    .pixelZoom = true,
    .pixelTransferf = true,
    .pixelTransferi = true,
    .pixelMapfv = true,
    .pixelMapuiv = true,
    .pixelMapusv = true,
    .copyPixels = true,
    .drawPixels = true,
    .getClipPlane = true,
    .getLightfv = true,
    .getLightiv = true,
    .getMapdv = true,
    .getMapfv = true,
    .getMapiv = true,
    .getMaterialfv = true,
    .getMaterialiv = true,
    .getPixelMapfv = true,
    .getPixelMapuiv = true,
    .getPixelMapusv = true,
    .getPolygonStipple = true,
    .getTexEnvfv = true,
    .getTexEnviv = true,
    .getTexGendv = true,
    .getTexGenfv = true,
    .getTexGeniv = true,
    .isList = true,
    .frustum = true,
    .loadIdentity = true,
    .loadMatrixf = true,
    .loadMatrixd = true,
    .matrixMode = true,
    .multMatrixf = true,
    .multMatrixd = true,
    .ortho = true,
    .popMatrix = true,
    .pushMatrix = true,
    .rotated = true,
    .rotatef = true,
    .scaled = true,
    .scalef = true,
    .translated = true,
    .translatef = true,
    .drawArrays = true,
    .drawElements = true,
    .getPointerv = true,
    .polygonOffset = true,
    .copyTexImage1D = true,
    .copyTexImage2D = true,
    .copyTexSubImage1D = true,
    .copyTexSubImage2D = true,
    .texSubImage1D = true,
    .texSubImage2D = true,
    .bindTexture = true,
    .deleteTextures = true,
    .genTextures = true,
    .isTexture = true,
    .arrayElement = true,
    .colorPointer = true,
    .disableClientState = true,
    .edgeFlagPointer = true,
    .enableClientState = true,
    .indexPointer = true,
    .interleavedArrays = true,
    .normalPointer = true,
    .texCoordPointer = true,
    .vertexPointer = true,
    .areTexturesResident = true,
    .prioritizeTextures = true,
    .indexub = true,
    .indexubv = true,
    .popClientAttrib = true,
    .pushClientAttrib = true,
    .drawRangeElements = true,
    .texImage3D = true,
    .texSubImage3D = true,
    .copyTexSubImage3D = true,
    .activeTexture = true,
    .sampleCoverage = true,
    .compressedTexImage3D = true,
    .compressedTexImage2D = true,
    .compressedTexImage1D = true,
    .compressedTexSubImage3D = true,
    .compressedTexSubImage2D = true,
    .compressedTexSubImage1D = true,
    .getCompressedTexImage = true,
    .clientActiveTexture = true,
    .multiTexCoord1d = true,
    .multiTexCoord1dv = true,
    .multiTexCoord1f = true,
    .multiTexCoord1fv = true,
    .multiTexCoord1i = true,
    .multiTexCoord1iv = true,
    .multiTexCoord1s = true,
    .multiTexCoord1sv = true,
    .multiTexCoord2d = true,
    .multiTexCoord2dv = true,
    .multiTexCoord2f = true,
    .multiTexCoord2fv = true,
    .multiTexCoord2i = true,
    .multiTexCoord2iv = true,
    .multiTexCoord2s = true,
    .multiTexCoord2sv = true,
    .multiTexCoord3d = true,
    .multiTexCoord3dv = true,
    .multiTexCoord3f = true,
    .multiTexCoord3fv = true,
    .multiTexCoord3i = true,
    .multiTexCoord3iv = true,
    .multiTexCoord3s = true,
    .multiTexCoord3sv = true,
    .multiTexCoord4d = true,
    .multiTexCoord4dv = true,
    .multiTexCoord4f = true,
    .multiTexCoord4fv = true,
    .multiTexCoord4i = true,
    .multiTexCoord4iv = true,
    .multiTexCoord4s = true,
    .multiTexCoord4sv = true,
    .loadTransposeMatrixf = true,
    .loadTransposeMatrixd = true,
    .multTransposeMatrixf = true,
    .multTransposeMatrixd = true,
    .blendFuncSeparate = true,
    .multiDrawArrays = true,
    .multiDrawElements = true,
    .pointParameterf = true,
    .pointParameterfv = true,
    .pointParameteri = true,
    .pointParameteriv = true,
    .fogCoordf = true,
    .fogCoordfv = true,
    .fogCoordd = true,
    .fogCoorddv = true,
    .fogCoordPointer = true,
    .secondaryColor3b = true,
    .secondaryColor3bv = true,
    .secondaryColor3d = true,
    .secondaryColor3dv = true,
    .secondaryColor3f = true,
    .secondaryColor3fv = true,
    .secondaryColor3i = true,
    .secondaryColor3iv = true,
    .secondaryColor3s = true,
    .secondaryColor3sv = true,
    .secondaryColor3ub = true,
    .secondaryColor3ubv = true,
    .secondaryColor3ui = true,
    .secondaryColor3uiv = true,
    .secondaryColor3us = true,
    .secondaryColor3usv = true,
    .secondaryColorPointer = true,
    .windowPos2d = true,
    .windowPos2dv = true,
    .windowPos2f = true,
    .windowPos2fv = true,
    .windowPos2i = true,
    .windowPos2iv = true,
    .windowPos2s = true,
    .windowPos2sv = true,
    .windowPos3d = true,
    .windowPos3dv = true,
    .windowPos3f = true,
    .windowPos3fv = true,
    .windowPos3i = true,
    .windowPos3iv = true,
    .windowPos3s = true,
    .windowPos3sv = true,
    .blendColor = true,
    .blendEquation = true,
    .genQueries = true,
    .deleteQueries = true,
    .isQuery = true,
    .beginQuery = true,
    .endQuery = true,
    .getQueryiv = true,
    .getQueryObjectiv = true,
    .getQueryObjectuiv = true,
    .bindBuffer = true,
    .deleteBuffers = true,
    .genBuffers = true,
    .isBuffer = true,
    .bufferData = true,
    .bufferSubData = true,
    .getBufferSubData = true,
    .mapBuffer = true,
    .unmapBuffer = true,
    .getBufferParameteriv = true,
    .getBufferPointerv = true,
    .blendEquationSeparate = true,
    .drawBuffers = true,
    .stencilOpSeparate = true,
    .stencilFuncSeparate = true,
    .stencilMaskSeparate = true,
    .attachShader = true,
    .bindAttribLocation = true,
    .compileShader = true,
    .createProgram = true,
    .createShader = true,
    .deleteProgram = true,
    .deleteShader = true,
    .detachShader = true,
    .disableVertexAttribArray = true,
    .enableVertexAttribArray = true,
    .getActiveAttrib = true,
    .getActiveUniform = true,
    .getAttachedShaders = true,
    .getAttribLocation = true,
    .getProgramiv = true,
    .getProgramInfoLog = true,
    .getShaderiv = true,
    .getShaderInfoLog = true,
    .getShaderSource = true,
    .getUniformLocation = true,
    .getUniformfv = true,
    .getUniformiv = true,
    .getVertexAttribdv = true,
    .getVertexAttribfv = true,
    .getVertexAttribiv = true,
    .getVertexAttribPointerv = true,
    .isProgram = true,
    .isShader = true,
    .linkProgram = true,
    .shaderSource = true,
    .useProgram = true,
    .uniform1f = true,
    .uniform2f = true,
    .uniform3f = true,
    .uniform4f = true,
    .uniform1i = true,
    .uniform2i = true,
    .uniform3i = true,
    .uniform4i = true,
    .uniform1fv = true,
    .uniform2fv = true,
    .uniform3fv = true,
    .uniform4fv = true,
    .uniform1iv = true,
    .uniform2iv = true,
    .uniform3iv = true,
    .uniform4iv = true,
    .uniformMatrix2fv = true,
    .uniformMatrix3fv = true,
    .uniformMatrix4fv = true,
    .validateProgram = true,
    .vertexAttrib1d = true,
    .vertexAttrib1dv = true,
    .vertexAttrib1f = true,
    .vertexAttrib1fv = true,
    .vertexAttrib1s = true,
    .vertexAttrib1sv = true,
    .vertexAttrib2d = true,
    .vertexAttrib2dv = true,
    .vertexAttrib2f = true,
    .vertexAttrib2fv = true,
    .vertexAttrib2s = true,
    .vertexAttrib2sv = true,
    .vertexAttrib3d = true,
    .vertexAttrib3dv = true,
    .vertexAttrib3f = true,
    .vertexAttrib3fv = true,
    .vertexAttrib3s = true,
    .vertexAttrib3sv = true,
    .vertexAttrib4Nbv = true,
    .vertexAttrib4Niv = true,
    .vertexAttrib4Nsv = true,
    .vertexAttrib4Nub = true,
    .vertexAttrib4Nubv = true,
    .vertexAttrib4Nuiv = true,
    .vertexAttrib4Nusv = true,
    .vertexAttrib4bv = true,
    .vertexAttrib4d = true,
    .vertexAttrib4dv = true,
    .vertexAttrib4f = true,
    .vertexAttrib4fv = true,
    .vertexAttrib4iv = true,
    .vertexAttrib4s = true,
    .vertexAttrib4sv = true,
    .vertexAttrib4ubv = true,
    .vertexAttrib4uiv = true,
    .vertexAttrib4usv = true,
    .vertexAttribPointer = true,
    .uniformMatrix2x3fv = true,
    .uniformMatrix3x2fv = true,
    .uniformMatrix2x4fv = true,
    .uniformMatrix4x2fv = true,
    .uniformMatrix3x4fv = true,
    .uniformMatrix4x3fv = true,
    .colorMaski = true,
    .getBooleani_v = true,
    .getIntegeri_v = true,
    .enablei = true,
    .disablei = true,
    .isEnabledi = true,
    .beginTransformFeedback = true,
    .endTransformFeedback = true,
    .bindBufferRange = true,
    .bindBufferBase = true,
    .transformFeedbackVaryings = true,
    .getTransformFeedbackVarying = true,
    .clampColor = true,
    .beginConditionalRender = true,
    .endConditionalRender = true,
    .vertexAttribIPointer = true,
    .getVertexAttribIiv = true,
    .getVertexAttribIuiv = true,
    .vertexAttribI1i = true,
    .vertexAttribI2i = true,
    .vertexAttribI3i = true,
    .vertexAttribI4i = true,
    .vertexAttribI1ui = true,
    .vertexAttribI2ui = true,
    .vertexAttribI3ui = true,
    .vertexAttribI4ui = true,
    .vertexAttribI1iv = true,
    .vertexAttribI2iv = true,
    .vertexAttribI3iv = true,
    .vertexAttribI4iv = true,
    .vertexAttribI1uiv = true,
    .vertexAttribI2uiv = true,
    .vertexAttribI3uiv = true,
    .vertexAttribI4uiv = true,
    .vertexAttribI4bv = true,
    .vertexAttribI4sv = true,
    .vertexAttribI4ubv = true,
    .vertexAttribI4usv = true,
    .getUniformuiv = true,
    .bindFragDataLocation = true,
    .getFragDataLocation = true,
    .uniform1ui = true,
    .uniform2ui = true,
    .uniform3ui = true,
    .uniform4ui = true,
    .uniform1uiv = true,
    .uniform2uiv = true,
    .uniform3uiv = true,
    .uniform4uiv = true,
    .texParameterIiv = true,
    .texParameterIuiv = true,
    .getTexParameterIiv = true,
    .getTexParameterIuiv = true,
    .clearBufferiv = true,
    .clearBufferuiv = true,
    .clearBufferfv = true,
    .clearBufferfi = true,
    .getStringi = true,
    .isRenderbuffer = true,
    .bindRenderbuffer = true,
    .deleteRenderbuffers = true,
    .genRenderbuffers = true,
    .renderbufferStorage = true,
    .getRenderbufferParameteriv = true,
    .isFramebuffer = true,
    .bindFramebuffer = true,
    .deleteFramebuffers = true,
    .genFramebuffers = true,
    .checkFramebufferStatus = true,
    .framebufferTexture1D = true,
    .framebufferTexture2D = true,
    .framebufferTexture3D = true,
    .framebufferRenderbuffer = true,
    .getFramebufferAttachmentParameteriv = true,
    .generateMipmap = true,
    .blitFramebuffer = true,
    .renderbufferStorageMultisample = true,
    .framebufferTextureLayer = true,
    .mapBufferRange = true,
    .flushMappedBufferRange = true,
    .bindVertexArray = true,
    .deleteVertexArrays = true,
    .genVertexArrays = true,
    .isVertexArray = true,
    .drawArraysInstanced = true,
    .drawElementsInstanced = true,
    .texBuffer = true,
    .primitiveRestartIndex = true,
    .copyBufferSubData = true,
    .getUniformIndices = true,
    .getActiveUniformsiv = true,
    .getActiveUniformName = true,
    .getUniformBlockIndex = true,
    .getActiveUniformBlockiv = true,
    .getActiveUniformBlockName = true,
    .uniformBlockBinding = true,
    .drawElementsBaseVertex = true,
    .drawRangeElementsBaseVertex = true,
    .drawElementsInstancedBaseVertex = true,
    .multiDrawElementsBaseVertex = true,
    .provokingVertex = true,
    .fenceSync = true,
    .isSync = true,
    .deleteSync = true,
    .clientWaitSync = true,
    .waitSync = true,
    .getInteger64v = true,
    .getSynciv = true,
    .getInteger64i_v = true,
    .getBufferParameteri64v = true,
    .framebufferTexture = true,
    .texImage2DMultisample = true,
    .texImage3DMultisample = true,
    .getMultisamplefv = true,
    .sampleMaski = true,
    .bindFragDataLocationIndexed = true,
    .getFragDataIndex = true,
    .genSamplers = true,
    .deleteSamplers = true,
    .isSampler = true,
    .bindSampler = true,
    .samplerParameteri = true,
    .samplerParameteriv = true,
    .samplerParameterf = true,
    .samplerParameterfv = true,
    .samplerParameterIiv = true,
    .samplerParameterIuiv = true,
    .getSamplerParameteriv = true,
    .getSamplerParameterIiv = true,
    .getSamplerParameterfv = true,
    .getSamplerParameterIuiv = true,
    .queryCounter = true,
    .getQueryObjecti64v = true,
    .getQueryObjectui64v = true,
    .vertexAttribDivisor = true,
    .vertexAttribP1ui = true,
    .vertexAttribP1uiv = true,
    .vertexAttribP2ui = true,
    .vertexAttribP2uiv = true,
    .vertexAttribP3ui = true,
    .vertexAttribP3uiv = true,
    .vertexAttribP4ui = true,
    .vertexAttribP4uiv = true,
    .vertexP2ui = true,
    .vertexP2uiv = true,
    .vertexP3ui = true,
    .vertexP3uiv = true,
    .vertexP4ui = true,
    .vertexP4uiv = true,
    .texCoordP1ui = true,
    .texCoordP1uiv = true,
    .texCoordP2ui = true,
    .texCoordP2uiv = true,
    .texCoordP3ui = true,
    .texCoordP3uiv = true,
    .texCoordP4ui = true,
    .texCoordP4uiv = true,
    .multiTexCoordP1ui = true,
    .multiTexCoordP1uiv = true,
    .multiTexCoordP2ui = true,
    .multiTexCoordP2uiv = true,
    .multiTexCoordP3ui = true,
    .multiTexCoordP3uiv = true,
    .multiTexCoordP4ui = true,
    .multiTexCoordP4uiv = true,
    .normalP3ui = true,
    .normalP3uiv = true,
    .colorP3ui = true,
    .colorP3uiv = true,
    .colorP4ui = true,
    .colorP4uiv = true,
    .secondaryColorP3ui = true,
    .secondaryColorP3uiv = true,
    .minSampleShading = true,
    .blendEquationi = true,
    .blendEquationSeparatei = true,
    .blendFunci = true,
    .blendFuncSeparatei = true,
    .drawArraysIndirect = true,
    .drawElementsIndirect = true,
    .uniform1d = true,
    .uniform2d = true,
    .uniform3d = true,
    .uniform4d = true,
    .uniform1dv = true,
    .uniform2dv = true,
    .uniform3dv = true,
    .uniform4dv = true,
    .uniformMatrix2dv = true,
    .uniformMatrix3dv = true,
    .uniformMatrix4dv = true,
    .uniformMatrix2x3dv = true,
    .uniformMatrix2x4dv = true,
    .uniformMatrix3x2dv = true,
    .uniformMatrix3x4dv = true,
    .uniformMatrix4x2dv = true,
    .uniformMatrix4x3dv = true,
    .getUniformdv = true,
    .getSubroutineUniformLocation = true,
    .getSubroutineIndex = true,
    .getActiveSubroutineUniformiv = true,
    .getActiveSubroutineUniformName = true,
    .getActiveSubroutineName = true,
    .uniformSubroutinesuiv = true,
    .getUniformSubroutineuiv = true,
    .getProgramStageiv = true,
    .patchParameteri = true,
    .patchParameterfv = true,
    .bindTransformFeedback = true,
    .deleteTransformFeedbacks = true,
    .genTransformFeedbacks = true,
    .isTransformFeedback = true,
    .pauseTransformFeedback = true,
    .resumeTransformFeedback = true,
    .drawTransformFeedback = true,
    .drawTransformFeedbackStream = true,
    .beginQueryIndexed = true,
    .endQueryIndexed = true,
    .getQueryIndexediv = true,
    .releaseShaderCompiler = true,
    .shaderBinary = true,
    .getShaderPrecisionFormat = true,
    .depthRangef = true,
    .clearDepthf = true,
    .getProgramBinary = true,
    .programBinary = true,
    .programParameteri = true,
    .useProgramStages = true,
    .activeShaderProgram = true,
    .createShaderProgramv = true,
    .bindProgramPipeline = true,
    .deleteProgramPipelines = true,
    .genProgramPipelines = true,
    .isProgramPipeline = true,
    .getProgramPipelineiv = true,
    .programUniform1i = true,
    .programUniform1iv = true,
    .programUniform1f = true,
    .programUniform1fv = true,
    .programUniform1d = true,
    .programUniform1dv = true,
    .programUniform1ui = true,
    .programUniform1uiv = true,
    .programUniform2i = true,
    .programUniform2iv = true,
    .programUniform2f = true,
    .programUniform2fv = true,
    .programUniform2d = true,
    .programUniform2dv = true,
    .programUniform2ui = true,
    .programUniform2uiv = true,
    .programUniform3i = true,
    .programUniform3iv = true,
    .programUniform3f = true,
    .programUniform3fv = true,
    .programUniform3d = true,
    .programUniform3dv = true,
    .programUniform3ui = true,
    .programUniform3uiv = true,
    .programUniform4i = true,
    .programUniform4iv = true,
    .programUniform4f = true,
    .programUniform4fv = true,
    .programUniform4d = true,
    .programUniform4dv = true,
    .programUniform4ui = true,
    .programUniform4uiv = true,
    .programUniformMatrix2fv = true,
    .programUniformMatrix3fv = true,
    .programUniformMatrix4fv = true,
    .programUniformMatrix2dv = true,
    .programUniformMatrix3dv = true,
    .programUniformMatrix4dv = true,
    .programUniformMatrix2x3fv = true,
    .programUniformMatrix3x2fv = true,
    .programUniformMatrix2x4fv = true,
    .programUniformMatrix4x2fv = true,
    .programUniformMatrix3x4fv = true,
    .programUniformMatrix4x3fv = true,
    .programUniformMatrix2x3dv = true,
    .programUniformMatrix3x2dv = true,
    .programUniformMatrix2x4dv = true,
    .programUniformMatrix4x2dv = true,
    .programUniformMatrix3x4dv = true,
    .programUniformMatrix4x3dv = true,
    .validateProgramPipeline = true,
    .getProgramPipelineInfoLog = true,
    .vertexAttribL1d = true,
    .vertexAttribL2d = true,
    .vertexAttribL3d = true,
    .vertexAttribL4d = true,
    .vertexAttribL1dv = true,
    .vertexAttribL2dv = true,
    .vertexAttribL3dv = true,
    .vertexAttribL4dv = true,
    .vertexAttribLPointer = true,
    .getVertexAttribLdv = true,
    .viewportArrayv = true,
    .viewportIndexedf = true,
    .viewportIndexedfv = true,
    .scissorArrayv = true,
    .scissorIndexed = true,
    .scissorIndexedv = true,
    .depthRangeArrayv = true,
    .depthRangeIndexed = true,
    .getFloati_v = true,
    .getDoublei_v = true,
    .drawArraysInstancedBaseInstance = true,
    .drawElementsInstancedBaseInstance = true,
    .drawElementsInstancedBaseVertexBaseInstance = true,
    .getInternalformativ = true,
    .getActiveAtomicCounterBufferiv = true,
    .bindImageTexture = true,
    .memoryBarrier = true,
    .texStorage1D = true,
    .texStorage2D = true,
    .texStorage3D = true,
    .drawTransformFeedbackInstanced = true,
    .drawTransformFeedbackStreamInstanced = true,
};

pub const gl43 = CommandFlags{
    .cullFace = true,
    .frontFace = true,
    .hint = true,
    .lineWidth = true,
    .pointSize = true,
    .polygonMode = true,
    .scissor = true,
    .texParameterf = true,
    .texParameterfv = true,
    .texParameteri = true,
    .texParameteriv = true,
    .texImage1D = true,
    .texImage2D = true,
    .drawBuffer = true,
    .clear = true,
    .clearColor = true,
    .clearStencil = true,
    .clearDepth = true,
    .stencilMask = true,
    .colorMask = true,
    .depthMask = true,
    .disable = true,
    .enable = true,
    .finish = true,
    .flush = true,
    .blendFunc = true,
    .logicOp = true,
    .stencilFunc = true,
    .stencilOp = true,
    .depthFunc = true,
    .pixelStoref = true,
    .pixelStorei = true,
    .readBuffer = true,
    .readPixels = true,
    .getBooleanv = true,
    .getDoublev = true,
    .getError = true,
    .getFloatv = true,
    .getIntegerv = true,
    .getString = true,
    .getTexImage = true,
    .getTexParameterfv = true,
    .getTexParameteriv = true,
    .getTexLevelParameterfv = true,
    .getTexLevelParameteriv = true,
    .isEnabled = true,
    .depthRange = true,
    .viewport = true,
    .newList = true,
    .endList = true,
    .callList = true,
    .callLists = true,
    .deleteLists = true,
    .genLists = true,
    .listBase = true,
    .begin = true,
    .bitmap = true,
    .color3b = true,
    .color3bv = true,
    .color3d = true,
    .color3dv = true,
    .color3f = true,
    .color3fv = true,
    .color3i = true,
    .color3iv = true,
    .color3s = true,
    .color3sv = true,
    .color3ub = true,
    .color3ubv = true,
    .color3ui = true,
    .color3uiv = true,
    .color3us = true,
    .color3usv = true,
    .color4b = true,
    .color4bv = true,
    .color4d = true,
    .color4dv = true,
    .color4f = true,
    .color4fv = true,
    .color4i = true,
    .color4iv = true,
    .color4s = true,
    .color4sv = true,
    .color4ub = true,
    .color4ubv = true,
    .color4ui = true,
    .color4uiv = true,
    .color4us = true,
    .color4usv = true,
    .edgeFlag = true,
    .edgeFlagv = true,
    .end = true,
    .indexd = true,
    .indexdv = true,
    .indexf = true,
    .indexfv = true,
    .indexi = true,
    .indexiv = true,
    .indexs = true,
    .indexsv = true,
    .normal3b = true,
    .normal3bv = true,
    .normal3d = true,
    .normal3dv = true,
    .normal3f = true,
    .normal3fv = true,
    .normal3i = true,
    .normal3iv = true,
    .normal3s = true,
    .normal3sv = true,
    .rasterPos2d = true,
    .rasterPos2dv = true,
    .rasterPos2f = true,
    .rasterPos2fv = true,
    .rasterPos2i = true,
    .rasterPos2iv = true,
    .rasterPos2s = true,
    .rasterPos2sv = true,
    .rasterPos3d = true,
    .rasterPos3dv = true,
    .rasterPos3f = true,
    .rasterPos3fv = true,
    .rasterPos3i = true,
    .rasterPos3iv = true,
    .rasterPos3s = true,
    .rasterPos3sv = true,
    .rasterPos4d = true,
    .rasterPos4dv = true,
    .rasterPos4f = true,
    .rasterPos4fv = true,
    .rasterPos4i = true,
    .rasterPos4iv = true,
    .rasterPos4s = true,
    .rasterPos4sv = true,
    .rectd = true,
    .rectdv = true,
    .rectf = true,
    .rectfv = true,
    .recti = true,
    .rectiv = true,
    .rects = true,
    .rectsv = true,
    .texCoord1d = true,
    .texCoord1dv = true,
    .texCoord1f = true,
    .texCoord1fv = true,
    .texCoord1i = true,
    .texCoord1iv = true,
    .texCoord1s = true,
    .texCoord1sv = true,
    .texCoord2d = true,
    .texCoord2dv = true,
    .texCoord2f = true,
    .texCoord2fv = true,
    .texCoord2i = true,
    .texCoord2iv = true,
    .texCoord2s = true,
    .texCoord2sv = true,
    .texCoord3d = true,
    .texCoord3dv = true,
    .texCoord3f = true,
    .texCoord3fv = true,
    .texCoord3i = true,
    .texCoord3iv = true,
    .texCoord3s = true,
    .texCoord3sv = true,
    .texCoord4d = true,
    .texCoord4dv = true,
    .texCoord4f = true,
    .texCoord4fv = true,
    .texCoord4i = true,
    .texCoord4iv = true,
    .texCoord4s = true,
    .texCoord4sv = true,
    .vertex2d = true,
    .vertex2dv = true,
    .vertex2f = true,
    .vertex2fv = true,
    .vertex2i = true,
    .vertex2iv = true,
    .vertex2s = true,
    .vertex2sv = true,
    .vertex3d = true,
    .vertex3dv = true,
    .vertex3f = true,
    .vertex3fv = true,
    .vertex3i = true,
    .vertex3iv = true,
    .vertex3s = true,
    .vertex3sv = true,
    .vertex4d = true,
    .vertex4dv = true,
    .vertex4f = true,
    .vertex4fv = true,
    .vertex4i = true,
    .vertex4iv = true,
    .vertex4s = true,
    .vertex4sv = true,
    .clipPlane = true,
    .colorMaterial = true,
    .fogf = true,
    .fogfv = true,
    .fogi = true,
    .fogiv = true,
    .lightf = true,
    .lightfv = true,
    .lighti = true,
    .lightiv = true,
    .lightModelf = true,
    .lightModelfv = true,
    .lightModeli = true,
    .lightModeliv = true,
    .lineStipple = true,
    .materialf = true,
    .materialfv = true,
    .materiali = true,
    .materialiv = true,
    .polygonStipple = true,
    .shadeModel = true,
    .texEnvf = true,
    .texEnvfv = true,
    .texEnvi = true,
    .texEnviv = true,
    .texGend = true,
    .texGendv = true,
    .texGenf = true,
    .texGenfv = true,
    .texGeni = true,
    .texGeniv = true,
    .feedbackBuffer = true,
    .selectBuffer = true,
    .renderMode = true,
    .initNames = true,
    .loadName = true,
    .passThrough = true,
    .popName = true,
    .pushName = true,
    .clearAccum = true,
    .clearIndex = true,
    .indexMask = true,
    .accum = true,
    .popAttrib = true,
    .pushAttrib = true,
    .map1d = true,
    .map1f = true,
    .map2d = true,
    .map2f = true,
    .mapGrid1d = true,
    .mapGrid1f = true,
    .mapGrid2d = true,
    .mapGrid2f = true,
    .evalCoord1d = true,
    .evalCoord1dv = true,
    .evalCoord1f = true,
    .evalCoord1fv = true,
    .evalCoord2d = true,
    .evalCoord2dv = true,
    .evalCoord2f = true,
    .evalCoord2fv = true,
    .evalMesh1 = true,
    .evalPoint1 = true,
    .evalMesh2 = true,
    .evalPoint2 = true,
    .alphaFunc = true,
    .pixelZoom = true,
    .pixelTransferf = true,
    .pixelTransferi = true,
    .pixelMapfv = true,
    .pixelMapuiv = true,
    .pixelMapusv = true,
    .copyPixels = true,
    .drawPixels = true,
    .getClipPlane = true,
    .getLightfv = true,
    .getLightiv = true,
    .getMapdv = true,
    .getMapfv = true,
    .getMapiv = true,
    .getMaterialfv = true,
    .getMaterialiv = true,
    .getPixelMapfv = true,
    .getPixelMapuiv = true,
    .getPixelMapusv = true,
    .getPolygonStipple = true,
    .getTexEnvfv = true,
    .getTexEnviv = true,
    .getTexGendv = true,
    .getTexGenfv = true,
    .getTexGeniv = true,
    .isList = true,
    .frustum = true,
    .loadIdentity = true,
    .loadMatrixf = true,
    .loadMatrixd = true,
    .matrixMode = true,
    .multMatrixf = true,
    .multMatrixd = true,
    .ortho = true,
    .popMatrix = true,
    .pushMatrix = true,
    .rotated = true,
    .rotatef = true,
    .scaled = true,
    .scalef = true,
    .translated = true,
    .translatef = true,
    .drawArrays = true,
    .drawElements = true,
    .getPointerv = true,
    .polygonOffset = true,
    .copyTexImage1D = true,
    .copyTexImage2D = true,
    .copyTexSubImage1D = true,
    .copyTexSubImage2D = true,
    .texSubImage1D = true,
    .texSubImage2D = true,
    .bindTexture = true,
    .deleteTextures = true,
    .genTextures = true,
    .isTexture = true,
    .arrayElement = true,
    .colorPointer = true,
    .disableClientState = true,
    .edgeFlagPointer = true,
    .enableClientState = true,
    .indexPointer = true,
    .interleavedArrays = true,
    .normalPointer = true,
    .texCoordPointer = true,
    .vertexPointer = true,
    .areTexturesResident = true,
    .prioritizeTextures = true,
    .indexub = true,
    .indexubv = true,
    .popClientAttrib = true,
    .pushClientAttrib = true,
    .drawRangeElements = true,
    .texImage3D = true,
    .texSubImage3D = true,
    .copyTexSubImage3D = true,
    .activeTexture = true,
    .sampleCoverage = true,
    .compressedTexImage3D = true,
    .compressedTexImage2D = true,
    .compressedTexImage1D = true,
    .compressedTexSubImage3D = true,
    .compressedTexSubImage2D = true,
    .compressedTexSubImage1D = true,
    .getCompressedTexImage = true,
    .clientActiveTexture = true,
    .multiTexCoord1d = true,
    .multiTexCoord1dv = true,
    .multiTexCoord1f = true,
    .multiTexCoord1fv = true,
    .multiTexCoord1i = true,
    .multiTexCoord1iv = true,
    .multiTexCoord1s = true,
    .multiTexCoord1sv = true,
    .multiTexCoord2d = true,
    .multiTexCoord2dv = true,
    .multiTexCoord2f = true,
    .multiTexCoord2fv = true,
    .multiTexCoord2i = true,
    .multiTexCoord2iv = true,
    .multiTexCoord2s = true,
    .multiTexCoord2sv = true,
    .multiTexCoord3d = true,
    .multiTexCoord3dv = true,
    .multiTexCoord3f = true,
    .multiTexCoord3fv = true,
    .multiTexCoord3i = true,
    .multiTexCoord3iv = true,
    .multiTexCoord3s = true,
    .multiTexCoord3sv = true,
    .multiTexCoord4d = true,
    .multiTexCoord4dv = true,
    .multiTexCoord4f = true,
    .multiTexCoord4fv = true,
    .multiTexCoord4i = true,
    .multiTexCoord4iv = true,
    .multiTexCoord4s = true,
    .multiTexCoord4sv = true,
    .loadTransposeMatrixf = true,
    .loadTransposeMatrixd = true,
    .multTransposeMatrixf = true,
    .multTransposeMatrixd = true,
    .blendFuncSeparate = true,
    .multiDrawArrays = true,
    .multiDrawElements = true,
    .pointParameterf = true,
    .pointParameterfv = true,
    .pointParameteri = true,
    .pointParameteriv = true,
    .fogCoordf = true,
    .fogCoordfv = true,
    .fogCoordd = true,
    .fogCoorddv = true,
    .fogCoordPointer = true,
    .secondaryColor3b = true,
    .secondaryColor3bv = true,
    .secondaryColor3d = true,
    .secondaryColor3dv = true,
    .secondaryColor3f = true,
    .secondaryColor3fv = true,
    .secondaryColor3i = true,
    .secondaryColor3iv = true,
    .secondaryColor3s = true,
    .secondaryColor3sv = true,
    .secondaryColor3ub = true,
    .secondaryColor3ubv = true,
    .secondaryColor3ui = true,
    .secondaryColor3uiv = true,
    .secondaryColor3us = true,
    .secondaryColor3usv = true,
    .secondaryColorPointer = true,
    .windowPos2d = true,
    .windowPos2dv = true,
    .windowPos2f = true,
    .windowPos2fv = true,
    .windowPos2i = true,
    .windowPos2iv = true,
    .windowPos2s = true,
    .windowPos2sv = true,
    .windowPos3d = true,
    .windowPos3dv = true,
    .windowPos3f = true,
    .windowPos3fv = true,
    .windowPos3i = true,
    .windowPos3iv = true,
    .windowPos3s = true,
    .windowPos3sv = true,
    .blendColor = true,
    .blendEquation = true,
    .genQueries = true,
    .deleteQueries = true,
    .isQuery = true,
    .beginQuery = true,
    .endQuery = true,
    .getQueryiv = true,
    .getQueryObjectiv = true,
    .getQueryObjectuiv = true,
    .bindBuffer = true,
    .deleteBuffers = true,
    .genBuffers = true,
    .isBuffer = true,
    .bufferData = true,
    .bufferSubData = true,
    .getBufferSubData = true,
    .mapBuffer = true,
    .unmapBuffer = true,
    .getBufferParameteriv = true,
    .getBufferPointerv = true,
    .blendEquationSeparate = true,
    .drawBuffers = true,
    .stencilOpSeparate = true,
    .stencilFuncSeparate = true,
    .stencilMaskSeparate = true,
    .attachShader = true,
    .bindAttribLocation = true,
    .compileShader = true,
    .createProgram = true,
    .createShader = true,
    .deleteProgram = true,
    .deleteShader = true,
    .detachShader = true,
    .disableVertexAttribArray = true,
    .enableVertexAttribArray = true,
    .getActiveAttrib = true,
    .getActiveUniform = true,
    .getAttachedShaders = true,
    .getAttribLocation = true,
    .getProgramiv = true,
    .getProgramInfoLog = true,
    .getShaderiv = true,
    .getShaderInfoLog = true,
    .getShaderSource = true,
    .getUniformLocation = true,
    .getUniformfv = true,
    .getUniformiv = true,
    .getVertexAttribdv = true,
    .getVertexAttribfv = true,
    .getVertexAttribiv = true,
    .getVertexAttribPointerv = true,
    .isProgram = true,
    .isShader = true,
    .linkProgram = true,
    .shaderSource = true,
    .useProgram = true,
    .uniform1f = true,
    .uniform2f = true,
    .uniform3f = true,
    .uniform4f = true,
    .uniform1i = true,
    .uniform2i = true,
    .uniform3i = true,
    .uniform4i = true,
    .uniform1fv = true,
    .uniform2fv = true,
    .uniform3fv = true,
    .uniform4fv = true,
    .uniform1iv = true,
    .uniform2iv = true,
    .uniform3iv = true,
    .uniform4iv = true,
    .uniformMatrix2fv = true,
    .uniformMatrix3fv = true,
    .uniformMatrix4fv = true,
    .validateProgram = true,
    .vertexAttrib1d = true,
    .vertexAttrib1dv = true,
    .vertexAttrib1f = true,
    .vertexAttrib1fv = true,
    .vertexAttrib1s = true,
    .vertexAttrib1sv = true,
    .vertexAttrib2d = true,
    .vertexAttrib2dv = true,
    .vertexAttrib2f = true,
    .vertexAttrib2fv = true,
    .vertexAttrib2s = true,
    .vertexAttrib2sv = true,
    .vertexAttrib3d = true,
    .vertexAttrib3dv = true,
    .vertexAttrib3f = true,
    .vertexAttrib3fv = true,
    .vertexAttrib3s = true,
    .vertexAttrib3sv = true,
    .vertexAttrib4Nbv = true,
    .vertexAttrib4Niv = true,
    .vertexAttrib4Nsv = true,
    .vertexAttrib4Nub = true,
    .vertexAttrib4Nubv = true,
    .vertexAttrib4Nuiv = true,
    .vertexAttrib4Nusv = true,
    .vertexAttrib4bv = true,
    .vertexAttrib4d = true,
    .vertexAttrib4dv = true,
    .vertexAttrib4f = true,
    .vertexAttrib4fv = true,
    .vertexAttrib4iv = true,
    .vertexAttrib4s = true,
    .vertexAttrib4sv = true,
    .vertexAttrib4ubv = true,
    .vertexAttrib4uiv = true,
    .vertexAttrib4usv = true,
    .vertexAttribPointer = true,
    .uniformMatrix2x3fv = true,
    .uniformMatrix3x2fv = true,
    .uniformMatrix2x4fv = true,
    .uniformMatrix4x2fv = true,
    .uniformMatrix3x4fv = true,
    .uniformMatrix4x3fv = true,
    .colorMaski = true,
    .getBooleani_v = true,
    .getIntegeri_v = true,
    .enablei = true,
    .disablei = true,
    .isEnabledi = true,
    .beginTransformFeedback = true,
    .endTransformFeedback = true,
    .bindBufferRange = true,
    .bindBufferBase = true,
    .transformFeedbackVaryings = true,
    .getTransformFeedbackVarying = true,
    .clampColor = true,
    .beginConditionalRender = true,
    .endConditionalRender = true,
    .vertexAttribIPointer = true,
    .getVertexAttribIiv = true,
    .getVertexAttribIuiv = true,
    .vertexAttribI1i = true,
    .vertexAttribI2i = true,
    .vertexAttribI3i = true,
    .vertexAttribI4i = true,
    .vertexAttribI1ui = true,
    .vertexAttribI2ui = true,
    .vertexAttribI3ui = true,
    .vertexAttribI4ui = true,
    .vertexAttribI1iv = true,
    .vertexAttribI2iv = true,
    .vertexAttribI3iv = true,
    .vertexAttribI4iv = true,
    .vertexAttribI1uiv = true,
    .vertexAttribI2uiv = true,
    .vertexAttribI3uiv = true,
    .vertexAttribI4uiv = true,
    .vertexAttribI4bv = true,
    .vertexAttribI4sv = true,
    .vertexAttribI4ubv = true,
    .vertexAttribI4usv = true,
    .getUniformuiv = true,
    .bindFragDataLocation = true,
    .getFragDataLocation = true,
    .uniform1ui = true,
    .uniform2ui = true,
    .uniform3ui = true,
    .uniform4ui = true,
    .uniform1uiv = true,
    .uniform2uiv = true,
    .uniform3uiv = true,
    .uniform4uiv = true,
    .texParameterIiv = true,
    .texParameterIuiv = true,
    .getTexParameterIiv = true,
    .getTexParameterIuiv = true,
    .clearBufferiv = true,
    .clearBufferuiv = true,
    .clearBufferfv = true,
    .clearBufferfi = true,
    .getStringi = true,
    .isRenderbuffer = true,
    .bindRenderbuffer = true,
    .deleteRenderbuffers = true,
    .genRenderbuffers = true,
    .renderbufferStorage = true,
    .getRenderbufferParameteriv = true,
    .isFramebuffer = true,
    .bindFramebuffer = true,
    .deleteFramebuffers = true,
    .genFramebuffers = true,
    .checkFramebufferStatus = true,
    .framebufferTexture1D = true,
    .framebufferTexture2D = true,
    .framebufferTexture3D = true,
    .framebufferRenderbuffer = true,
    .getFramebufferAttachmentParameteriv = true,
    .generateMipmap = true,
    .blitFramebuffer = true,
    .renderbufferStorageMultisample = true,
    .framebufferTextureLayer = true,
    .mapBufferRange = true,
    .flushMappedBufferRange = true,
    .bindVertexArray = true,
    .deleteVertexArrays = true,
    .genVertexArrays = true,
    .isVertexArray = true,
    .drawArraysInstanced = true,
    .drawElementsInstanced = true,
    .texBuffer = true,
    .primitiveRestartIndex = true,
    .copyBufferSubData = true,
    .getUniformIndices = true,
    .getActiveUniformsiv = true,
    .getActiveUniformName = true,
    .getUniformBlockIndex = true,
    .getActiveUniformBlockiv = true,
    .getActiveUniformBlockName = true,
    .uniformBlockBinding = true,
    .drawElementsBaseVertex = true,
    .drawRangeElementsBaseVertex = true,
    .drawElementsInstancedBaseVertex = true,
    .multiDrawElementsBaseVertex = true,
    .provokingVertex = true,
    .fenceSync = true,
    .isSync = true,
    .deleteSync = true,
    .clientWaitSync = true,
    .waitSync = true,
    .getInteger64v = true,
    .getSynciv = true,
    .getInteger64i_v = true,
    .getBufferParameteri64v = true,
    .framebufferTexture = true,
    .texImage2DMultisample = true,
    .texImage3DMultisample = true,
    .getMultisamplefv = true,
    .sampleMaski = true,
    .bindFragDataLocationIndexed = true,
    .getFragDataIndex = true,
    .genSamplers = true,
    .deleteSamplers = true,
    .isSampler = true,
    .bindSampler = true,
    .samplerParameteri = true,
    .samplerParameteriv = true,
    .samplerParameterf = true,
    .samplerParameterfv = true,
    .samplerParameterIiv = true,
    .samplerParameterIuiv = true,
    .getSamplerParameteriv = true,
    .getSamplerParameterIiv = true,
    .getSamplerParameterfv = true,
    .getSamplerParameterIuiv = true,
    .queryCounter = true,
    .getQueryObjecti64v = true,
    .getQueryObjectui64v = true,
    .vertexAttribDivisor = true,
    .vertexAttribP1ui = true,
    .vertexAttribP1uiv = true,
    .vertexAttribP2ui = true,
    .vertexAttribP2uiv = true,
    .vertexAttribP3ui = true,
    .vertexAttribP3uiv = true,
    .vertexAttribP4ui = true,
    .vertexAttribP4uiv = true,
    .vertexP2ui = true,
    .vertexP2uiv = true,
    .vertexP3ui = true,
    .vertexP3uiv = true,
    .vertexP4ui = true,
    .vertexP4uiv = true,
    .texCoordP1ui = true,
    .texCoordP1uiv = true,
    .texCoordP2ui = true,
    .texCoordP2uiv = true,
    .texCoordP3ui = true,
    .texCoordP3uiv = true,
    .texCoordP4ui = true,
    .texCoordP4uiv = true,
    .multiTexCoordP1ui = true,
    .multiTexCoordP1uiv = true,
    .multiTexCoordP2ui = true,
    .multiTexCoordP2uiv = true,
    .multiTexCoordP3ui = true,
    .multiTexCoordP3uiv = true,
    .multiTexCoordP4ui = true,
    .multiTexCoordP4uiv = true,
    .normalP3ui = true,
    .normalP3uiv = true,
    .colorP3ui = true,
    .colorP3uiv = true,
    .colorP4ui = true,
    .colorP4uiv = true,
    .secondaryColorP3ui = true,
    .secondaryColorP3uiv = true,
    .minSampleShading = true,
    .blendEquationi = true,
    .blendEquationSeparatei = true,
    .blendFunci = true,
    .blendFuncSeparatei = true,
    .drawArraysIndirect = true,
    .drawElementsIndirect = true,
    .uniform1d = true,
    .uniform2d = true,
    .uniform3d = true,
    .uniform4d = true,
    .uniform1dv = true,
    .uniform2dv = true,
    .uniform3dv = true,
    .uniform4dv = true,
    .uniformMatrix2dv = true,
    .uniformMatrix3dv = true,
    .uniformMatrix4dv = true,
    .uniformMatrix2x3dv = true,
    .uniformMatrix2x4dv = true,
    .uniformMatrix3x2dv = true,
    .uniformMatrix3x4dv = true,
    .uniformMatrix4x2dv = true,
    .uniformMatrix4x3dv = true,
    .getUniformdv = true,
    .getSubroutineUniformLocation = true,
    .getSubroutineIndex = true,
    .getActiveSubroutineUniformiv = true,
    .getActiveSubroutineUniformName = true,
    .getActiveSubroutineName = true,
    .uniformSubroutinesuiv = true,
    .getUniformSubroutineuiv = true,
    .getProgramStageiv = true,
    .patchParameteri = true,
    .patchParameterfv = true,
    .bindTransformFeedback = true,
    .deleteTransformFeedbacks = true,
    .genTransformFeedbacks = true,
    .isTransformFeedback = true,
    .pauseTransformFeedback = true,
    .resumeTransformFeedback = true,
    .drawTransformFeedback = true,
    .drawTransformFeedbackStream = true,
    .beginQueryIndexed = true,
    .endQueryIndexed = true,
    .getQueryIndexediv = true,
    .releaseShaderCompiler = true,
    .shaderBinary = true,
    .getShaderPrecisionFormat = true,
    .depthRangef = true,
    .clearDepthf = true,
    .getProgramBinary = true,
    .programBinary = true,
    .programParameteri = true,
    .useProgramStages = true,
    .activeShaderProgram = true,
    .createShaderProgramv = true,
    .bindProgramPipeline = true,
    .deleteProgramPipelines = true,
    .genProgramPipelines = true,
    .isProgramPipeline = true,
    .getProgramPipelineiv = true,
    .programUniform1i = true,
    .programUniform1iv = true,
    .programUniform1f = true,
    .programUniform1fv = true,
    .programUniform1d = true,
    .programUniform1dv = true,
    .programUniform1ui = true,
    .programUniform1uiv = true,
    .programUniform2i = true,
    .programUniform2iv = true,
    .programUniform2f = true,
    .programUniform2fv = true,
    .programUniform2d = true,
    .programUniform2dv = true,
    .programUniform2ui = true,
    .programUniform2uiv = true,
    .programUniform3i = true,
    .programUniform3iv = true,
    .programUniform3f = true,
    .programUniform3fv = true,
    .programUniform3d = true,
    .programUniform3dv = true,
    .programUniform3ui = true,
    .programUniform3uiv = true,
    .programUniform4i = true,
    .programUniform4iv = true,
    .programUniform4f = true,
    .programUniform4fv = true,
    .programUniform4d = true,
    .programUniform4dv = true,
    .programUniform4ui = true,
    .programUniform4uiv = true,
    .programUniformMatrix2fv = true,
    .programUniformMatrix3fv = true,
    .programUniformMatrix4fv = true,
    .programUniformMatrix2dv = true,
    .programUniformMatrix3dv = true,
    .programUniformMatrix4dv = true,
    .programUniformMatrix2x3fv = true,
    .programUniformMatrix3x2fv = true,
    .programUniformMatrix2x4fv = true,
    .programUniformMatrix4x2fv = true,
    .programUniformMatrix3x4fv = true,
    .programUniformMatrix4x3fv = true,
    .programUniformMatrix2x3dv = true,
    .programUniformMatrix3x2dv = true,
    .programUniformMatrix2x4dv = true,
    .programUniformMatrix4x2dv = true,
    .programUniformMatrix3x4dv = true,
    .programUniformMatrix4x3dv = true,
    .validateProgramPipeline = true,
    .getProgramPipelineInfoLog = true,
    .vertexAttribL1d = true,
    .vertexAttribL2d = true,
    .vertexAttribL3d = true,
    .vertexAttribL4d = true,
    .vertexAttribL1dv = true,
    .vertexAttribL2dv = true,
    .vertexAttribL3dv = true,
    .vertexAttribL4dv = true,
    .vertexAttribLPointer = true,
    .getVertexAttribLdv = true,
    .viewportArrayv = true,
    .viewportIndexedf = true,
    .viewportIndexedfv = true,
    .scissorArrayv = true,
    .scissorIndexed = true,
    .scissorIndexedv = true,
    .depthRangeArrayv = true,
    .depthRangeIndexed = true,
    .getFloati_v = true,
    .getDoublei_v = true,
    .drawArraysInstancedBaseInstance = true,
    .drawElementsInstancedBaseInstance = true,
    .drawElementsInstancedBaseVertexBaseInstance = true,
    .getInternalformativ = true,
    .getActiveAtomicCounterBufferiv = true,
    .bindImageTexture = true,
    .memoryBarrier = true,
    .texStorage1D = true,
    .texStorage2D = true,
    .texStorage3D = true,
    .drawTransformFeedbackInstanced = true,
    .drawTransformFeedbackStreamInstanced = true,
    .clearBufferData = true,
    .clearBufferSubData = true,
    .dispatchCompute = true,
    .dispatchComputeIndirect = true,
    .copyImageSubData = true,
    .framebufferParameteri = true,
    .getFramebufferParameteriv = true,
    .getInternalformati64v = true,
    .invalidateTexSubImage = true,
    .invalidateTexImage = true,
    .invalidateBufferSubData = true,
    .invalidateBufferData = true,
    .invalidateFramebuffer = true,
    .invalidateSubFramebuffer = true,
    .multiDrawArraysIndirect = true,
    .multiDrawElementsIndirect = true,
    .getProgramInterfaceiv = true,
    .getProgramResourceIndex = true,
    .getProgramResourceName = true,
    .getProgramResourceiv = true,
    .getProgramResourceLocation = true,
    .getProgramResourceLocationIndex = true,
    .shaderStorageBlockBinding = true,
    .texBufferRange = true,
    .texStorage2DMultisample = true,
    .texStorage3DMultisample = true,
    .textureView = true,
    .bindVertexBuffer = true,
    .vertexAttribFormat = true,
    .vertexAttribIFormat = true,
    .vertexAttribLFormat = true,
    .vertexAttribBinding = true,
    .vertexBindingDivisor = true,
    .debugMessageControl = true,
    .debugMessageInsert = true,
    .debugMessageCallback = true,
    .getDebugMessageLog = true,
    .pushDebugGroup = true,
    .popDebugGroup = true,
    .objectLabel = true,
    .getObjectLabel = true,
    .objectPtrLabel = true,
    .getObjectPtrLabel = true,
};

pub const gl44 = CommandFlags{
    .cullFace = true,
    .frontFace = true,
    .hint = true,
    .lineWidth = true,
    .pointSize = true,
    .polygonMode = true,
    .scissor = true,
    .texParameterf = true,
    .texParameterfv = true,
    .texParameteri = true,
    .texParameteriv = true,
    .texImage1D = true,
    .texImage2D = true,
    .drawBuffer = true,
    .clear = true,
    .clearColor = true,
    .clearStencil = true,
    .clearDepth = true,
    .stencilMask = true,
    .colorMask = true,
    .depthMask = true,
    .disable = true,
    .enable = true,
    .finish = true,
    .flush = true,
    .blendFunc = true,
    .logicOp = true,
    .stencilFunc = true,
    .stencilOp = true,
    .depthFunc = true,
    .pixelStoref = true,
    .pixelStorei = true,
    .readBuffer = true,
    .readPixels = true,
    .getBooleanv = true,
    .getDoublev = true,
    .getError = true,
    .getFloatv = true,
    .getIntegerv = true,
    .getString = true,
    .getTexImage = true,
    .getTexParameterfv = true,
    .getTexParameteriv = true,
    .getTexLevelParameterfv = true,
    .getTexLevelParameteriv = true,
    .isEnabled = true,
    .depthRange = true,
    .viewport = true,
    .newList = true,
    .endList = true,
    .callList = true,
    .callLists = true,
    .deleteLists = true,
    .genLists = true,
    .listBase = true,
    .begin = true,
    .bitmap = true,
    .color3b = true,
    .color3bv = true,
    .color3d = true,
    .color3dv = true,
    .color3f = true,
    .color3fv = true,
    .color3i = true,
    .color3iv = true,
    .color3s = true,
    .color3sv = true,
    .color3ub = true,
    .color3ubv = true,
    .color3ui = true,
    .color3uiv = true,
    .color3us = true,
    .color3usv = true,
    .color4b = true,
    .color4bv = true,
    .color4d = true,
    .color4dv = true,
    .color4f = true,
    .color4fv = true,
    .color4i = true,
    .color4iv = true,
    .color4s = true,
    .color4sv = true,
    .color4ub = true,
    .color4ubv = true,
    .color4ui = true,
    .color4uiv = true,
    .color4us = true,
    .color4usv = true,
    .edgeFlag = true,
    .edgeFlagv = true,
    .end = true,
    .indexd = true,
    .indexdv = true,
    .indexf = true,
    .indexfv = true,
    .indexi = true,
    .indexiv = true,
    .indexs = true,
    .indexsv = true,
    .normal3b = true,
    .normal3bv = true,
    .normal3d = true,
    .normal3dv = true,
    .normal3f = true,
    .normal3fv = true,
    .normal3i = true,
    .normal3iv = true,
    .normal3s = true,
    .normal3sv = true,
    .rasterPos2d = true,
    .rasterPos2dv = true,
    .rasterPos2f = true,
    .rasterPos2fv = true,
    .rasterPos2i = true,
    .rasterPos2iv = true,
    .rasterPos2s = true,
    .rasterPos2sv = true,
    .rasterPos3d = true,
    .rasterPos3dv = true,
    .rasterPos3f = true,
    .rasterPos3fv = true,
    .rasterPos3i = true,
    .rasterPos3iv = true,
    .rasterPos3s = true,
    .rasterPos3sv = true,
    .rasterPos4d = true,
    .rasterPos4dv = true,
    .rasterPos4f = true,
    .rasterPos4fv = true,
    .rasterPos4i = true,
    .rasterPos4iv = true,
    .rasterPos4s = true,
    .rasterPos4sv = true,
    .rectd = true,
    .rectdv = true,
    .rectf = true,
    .rectfv = true,
    .recti = true,
    .rectiv = true,
    .rects = true,
    .rectsv = true,
    .texCoord1d = true,
    .texCoord1dv = true,
    .texCoord1f = true,
    .texCoord1fv = true,
    .texCoord1i = true,
    .texCoord1iv = true,
    .texCoord1s = true,
    .texCoord1sv = true,
    .texCoord2d = true,
    .texCoord2dv = true,
    .texCoord2f = true,
    .texCoord2fv = true,
    .texCoord2i = true,
    .texCoord2iv = true,
    .texCoord2s = true,
    .texCoord2sv = true,
    .texCoord3d = true,
    .texCoord3dv = true,
    .texCoord3f = true,
    .texCoord3fv = true,
    .texCoord3i = true,
    .texCoord3iv = true,
    .texCoord3s = true,
    .texCoord3sv = true,
    .texCoord4d = true,
    .texCoord4dv = true,
    .texCoord4f = true,
    .texCoord4fv = true,
    .texCoord4i = true,
    .texCoord4iv = true,
    .texCoord4s = true,
    .texCoord4sv = true,
    .vertex2d = true,
    .vertex2dv = true,
    .vertex2f = true,
    .vertex2fv = true,
    .vertex2i = true,
    .vertex2iv = true,
    .vertex2s = true,
    .vertex2sv = true,
    .vertex3d = true,
    .vertex3dv = true,
    .vertex3f = true,
    .vertex3fv = true,
    .vertex3i = true,
    .vertex3iv = true,
    .vertex3s = true,
    .vertex3sv = true,
    .vertex4d = true,
    .vertex4dv = true,
    .vertex4f = true,
    .vertex4fv = true,
    .vertex4i = true,
    .vertex4iv = true,
    .vertex4s = true,
    .vertex4sv = true,
    .clipPlane = true,
    .colorMaterial = true,
    .fogf = true,
    .fogfv = true,
    .fogi = true,
    .fogiv = true,
    .lightf = true,
    .lightfv = true,
    .lighti = true,
    .lightiv = true,
    .lightModelf = true,
    .lightModelfv = true,
    .lightModeli = true,
    .lightModeliv = true,
    .lineStipple = true,
    .materialf = true,
    .materialfv = true,
    .materiali = true,
    .materialiv = true,
    .polygonStipple = true,
    .shadeModel = true,
    .texEnvf = true,
    .texEnvfv = true,
    .texEnvi = true,
    .texEnviv = true,
    .texGend = true,
    .texGendv = true,
    .texGenf = true,
    .texGenfv = true,
    .texGeni = true,
    .texGeniv = true,
    .feedbackBuffer = true,
    .selectBuffer = true,
    .renderMode = true,
    .initNames = true,
    .loadName = true,
    .passThrough = true,
    .popName = true,
    .pushName = true,
    .clearAccum = true,
    .clearIndex = true,
    .indexMask = true,
    .accum = true,
    .popAttrib = true,
    .pushAttrib = true,
    .map1d = true,
    .map1f = true,
    .map2d = true,
    .map2f = true,
    .mapGrid1d = true,
    .mapGrid1f = true,
    .mapGrid2d = true,
    .mapGrid2f = true,
    .evalCoord1d = true,
    .evalCoord1dv = true,
    .evalCoord1f = true,
    .evalCoord1fv = true,
    .evalCoord2d = true,
    .evalCoord2dv = true,
    .evalCoord2f = true,
    .evalCoord2fv = true,
    .evalMesh1 = true,
    .evalPoint1 = true,
    .evalMesh2 = true,
    .evalPoint2 = true,
    .alphaFunc = true,
    .pixelZoom = true,
    .pixelTransferf = true,
    .pixelTransferi = true,
    .pixelMapfv = true,
    .pixelMapuiv = true,
    .pixelMapusv = true,
    .copyPixels = true,
    .drawPixels = true,
    .getClipPlane = true,
    .getLightfv = true,
    .getLightiv = true,
    .getMapdv = true,
    .getMapfv = true,
    .getMapiv = true,
    .getMaterialfv = true,
    .getMaterialiv = true,
    .getPixelMapfv = true,
    .getPixelMapuiv = true,
    .getPixelMapusv = true,
    .getPolygonStipple = true,
    .getTexEnvfv = true,
    .getTexEnviv = true,
    .getTexGendv = true,
    .getTexGenfv = true,
    .getTexGeniv = true,
    .isList = true,
    .frustum = true,
    .loadIdentity = true,
    .loadMatrixf = true,
    .loadMatrixd = true,
    .matrixMode = true,
    .multMatrixf = true,
    .multMatrixd = true,
    .ortho = true,
    .popMatrix = true,
    .pushMatrix = true,
    .rotated = true,
    .rotatef = true,
    .scaled = true,
    .scalef = true,
    .translated = true,
    .translatef = true,
    .drawArrays = true,
    .drawElements = true,
    .getPointerv = true,
    .polygonOffset = true,
    .copyTexImage1D = true,
    .copyTexImage2D = true,
    .copyTexSubImage1D = true,
    .copyTexSubImage2D = true,
    .texSubImage1D = true,
    .texSubImage2D = true,
    .bindTexture = true,
    .deleteTextures = true,
    .genTextures = true,
    .isTexture = true,
    .arrayElement = true,
    .colorPointer = true,
    .disableClientState = true,
    .edgeFlagPointer = true,
    .enableClientState = true,
    .indexPointer = true,
    .interleavedArrays = true,
    .normalPointer = true,
    .texCoordPointer = true,
    .vertexPointer = true,
    .areTexturesResident = true,
    .prioritizeTextures = true,
    .indexub = true,
    .indexubv = true,
    .popClientAttrib = true,
    .pushClientAttrib = true,
    .drawRangeElements = true,
    .texImage3D = true,
    .texSubImage3D = true,
    .copyTexSubImage3D = true,
    .activeTexture = true,
    .sampleCoverage = true,
    .compressedTexImage3D = true,
    .compressedTexImage2D = true,
    .compressedTexImage1D = true,
    .compressedTexSubImage3D = true,
    .compressedTexSubImage2D = true,
    .compressedTexSubImage1D = true,
    .getCompressedTexImage = true,
    .clientActiveTexture = true,
    .multiTexCoord1d = true,
    .multiTexCoord1dv = true,
    .multiTexCoord1f = true,
    .multiTexCoord1fv = true,
    .multiTexCoord1i = true,
    .multiTexCoord1iv = true,
    .multiTexCoord1s = true,
    .multiTexCoord1sv = true,
    .multiTexCoord2d = true,
    .multiTexCoord2dv = true,
    .multiTexCoord2f = true,
    .multiTexCoord2fv = true,
    .multiTexCoord2i = true,
    .multiTexCoord2iv = true,
    .multiTexCoord2s = true,
    .multiTexCoord2sv = true,
    .multiTexCoord3d = true,
    .multiTexCoord3dv = true,
    .multiTexCoord3f = true,
    .multiTexCoord3fv = true,
    .multiTexCoord3i = true,
    .multiTexCoord3iv = true,
    .multiTexCoord3s = true,
    .multiTexCoord3sv = true,
    .multiTexCoord4d = true,
    .multiTexCoord4dv = true,
    .multiTexCoord4f = true,
    .multiTexCoord4fv = true,
    .multiTexCoord4i = true,
    .multiTexCoord4iv = true,
    .multiTexCoord4s = true,
    .multiTexCoord4sv = true,
    .loadTransposeMatrixf = true,
    .loadTransposeMatrixd = true,
    .multTransposeMatrixf = true,
    .multTransposeMatrixd = true,
    .blendFuncSeparate = true,
    .multiDrawArrays = true,
    .multiDrawElements = true,
    .pointParameterf = true,
    .pointParameterfv = true,
    .pointParameteri = true,
    .pointParameteriv = true,
    .fogCoordf = true,
    .fogCoordfv = true,
    .fogCoordd = true,
    .fogCoorddv = true,
    .fogCoordPointer = true,
    .secondaryColor3b = true,
    .secondaryColor3bv = true,
    .secondaryColor3d = true,
    .secondaryColor3dv = true,
    .secondaryColor3f = true,
    .secondaryColor3fv = true,
    .secondaryColor3i = true,
    .secondaryColor3iv = true,
    .secondaryColor3s = true,
    .secondaryColor3sv = true,
    .secondaryColor3ub = true,
    .secondaryColor3ubv = true,
    .secondaryColor3ui = true,
    .secondaryColor3uiv = true,
    .secondaryColor3us = true,
    .secondaryColor3usv = true,
    .secondaryColorPointer = true,
    .windowPos2d = true,
    .windowPos2dv = true,
    .windowPos2f = true,
    .windowPos2fv = true,
    .windowPos2i = true,
    .windowPos2iv = true,
    .windowPos2s = true,
    .windowPos2sv = true,
    .windowPos3d = true,
    .windowPos3dv = true,
    .windowPos3f = true,
    .windowPos3fv = true,
    .windowPos3i = true,
    .windowPos3iv = true,
    .windowPos3s = true,
    .windowPos3sv = true,
    .blendColor = true,
    .blendEquation = true,
    .genQueries = true,
    .deleteQueries = true,
    .isQuery = true,
    .beginQuery = true,
    .endQuery = true,
    .getQueryiv = true,
    .getQueryObjectiv = true,
    .getQueryObjectuiv = true,
    .bindBuffer = true,
    .deleteBuffers = true,
    .genBuffers = true,
    .isBuffer = true,
    .bufferData = true,
    .bufferSubData = true,
    .getBufferSubData = true,
    .mapBuffer = true,
    .unmapBuffer = true,
    .getBufferParameteriv = true,
    .getBufferPointerv = true,
    .blendEquationSeparate = true,
    .drawBuffers = true,
    .stencilOpSeparate = true,
    .stencilFuncSeparate = true,
    .stencilMaskSeparate = true,
    .attachShader = true,
    .bindAttribLocation = true,
    .compileShader = true,
    .createProgram = true,
    .createShader = true,
    .deleteProgram = true,
    .deleteShader = true,
    .detachShader = true,
    .disableVertexAttribArray = true,
    .enableVertexAttribArray = true,
    .getActiveAttrib = true,
    .getActiveUniform = true,
    .getAttachedShaders = true,
    .getAttribLocation = true,
    .getProgramiv = true,
    .getProgramInfoLog = true,
    .getShaderiv = true,
    .getShaderInfoLog = true,
    .getShaderSource = true,
    .getUniformLocation = true,
    .getUniformfv = true,
    .getUniformiv = true,
    .getVertexAttribdv = true,
    .getVertexAttribfv = true,
    .getVertexAttribiv = true,
    .getVertexAttribPointerv = true,
    .isProgram = true,
    .isShader = true,
    .linkProgram = true,
    .shaderSource = true,
    .useProgram = true,
    .uniform1f = true,
    .uniform2f = true,
    .uniform3f = true,
    .uniform4f = true,
    .uniform1i = true,
    .uniform2i = true,
    .uniform3i = true,
    .uniform4i = true,
    .uniform1fv = true,
    .uniform2fv = true,
    .uniform3fv = true,
    .uniform4fv = true,
    .uniform1iv = true,
    .uniform2iv = true,
    .uniform3iv = true,
    .uniform4iv = true,
    .uniformMatrix2fv = true,
    .uniformMatrix3fv = true,
    .uniformMatrix4fv = true,
    .validateProgram = true,
    .vertexAttrib1d = true,
    .vertexAttrib1dv = true,
    .vertexAttrib1f = true,
    .vertexAttrib1fv = true,
    .vertexAttrib1s = true,
    .vertexAttrib1sv = true,
    .vertexAttrib2d = true,
    .vertexAttrib2dv = true,
    .vertexAttrib2f = true,
    .vertexAttrib2fv = true,
    .vertexAttrib2s = true,
    .vertexAttrib2sv = true,
    .vertexAttrib3d = true,
    .vertexAttrib3dv = true,
    .vertexAttrib3f = true,
    .vertexAttrib3fv = true,
    .vertexAttrib3s = true,
    .vertexAttrib3sv = true,
    .vertexAttrib4Nbv = true,
    .vertexAttrib4Niv = true,
    .vertexAttrib4Nsv = true,
    .vertexAttrib4Nub = true,
    .vertexAttrib4Nubv = true,
    .vertexAttrib4Nuiv = true,
    .vertexAttrib4Nusv = true,
    .vertexAttrib4bv = true,
    .vertexAttrib4d = true,
    .vertexAttrib4dv = true,
    .vertexAttrib4f = true,
    .vertexAttrib4fv = true,
    .vertexAttrib4iv = true,
    .vertexAttrib4s = true,
    .vertexAttrib4sv = true,
    .vertexAttrib4ubv = true,
    .vertexAttrib4uiv = true,
    .vertexAttrib4usv = true,
    .vertexAttribPointer = true,
    .uniformMatrix2x3fv = true,
    .uniformMatrix3x2fv = true,
    .uniformMatrix2x4fv = true,
    .uniformMatrix4x2fv = true,
    .uniformMatrix3x4fv = true,
    .uniformMatrix4x3fv = true,
    .colorMaski = true,
    .getBooleani_v = true,
    .getIntegeri_v = true,
    .enablei = true,
    .disablei = true,
    .isEnabledi = true,
    .beginTransformFeedback = true,
    .endTransformFeedback = true,
    .bindBufferRange = true,
    .bindBufferBase = true,
    .transformFeedbackVaryings = true,
    .getTransformFeedbackVarying = true,
    .clampColor = true,
    .beginConditionalRender = true,
    .endConditionalRender = true,
    .vertexAttribIPointer = true,
    .getVertexAttribIiv = true,
    .getVertexAttribIuiv = true,
    .vertexAttribI1i = true,
    .vertexAttribI2i = true,
    .vertexAttribI3i = true,
    .vertexAttribI4i = true,
    .vertexAttribI1ui = true,
    .vertexAttribI2ui = true,
    .vertexAttribI3ui = true,
    .vertexAttribI4ui = true,
    .vertexAttribI1iv = true,
    .vertexAttribI2iv = true,
    .vertexAttribI3iv = true,
    .vertexAttribI4iv = true,
    .vertexAttribI1uiv = true,
    .vertexAttribI2uiv = true,
    .vertexAttribI3uiv = true,
    .vertexAttribI4uiv = true,
    .vertexAttribI4bv = true,
    .vertexAttribI4sv = true,
    .vertexAttribI4ubv = true,
    .vertexAttribI4usv = true,
    .getUniformuiv = true,
    .bindFragDataLocation = true,
    .getFragDataLocation = true,
    .uniform1ui = true,
    .uniform2ui = true,
    .uniform3ui = true,
    .uniform4ui = true,
    .uniform1uiv = true,
    .uniform2uiv = true,
    .uniform3uiv = true,
    .uniform4uiv = true,
    .texParameterIiv = true,
    .texParameterIuiv = true,
    .getTexParameterIiv = true,
    .getTexParameterIuiv = true,
    .clearBufferiv = true,
    .clearBufferuiv = true,
    .clearBufferfv = true,
    .clearBufferfi = true,
    .getStringi = true,
    .isRenderbuffer = true,
    .bindRenderbuffer = true,
    .deleteRenderbuffers = true,
    .genRenderbuffers = true,
    .renderbufferStorage = true,
    .getRenderbufferParameteriv = true,
    .isFramebuffer = true,
    .bindFramebuffer = true,
    .deleteFramebuffers = true,
    .genFramebuffers = true,
    .checkFramebufferStatus = true,
    .framebufferTexture1D = true,
    .framebufferTexture2D = true,
    .framebufferTexture3D = true,
    .framebufferRenderbuffer = true,
    .getFramebufferAttachmentParameteriv = true,
    .generateMipmap = true,
    .blitFramebuffer = true,
    .renderbufferStorageMultisample = true,
    .framebufferTextureLayer = true,
    .mapBufferRange = true,
    .flushMappedBufferRange = true,
    .bindVertexArray = true,
    .deleteVertexArrays = true,
    .genVertexArrays = true,
    .isVertexArray = true,
    .drawArraysInstanced = true,
    .drawElementsInstanced = true,
    .texBuffer = true,
    .primitiveRestartIndex = true,
    .copyBufferSubData = true,
    .getUniformIndices = true,
    .getActiveUniformsiv = true,
    .getActiveUniformName = true,
    .getUniformBlockIndex = true,
    .getActiveUniformBlockiv = true,
    .getActiveUniformBlockName = true,
    .uniformBlockBinding = true,
    .drawElementsBaseVertex = true,
    .drawRangeElementsBaseVertex = true,
    .drawElementsInstancedBaseVertex = true,
    .multiDrawElementsBaseVertex = true,
    .provokingVertex = true,
    .fenceSync = true,
    .isSync = true,
    .deleteSync = true,
    .clientWaitSync = true,
    .waitSync = true,
    .getInteger64v = true,
    .getSynciv = true,
    .getInteger64i_v = true,
    .getBufferParameteri64v = true,
    .framebufferTexture = true,
    .texImage2DMultisample = true,
    .texImage3DMultisample = true,
    .getMultisamplefv = true,
    .sampleMaski = true,
    .bindFragDataLocationIndexed = true,
    .getFragDataIndex = true,
    .genSamplers = true,
    .deleteSamplers = true,
    .isSampler = true,
    .bindSampler = true,
    .samplerParameteri = true,
    .samplerParameteriv = true,
    .samplerParameterf = true,
    .samplerParameterfv = true,
    .samplerParameterIiv = true,
    .samplerParameterIuiv = true,
    .getSamplerParameteriv = true,
    .getSamplerParameterIiv = true,
    .getSamplerParameterfv = true,
    .getSamplerParameterIuiv = true,
    .queryCounter = true,
    .getQueryObjecti64v = true,
    .getQueryObjectui64v = true,
    .vertexAttribDivisor = true,
    .vertexAttribP1ui = true,
    .vertexAttribP1uiv = true,
    .vertexAttribP2ui = true,
    .vertexAttribP2uiv = true,
    .vertexAttribP3ui = true,
    .vertexAttribP3uiv = true,
    .vertexAttribP4ui = true,
    .vertexAttribP4uiv = true,
    .vertexP2ui = true,
    .vertexP2uiv = true,
    .vertexP3ui = true,
    .vertexP3uiv = true,
    .vertexP4ui = true,
    .vertexP4uiv = true,
    .texCoordP1ui = true,
    .texCoordP1uiv = true,
    .texCoordP2ui = true,
    .texCoordP2uiv = true,
    .texCoordP3ui = true,
    .texCoordP3uiv = true,
    .texCoordP4ui = true,
    .texCoordP4uiv = true,
    .multiTexCoordP1ui = true,
    .multiTexCoordP1uiv = true,
    .multiTexCoordP2ui = true,
    .multiTexCoordP2uiv = true,
    .multiTexCoordP3ui = true,
    .multiTexCoordP3uiv = true,
    .multiTexCoordP4ui = true,
    .multiTexCoordP4uiv = true,
    .normalP3ui = true,
    .normalP3uiv = true,
    .colorP3ui = true,
    .colorP3uiv = true,
    .colorP4ui = true,
    .colorP4uiv = true,
    .secondaryColorP3ui = true,
    .secondaryColorP3uiv = true,
    .minSampleShading = true,
    .blendEquationi = true,
    .blendEquationSeparatei = true,
    .blendFunci = true,
    .blendFuncSeparatei = true,
    .drawArraysIndirect = true,
    .drawElementsIndirect = true,
    .uniform1d = true,
    .uniform2d = true,
    .uniform3d = true,
    .uniform4d = true,
    .uniform1dv = true,
    .uniform2dv = true,
    .uniform3dv = true,
    .uniform4dv = true,
    .uniformMatrix2dv = true,
    .uniformMatrix3dv = true,
    .uniformMatrix4dv = true,
    .uniformMatrix2x3dv = true,
    .uniformMatrix2x4dv = true,
    .uniformMatrix3x2dv = true,
    .uniformMatrix3x4dv = true,
    .uniformMatrix4x2dv = true,
    .uniformMatrix4x3dv = true,
    .getUniformdv = true,
    .getSubroutineUniformLocation = true,
    .getSubroutineIndex = true,
    .getActiveSubroutineUniformiv = true,
    .getActiveSubroutineUniformName = true,
    .getActiveSubroutineName = true,
    .uniformSubroutinesuiv = true,
    .getUniformSubroutineuiv = true,
    .getProgramStageiv = true,
    .patchParameteri = true,
    .patchParameterfv = true,
    .bindTransformFeedback = true,
    .deleteTransformFeedbacks = true,
    .genTransformFeedbacks = true,
    .isTransformFeedback = true,
    .pauseTransformFeedback = true,
    .resumeTransformFeedback = true,
    .drawTransformFeedback = true,
    .drawTransformFeedbackStream = true,
    .beginQueryIndexed = true,
    .endQueryIndexed = true,
    .getQueryIndexediv = true,
    .releaseShaderCompiler = true,
    .shaderBinary = true,
    .getShaderPrecisionFormat = true,
    .depthRangef = true,
    .clearDepthf = true,
    .getProgramBinary = true,
    .programBinary = true,
    .programParameteri = true,
    .useProgramStages = true,
    .activeShaderProgram = true,
    .createShaderProgramv = true,
    .bindProgramPipeline = true,
    .deleteProgramPipelines = true,
    .genProgramPipelines = true,
    .isProgramPipeline = true,
    .getProgramPipelineiv = true,
    .programUniform1i = true,
    .programUniform1iv = true,
    .programUniform1f = true,
    .programUniform1fv = true,
    .programUniform1d = true,
    .programUniform1dv = true,
    .programUniform1ui = true,
    .programUniform1uiv = true,
    .programUniform2i = true,
    .programUniform2iv = true,
    .programUniform2f = true,
    .programUniform2fv = true,
    .programUniform2d = true,
    .programUniform2dv = true,
    .programUniform2ui = true,
    .programUniform2uiv = true,
    .programUniform3i = true,
    .programUniform3iv = true,
    .programUniform3f = true,
    .programUniform3fv = true,
    .programUniform3d = true,
    .programUniform3dv = true,
    .programUniform3ui = true,
    .programUniform3uiv = true,
    .programUniform4i = true,
    .programUniform4iv = true,
    .programUniform4f = true,
    .programUniform4fv = true,
    .programUniform4d = true,
    .programUniform4dv = true,
    .programUniform4ui = true,
    .programUniform4uiv = true,
    .programUniformMatrix2fv = true,
    .programUniformMatrix3fv = true,
    .programUniformMatrix4fv = true,
    .programUniformMatrix2dv = true,
    .programUniformMatrix3dv = true,
    .programUniformMatrix4dv = true,
    .programUniformMatrix2x3fv = true,
    .programUniformMatrix3x2fv = true,
    .programUniformMatrix2x4fv = true,
    .programUniformMatrix4x2fv = true,
    .programUniformMatrix3x4fv = true,
    .programUniformMatrix4x3fv = true,
    .programUniformMatrix2x3dv = true,
    .programUniformMatrix3x2dv = true,
    .programUniformMatrix2x4dv = true,
    .programUniformMatrix4x2dv = true,
    .programUniformMatrix3x4dv = true,
    .programUniformMatrix4x3dv = true,
    .validateProgramPipeline = true,
    .getProgramPipelineInfoLog = true,
    .vertexAttribL1d = true,
    .vertexAttribL2d = true,
    .vertexAttribL3d = true,
    .vertexAttribL4d = true,
    .vertexAttribL1dv = true,
    .vertexAttribL2dv = true,
    .vertexAttribL3dv = true,
    .vertexAttribL4dv = true,
    .vertexAttribLPointer = true,
    .getVertexAttribLdv = true,
    .viewportArrayv = true,
    .viewportIndexedf = true,
    .viewportIndexedfv = true,
    .scissorArrayv = true,
    .scissorIndexed = true,
    .scissorIndexedv = true,
    .depthRangeArrayv = true,
    .depthRangeIndexed = true,
    .getFloati_v = true,
    .getDoublei_v = true,
    .drawArraysInstancedBaseInstance = true,
    .drawElementsInstancedBaseInstance = true,
    .drawElementsInstancedBaseVertexBaseInstance = true,
    .getInternalformativ = true,
    .getActiveAtomicCounterBufferiv = true,
    .bindImageTexture = true,
    .memoryBarrier = true,
    .texStorage1D = true,
    .texStorage2D = true,
    .texStorage3D = true,
    .drawTransformFeedbackInstanced = true,
    .drawTransformFeedbackStreamInstanced = true,
    .clearBufferData = true,
    .clearBufferSubData = true,
    .dispatchCompute = true,
    .dispatchComputeIndirect = true,
    .copyImageSubData = true,
    .framebufferParameteri = true,
    .getFramebufferParameteriv = true,
    .getInternalformati64v = true,
    .invalidateTexSubImage = true,
    .invalidateTexImage = true,
    .invalidateBufferSubData = true,
    .invalidateBufferData = true,
    .invalidateFramebuffer = true,
    .invalidateSubFramebuffer = true,
    .multiDrawArraysIndirect = true,
    .multiDrawElementsIndirect = true,
    .getProgramInterfaceiv = true,
    .getProgramResourceIndex = true,
    .getProgramResourceName = true,
    .getProgramResourceiv = true,
    .getProgramResourceLocation = true,
    .getProgramResourceLocationIndex = true,
    .shaderStorageBlockBinding = true,
    .texBufferRange = true,
    .texStorage2DMultisample = true,
    .texStorage3DMultisample = true,
    .textureView = true,
    .bindVertexBuffer = true,
    .vertexAttribFormat = true,
    .vertexAttribIFormat = true,
    .vertexAttribLFormat = true,
    .vertexAttribBinding = true,
    .vertexBindingDivisor = true,
    .debugMessageControl = true,
    .debugMessageInsert = true,
    .debugMessageCallback = true,
    .getDebugMessageLog = true,
    .pushDebugGroup = true,
    .popDebugGroup = true,
    .objectLabel = true,
    .getObjectLabel = true,
    .objectPtrLabel = true,
    .getObjectPtrLabel = true,
    .bufferStorage = true,
    .clearTexImage = true,
    .clearTexSubImage = true,
    .bindBuffersBase = true,
    .bindBuffersRange = true,
    .bindTextures = true,
    .bindSamplers = true,
    .bindImageTextures = true,
    .bindVertexBuffers = true,
};

pub const gl45 = CommandFlags{
    .cullFace = true,
    .frontFace = true,
    .hint = true,
    .lineWidth = true,
    .pointSize = true,
    .polygonMode = true,
    .scissor = true,
    .texParameterf = true,
    .texParameterfv = true,
    .texParameteri = true,
    .texParameteriv = true,
    .texImage1D = true,
    .texImage2D = true,
    .drawBuffer = true,
    .clear = true,
    .clearColor = true,
    .clearStencil = true,
    .clearDepth = true,
    .stencilMask = true,
    .colorMask = true,
    .depthMask = true,
    .disable = true,
    .enable = true,
    .finish = true,
    .flush = true,
    .blendFunc = true,
    .logicOp = true,
    .stencilFunc = true,
    .stencilOp = true,
    .depthFunc = true,
    .pixelStoref = true,
    .pixelStorei = true,
    .readBuffer = true,
    .readPixels = true,
    .getBooleanv = true,
    .getDoublev = true,
    .getError = true,
    .getFloatv = true,
    .getIntegerv = true,
    .getString = true,
    .getTexImage = true,
    .getTexParameterfv = true,
    .getTexParameteriv = true,
    .getTexLevelParameterfv = true,
    .getTexLevelParameteriv = true,
    .isEnabled = true,
    .depthRange = true,
    .viewport = true,
    .newList = true,
    .endList = true,
    .callList = true,
    .callLists = true,
    .deleteLists = true,
    .genLists = true,
    .listBase = true,
    .begin = true,
    .bitmap = true,
    .color3b = true,
    .color3bv = true,
    .color3d = true,
    .color3dv = true,
    .color3f = true,
    .color3fv = true,
    .color3i = true,
    .color3iv = true,
    .color3s = true,
    .color3sv = true,
    .color3ub = true,
    .color3ubv = true,
    .color3ui = true,
    .color3uiv = true,
    .color3us = true,
    .color3usv = true,
    .color4b = true,
    .color4bv = true,
    .color4d = true,
    .color4dv = true,
    .color4f = true,
    .color4fv = true,
    .color4i = true,
    .color4iv = true,
    .color4s = true,
    .color4sv = true,
    .color4ub = true,
    .color4ubv = true,
    .color4ui = true,
    .color4uiv = true,
    .color4us = true,
    .color4usv = true,
    .edgeFlag = true,
    .edgeFlagv = true,
    .end = true,
    .indexd = true,
    .indexdv = true,
    .indexf = true,
    .indexfv = true,
    .indexi = true,
    .indexiv = true,
    .indexs = true,
    .indexsv = true,
    .normal3b = true,
    .normal3bv = true,
    .normal3d = true,
    .normal3dv = true,
    .normal3f = true,
    .normal3fv = true,
    .normal3i = true,
    .normal3iv = true,
    .normal3s = true,
    .normal3sv = true,
    .rasterPos2d = true,
    .rasterPos2dv = true,
    .rasterPos2f = true,
    .rasterPos2fv = true,
    .rasterPos2i = true,
    .rasterPos2iv = true,
    .rasterPos2s = true,
    .rasterPos2sv = true,
    .rasterPos3d = true,
    .rasterPos3dv = true,
    .rasterPos3f = true,
    .rasterPos3fv = true,
    .rasterPos3i = true,
    .rasterPos3iv = true,
    .rasterPos3s = true,
    .rasterPos3sv = true,
    .rasterPos4d = true,
    .rasterPos4dv = true,
    .rasterPos4f = true,
    .rasterPos4fv = true,
    .rasterPos4i = true,
    .rasterPos4iv = true,
    .rasterPos4s = true,
    .rasterPos4sv = true,
    .rectd = true,
    .rectdv = true,
    .rectf = true,
    .rectfv = true,
    .recti = true,
    .rectiv = true,
    .rects = true,
    .rectsv = true,
    .texCoord1d = true,
    .texCoord1dv = true,
    .texCoord1f = true,
    .texCoord1fv = true,
    .texCoord1i = true,
    .texCoord1iv = true,
    .texCoord1s = true,
    .texCoord1sv = true,
    .texCoord2d = true,
    .texCoord2dv = true,
    .texCoord2f = true,
    .texCoord2fv = true,
    .texCoord2i = true,
    .texCoord2iv = true,
    .texCoord2s = true,
    .texCoord2sv = true,
    .texCoord3d = true,
    .texCoord3dv = true,
    .texCoord3f = true,
    .texCoord3fv = true,
    .texCoord3i = true,
    .texCoord3iv = true,
    .texCoord3s = true,
    .texCoord3sv = true,
    .texCoord4d = true,
    .texCoord4dv = true,
    .texCoord4f = true,
    .texCoord4fv = true,
    .texCoord4i = true,
    .texCoord4iv = true,
    .texCoord4s = true,
    .texCoord4sv = true,
    .vertex2d = true,
    .vertex2dv = true,
    .vertex2f = true,
    .vertex2fv = true,
    .vertex2i = true,
    .vertex2iv = true,
    .vertex2s = true,
    .vertex2sv = true,
    .vertex3d = true,
    .vertex3dv = true,
    .vertex3f = true,
    .vertex3fv = true,
    .vertex3i = true,
    .vertex3iv = true,
    .vertex3s = true,
    .vertex3sv = true,
    .vertex4d = true,
    .vertex4dv = true,
    .vertex4f = true,
    .vertex4fv = true,
    .vertex4i = true,
    .vertex4iv = true,
    .vertex4s = true,
    .vertex4sv = true,
    .clipPlane = true,
    .colorMaterial = true,
    .fogf = true,
    .fogfv = true,
    .fogi = true,
    .fogiv = true,
    .lightf = true,
    .lightfv = true,
    .lighti = true,
    .lightiv = true,
    .lightModelf = true,
    .lightModelfv = true,
    .lightModeli = true,
    .lightModeliv = true,
    .lineStipple = true,
    .materialf = true,
    .materialfv = true,
    .materiali = true,
    .materialiv = true,
    .polygonStipple = true,
    .shadeModel = true,
    .texEnvf = true,
    .texEnvfv = true,
    .texEnvi = true,
    .texEnviv = true,
    .texGend = true,
    .texGendv = true,
    .texGenf = true,
    .texGenfv = true,
    .texGeni = true,
    .texGeniv = true,
    .feedbackBuffer = true,
    .selectBuffer = true,
    .renderMode = true,
    .initNames = true,
    .loadName = true,
    .passThrough = true,
    .popName = true,
    .pushName = true,
    .clearAccum = true,
    .clearIndex = true,
    .indexMask = true,
    .accum = true,
    .popAttrib = true,
    .pushAttrib = true,
    .map1d = true,
    .map1f = true,
    .map2d = true,
    .map2f = true,
    .mapGrid1d = true,
    .mapGrid1f = true,
    .mapGrid2d = true,
    .mapGrid2f = true,
    .evalCoord1d = true,
    .evalCoord1dv = true,
    .evalCoord1f = true,
    .evalCoord1fv = true,
    .evalCoord2d = true,
    .evalCoord2dv = true,
    .evalCoord2f = true,
    .evalCoord2fv = true,
    .evalMesh1 = true,
    .evalPoint1 = true,
    .evalMesh2 = true,
    .evalPoint2 = true,
    .alphaFunc = true,
    .pixelZoom = true,
    .pixelTransferf = true,
    .pixelTransferi = true,
    .pixelMapfv = true,
    .pixelMapuiv = true,
    .pixelMapusv = true,
    .copyPixels = true,
    .drawPixels = true,
    .getClipPlane = true,
    .getLightfv = true,
    .getLightiv = true,
    .getMapdv = true,
    .getMapfv = true,
    .getMapiv = true,
    .getMaterialfv = true,
    .getMaterialiv = true,
    .getPixelMapfv = true,
    .getPixelMapuiv = true,
    .getPixelMapusv = true,
    .getPolygonStipple = true,
    .getTexEnvfv = true,
    .getTexEnviv = true,
    .getTexGendv = true,
    .getTexGenfv = true,
    .getTexGeniv = true,
    .isList = true,
    .frustum = true,
    .loadIdentity = true,
    .loadMatrixf = true,
    .loadMatrixd = true,
    .matrixMode = true,
    .multMatrixf = true,
    .multMatrixd = true,
    .ortho = true,
    .popMatrix = true,
    .pushMatrix = true,
    .rotated = true,
    .rotatef = true,
    .scaled = true,
    .scalef = true,
    .translated = true,
    .translatef = true,
    .drawArrays = true,
    .drawElements = true,
    .getPointerv = true,
    .polygonOffset = true,
    .copyTexImage1D = true,
    .copyTexImage2D = true,
    .copyTexSubImage1D = true,
    .copyTexSubImage2D = true,
    .texSubImage1D = true,
    .texSubImage2D = true,
    .bindTexture = true,
    .deleteTextures = true,
    .genTextures = true,
    .isTexture = true,
    .arrayElement = true,
    .colorPointer = true,
    .disableClientState = true,
    .edgeFlagPointer = true,
    .enableClientState = true,
    .indexPointer = true,
    .interleavedArrays = true,
    .normalPointer = true,
    .texCoordPointer = true,
    .vertexPointer = true,
    .areTexturesResident = true,
    .prioritizeTextures = true,
    .indexub = true,
    .indexubv = true,
    .popClientAttrib = true,
    .pushClientAttrib = true,
    .drawRangeElements = true,
    .texImage3D = true,
    .texSubImage3D = true,
    .copyTexSubImage3D = true,
    .activeTexture = true,
    .sampleCoverage = true,
    .compressedTexImage3D = true,
    .compressedTexImage2D = true,
    .compressedTexImage1D = true,
    .compressedTexSubImage3D = true,
    .compressedTexSubImage2D = true,
    .compressedTexSubImage1D = true,
    .getCompressedTexImage = true,
    .clientActiveTexture = true,
    .multiTexCoord1d = true,
    .multiTexCoord1dv = true,
    .multiTexCoord1f = true,
    .multiTexCoord1fv = true,
    .multiTexCoord1i = true,
    .multiTexCoord1iv = true,
    .multiTexCoord1s = true,
    .multiTexCoord1sv = true,
    .multiTexCoord2d = true,
    .multiTexCoord2dv = true,
    .multiTexCoord2f = true,
    .multiTexCoord2fv = true,
    .multiTexCoord2i = true,
    .multiTexCoord2iv = true,
    .multiTexCoord2s = true,
    .multiTexCoord2sv = true,
    .multiTexCoord3d = true,
    .multiTexCoord3dv = true,
    .multiTexCoord3f = true,
    .multiTexCoord3fv = true,
    .multiTexCoord3i = true,
    .multiTexCoord3iv = true,
    .multiTexCoord3s = true,
    .multiTexCoord3sv = true,
    .multiTexCoord4d = true,
    .multiTexCoord4dv = true,
    .multiTexCoord4f = true,
    .multiTexCoord4fv = true,
    .multiTexCoord4i = true,
    .multiTexCoord4iv = true,
    .multiTexCoord4s = true,
    .multiTexCoord4sv = true,
    .loadTransposeMatrixf = true,
    .loadTransposeMatrixd = true,
    .multTransposeMatrixf = true,
    .multTransposeMatrixd = true,
    .blendFuncSeparate = true,
    .multiDrawArrays = true,
    .multiDrawElements = true,
    .pointParameterf = true,
    .pointParameterfv = true,
    .pointParameteri = true,
    .pointParameteriv = true,
    .fogCoordf = true,
    .fogCoordfv = true,
    .fogCoordd = true,
    .fogCoorddv = true,
    .fogCoordPointer = true,
    .secondaryColor3b = true,
    .secondaryColor3bv = true,
    .secondaryColor3d = true,
    .secondaryColor3dv = true,
    .secondaryColor3f = true,
    .secondaryColor3fv = true,
    .secondaryColor3i = true,
    .secondaryColor3iv = true,
    .secondaryColor3s = true,
    .secondaryColor3sv = true,
    .secondaryColor3ub = true,
    .secondaryColor3ubv = true,
    .secondaryColor3ui = true,
    .secondaryColor3uiv = true,
    .secondaryColor3us = true,
    .secondaryColor3usv = true,
    .secondaryColorPointer = true,
    .windowPos2d = true,
    .windowPos2dv = true,
    .windowPos2f = true,
    .windowPos2fv = true,
    .windowPos2i = true,
    .windowPos2iv = true,
    .windowPos2s = true,
    .windowPos2sv = true,
    .windowPos3d = true,
    .windowPos3dv = true,
    .windowPos3f = true,
    .windowPos3fv = true,
    .windowPos3i = true,
    .windowPos3iv = true,
    .windowPos3s = true,
    .windowPos3sv = true,
    .blendColor = true,
    .blendEquation = true,
    .genQueries = true,
    .deleteQueries = true,
    .isQuery = true,
    .beginQuery = true,
    .endQuery = true,
    .getQueryiv = true,
    .getQueryObjectiv = true,
    .getQueryObjectuiv = true,
    .bindBuffer = true,
    .deleteBuffers = true,
    .genBuffers = true,
    .isBuffer = true,
    .bufferData = true,
    .bufferSubData = true,
    .getBufferSubData = true,
    .mapBuffer = true,
    .unmapBuffer = true,
    .getBufferParameteriv = true,
    .getBufferPointerv = true,
    .blendEquationSeparate = true,
    .drawBuffers = true,
    .stencilOpSeparate = true,
    .stencilFuncSeparate = true,
    .stencilMaskSeparate = true,
    .attachShader = true,
    .bindAttribLocation = true,
    .compileShader = true,
    .createProgram = true,
    .createShader = true,
    .deleteProgram = true,
    .deleteShader = true,
    .detachShader = true,
    .disableVertexAttribArray = true,
    .enableVertexAttribArray = true,
    .getActiveAttrib = true,
    .getActiveUniform = true,
    .getAttachedShaders = true,
    .getAttribLocation = true,
    .getProgramiv = true,
    .getProgramInfoLog = true,
    .getShaderiv = true,
    .getShaderInfoLog = true,
    .getShaderSource = true,
    .getUniformLocation = true,
    .getUniformfv = true,
    .getUniformiv = true,
    .getVertexAttribdv = true,
    .getVertexAttribfv = true,
    .getVertexAttribiv = true,
    .getVertexAttribPointerv = true,
    .isProgram = true,
    .isShader = true,
    .linkProgram = true,
    .shaderSource = true,
    .useProgram = true,
    .uniform1f = true,
    .uniform2f = true,
    .uniform3f = true,
    .uniform4f = true,
    .uniform1i = true,
    .uniform2i = true,
    .uniform3i = true,
    .uniform4i = true,
    .uniform1fv = true,
    .uniform2fv = true,
    .uniform3fv = true,
    .uniform4fv = true,
    .uniform1iv = true,
    .uniform2iv = true,
    .uniform3iv = true,
    .uniform4iv = true,
    .uniformMatrix2fv = true,
    .uniformMatrix3fv = true,
    .uniformMatrix4fv = true,
    .validateProgram = true,
    .vertexAttrib1d = true,
    .vertexAttrib1dv = true,
    .vertexAttrib1f = true,
    .vertexAttrib1fv = true,
    .vertexAttrib1s = true,
    .vertexAttrib1sv = true,
    .vertexAttrib2d = true,
    .vertexAttrib2dv = true,
    .vertexAttrib2f = true,
    .vertexAttrib2fv = true,
    .vertexAttrib2s = true,
    .vertexAttrib2sv = true,
    .vertexAttrib3d = true,
    .vertexAttrib3dv = true,
    .vertexAttrib3f = true,
    .vertexAttrib3fv = true,
    .vertexAttrib3s = true,
    .vertexAttrib3sv = true,
    .vertexAttrib4Nbv = true,
    .vertexAttrib4Niv = true,
    .vertexAttrib4Nsv = true,
    .vertexAttrib4Nub = true,
    .vertexAttrib4Nubv = true,
    .vertexAttrib4Nuiv = true,
    .vertexAttrib4Nusv = true,
    .vertexAttrib4bv = true,
    .vertexAttrib4d = true,
    .vertexAttrib4dv = true,
    .vertexAttrib4f = true,
    .vertexAttrib4fv = true,
    .vertexAttrib4iv = true,
    .vertexAttrib4s = true,
    .vertexAttrib4sv = true,
    .vertexAttrib4ubv = true,
    .vertexAttrib4uiv = true,
    .vertexAttrib4usv = true,
    .vertexAttribPointer = true,
    .uniformMatrix2x3fv = true,
    .uniformMatrix3x2fv = true,
    .uniformMatrix2x4fv = true,
    .uniformMatrix4x2fv = true,
    .uniformMatrix3x4fv = true,
    .uniformMatrix4x3fv = true,
    .colorMaski = true,
    .getBooleani_v = true,
    .getIntegeri_v = true,
    .enablei = true,
    .disablei = true,
    .isEnabledi = true,
    .beginTransformFeedback = true,
    .endTransformFeedback = true,
    .bindBufferRange = true,
    .bindBufferBase = true,
    .transformFeedbackVaryings = true,
    .getTransformFeedbackVarying = true,
    .clampColor = true,
    .beginConditionalRender = true,
    .endConditionalRender = true,
    .vertexAttribIPointer = true,
    .getVertexAttribIiv = true,
    .getVertexAttribIuiv = true,
    .vertexAttribI1i = true,
    .vertexAttribI2i = true,
    .vertexAttribI3i = true,
    .vertexAttribI4i = true,
    .vertexAttribI1ui = true,
    .vertexAttribI2ui = true,
    .vertexAttribI3ui = true,
    .vertexAttribI4ui = true,
    .vertexAttribI1iv = true,
    .vertexAttribI2iv = true,
    .vertexAttribI3iv = true,
    .vertexAttribI4iv = true,
    .vertexAttribI1uiv = true,
    .vertexAttribI2uiv = true,
    .vertexAttribI3uiv = true,
    .vertexAttribI4uiv = true,
    .vertexAttribI4bv = true,
    .vertexAttribI4sv = true,
    .vertexAttribI4ubv = true,
    .vertexAttribI4usv = true,
    .getUniformuiv = true,
    .bindFragDataLocation = true,
    .getFragDataLocation = true,
    .uniform1ui = true,
    .uniform2ui = true,
    .uniform3ui = true,
    .uniform4ui = true,
    .uniform1uiv = true,
    .uniform2uiv = true,
    .uniform3uiv = true,
    .uniform4uiv = true,
    .texParameterIiv = true,
    .texParameterIuiv = true,
    .getTexParameterIiv = true,
    .getTexParameterIuiv = true,
    .clearBufferiv = true,
    .clearBufferuiv = true,
    .clearBufferfv = true,
    .clearBufferfi = true,
    .getStringi = true,
    .isRenderbuffer = true,
    .bindRenderbuffer = true,
    .deleteRenderbuffers = true,
    .genRenderbuffers = true,
    .renderbufferStorage = true,
    .getRenderbufferParameteriv = true,
    .isFramebuffer = true,
    .bindFramebuffer = true,
    .deleteFramebuffers = true,
    .genFramebuffers = true,
    .checkFramebufferStatus = true,
    .framebufferTexture1D = true,
    .framebufferTexture2D = true,
    .framebufferTexture3D = true,
    .framebufferRenderbuffer = true,
    .getFramebufferAttachmentParameteriv = true,
    .generateMipmap = true,
    .blitFramebuffer = true,
    .renderbufferStorageMultisample = true,
    .framebufferTextureLayer = true,
    .mapBufferRange = true,
    .flushMappedBufferRange = true,
    .bindVertexArray = true,
    .deleteVertexArrays = true,
    .genVertexArrays = true,
    .isVertexArray = true,
    .drawArraysInstanced = true,
    .drawElementsInstanced = true,
    .texBuffer = true,
    .primitiveRestartIndex = true,
    .copyBufferSubData = true,
    .getUniformIndices = true,
    .getActiveUniformsiv = true,
    .getActiveUniformName = true,
    .getUniformBlockIndex = true,
    .getActiveUniformBlockiv = true,
    .getActiveUniformBlockName = true,
    .uniformBlockBinding = true,
    .drawElementsBaseVertex = true,
    .drawRangeElementsBaseVertex = true,
    .drawElementsInstancedBaseVertex = true,
    .multiDrawElementsBaseVertex = true,
    .provokingVertex = true,
    .fenceSync = true,
    .isSync = true,
    .deleteSync = true,
    .clientWaitSync = true,
    .waitSync = true,
    .getInteger64v = true,
    .getSynciv = true,
    .getInteger64i_v = true,
    .getBufferParameteri64v = true,
    .framebufferTexture = true,
    .texImage2DMultisample = true,
    .texImage3DMultisample = true,
    .getMultisamplefv = true,
    .sampleMaski = true,
    .bindFragDataLocationIndexed = true,
    .getFragDataIndex = true,
    .genSamplers = true,
    .deleteSamplers = true,
    .isSampler = true,
    .bindSampler = true,
    .samplerParameteri = true,
    .samplerParameteriv = true,
    .samplerParameterf = true,
    .samplerParameterfv = true,
    .samplerParameterIiv = true,
    .samplerParameterIuiv = true,
    .getSamplerParameteriv = true,
    .getSamplerParameterIiv = true,
    .getSamplerParameterfv = true,
    .getSamplerParameterIuiv = true,
    .queryCounter = true,
    .getQueryObjecti64v = true,
    .getQueryObjectui64v = true,
    .vertexAttribDivisor = true,
    .vertexAttribP1ui = true,
    .vertexAttribP1uiv = true,
    .vertexAttribP2ui = true,
    .vertexAttribP2uiv = true,
    .vertexAttribP3ui = true,
    .vertexAttribP3uiv = true,
    .vertexAttribP4ui = true,
    .vertexAttribP4uiv = true,
    .vertexP2ui = true,
    .vertexP2uiv = true,
    .vertexP3ui = true,
    .vertexP3uiv = true,
    .vertexP4ui = true,
    .vertexP4uiv = true,
    .texCoordP1ui = true,
    .texCoordP1uiv = true,
    .texCoordP2ui = true,
    .texCoordP2uiv = true,
    .texCoordP3ui = true,
    .texCoordP3uiv = true,
    .texCoordP4ui = true,
    .texCoordP4uiv = true,
    .multiTexCoordP1ui = true,
    .multiTexCoordP1uiv = true,
    .multiTexCoordP2ui = true,
    .multiTexCoordP2uiv = true,
    .multiTexCoordP3ui = true,
    .multiTexCoordP3uiv = true,
    .multiTexCoordP4ui = true,
    .multiTexCoordP4uiv = true,
    .normalP3ui = true,
    .normalP3uiv = true,
    .colorP3ui = true,
    .colorP3uiv = true,
    .colorP4ui = true,
    .colorP4uiv = true,
    .secondaryColorP3ui = true,
    .secondaryColorP3uiv = true,
    .minSampleShading = true,
    .blendEquationi = true,
    .blendEquationSeparatei = true,
    .blendFunci = true,
    .blendFuncSeparatei = true,
    .drawArraysIndirect = true,
    .drawElementsIndirect = true,
    .uniform1d = true,
    .uniform2d = true,
    .uniform3d = true,
    .uniform4d = true,
    .uniform1dv = true,
    .uniform2dv = true,
    .uniform3dv = true,
    .uniform4dv = true,
    .uniformMatrix2dv = true,
    .uniformMatrix3dv = true,
    .uniformMatrix4dv = true,
    .uniformMatrix2x3dv = true,
    .uniformMatrix2x4dv = true,
    .uniformMatrix3x2dv = true,
    .uniformMatrix3x4dv = true,
    .uniformMatrix4x2dv = true,
    .uniformMatrix4x3dv = true,
    .getUniformdv = true,
    .getSubroutineUniformLocation = true,
    .getSubroutineIndex = true,
    .getActiveSubroutineUniformiv = true,
    .getActiveSubroutineUniformName = true,
    .getActiveSubroutineName = true,
    .uniformSubroutinesuiv = true,
    .getUniformSubroutineuiv = true,
    .getProgramStageiv = true,
    .patchParameteri = true,
    .patchParameterfv = true,
    .bindTransformFeedback = true,
    .deleteTransformFeedbacks = true,
    .genTransformFeedbacks = true,
    .isTransformFeedback = true,
    .pauseTransformFeedback = true,
    .resumeTransformFeedback = true,
    .drawTransformFeedback = true,
    .drawTransformFeedbackStream = true,
    .beginQueryIndexed = true,
    .endQueryIndexed = true,
    .getQueryIndexediv = true,
    .releaseShaderCompiler = true,
    .shaderBinary = true,
    .getShaderPrecisionFormat = true,
    .depthRangef = true,
    .clearDepthf = true,
    .getProgramBinary = true,
    .programBinary = true,
    .programParameteri = true,
    .useProgramStages = true,
    .activeShaderProgram = true,
    .createShaderProgramv = true,
    .bindProgramPipeline = true,
    .deleteProgramPipelines = true,
    .genProgramPipelines = true,
    .isProgramPipeline = true,
    .getProgramPipelineiv = true,
    .programUniform1i = true,
    .programUniform1iv = true,
    .programUniform1f = true,
    .programUniform1fv = true,
    .programUniform1d = true,
    .programUniform1dv = true,
    .programUniform1ui = true,
    .programUniform1uiv = true,
    .programUniform2i = true,
    .programUniform2iv = true,
    .programUniform2f = true,
    .programUniform2fv = true,
    .programUniform2d = true,
    .programUniform2dv = true,
    .programUniform2ui = true,
    .programUniform2uiv = true,
    .programUniform3i = true,
    .programUniform3iv = true,
    .programUniform3f = true,
    .programUniform3fv = true,
    .programUniform3d = true,
    .programUniform3dv = true,
    .programUniform3ui = true,
    .programUniform3uiv = true,
    .programUniform4i = true,
    .programUniform4iv = true,
    .programUniform4f = true,
    .programUniform4fv = true,
    .programUniform4d = true,
    .programUniform4dv = true,
    .programUniform4ui = true,
    .programUniform4uiv = true,
    .programUniformMatrix2fv = true,
    .programUniformMatrix3fv = true,
    .programUniformMatrix4fv = true,
    .programUniformMatrix2dv = true,
    .programUniformMatrix3dv = true,
    .programUniformMatrix4dv = true,
    .programUniformMatrix2x3fv = true,
    .programUniformMatrix3x2fv = true,
    .programUniformMatrix2x4fv = true,
    .programUniformMatrix4x2fv = true,
    .programUniformMatrix3x4fv = true,
    .programUniformMatrix4x3fv = true,
    .programUniformMatrix2x3dv = true,
    .programUniformMatrix3x2dv = true,
    .programUniformMatrix2x4dv = true,
    .programUniformMatrix4x2dv = true,
    .programUniformMatrix3x4dv = true,
    .programUniformMatrix4x3dv = true,
    .validateProgramPipeline = true,
    .getProgramPipelineInfoLog = true,
    .vertexAttribL1d = true,
    .vertexAttribL2d = true,
    .vertexAttribL3d = true,
    .vertexAttribL4d = true,
    .vertexAttribL1dv = true,
    .vertexAttribL2dv = true,
    .vertexAttribL3dv = true,
    .vertexAttribL4dv = true,
    .vertexAttribLPointer = true,
    .getVertexAttribLdv = true,
    .viewportArrayv = true,
    .viewportIndexedf = true,
    .viewportIndexedfv = true,
    .scissorArrayv = true,
    .scissorIndexed = true,
    .scissorIndexedv = true,
    .depthRangeArrayv = true,
    .depthRangeIndexed = true,
    .getFloati_v = true,
    .getDoublei_v = true,
    .drawArraysInstancedBaseInstance = true,
    .drawElementsInstancedBaseInstance = true,
    .drawElementsInstancedBaseVertexBaseInstance = true,
    .getInternalformativ = true,
    .getActiveAtomicCounterBufferiv = true,
    .bindImageTexture = true,
    .memoryBarrier = true,
    .texStorage1D = true,
    .texStorage2D = true,
    .texStorage3D = true,
    .drawTransformFeedbackInstanced = true,
    .drawTransformFeedbackStreamInstanced = true,
    .clearBufferData = true,
    .clearBufferSubData = true,
    .dispatchCompute = true,
    .dispatchComputeIndirect = true,
    .copyImageSubData = true,
    .framebufferParameteri = true,
    .getFramebufferParameteriv = true,
    .getInternalformati64v = true,
    .invalidateTexSubImage = true,
    .invalidateTexImage = true,
    .invalidateBufferSubData = true,
    .invalidateBufferData = true,
    .invalidateFramebuffer = true,
    .invalidateSubFramebuffer = true,
    .multiDrawArraysIndirect = true,
    .multiDrawElementsIndirect = true,
    .getProgramInterfaceiv = true,
    .getProgramResourceIndex = true,
    .getProgramResourceName = true,
    .getProgramResourceiv = true,
    .getProgramResourceLocation = true,
    .getProgramResourceLocationIndex = true,
    .shaderStorageBlockBinding = true,
    .texBufferRange = true,
    .texStorage2DMultisample = true,
    .texStorage3DMultisample = true,
    .textureView = true,
    .bindVertexBuffer = true,
    .vertexAttribFormat = true,
    .vertexAttribIFormat = true,
    .vertexAttribLFormat = true,
    .vertexAttribBinding = true,
    .vertexBindingDivisor = true,
    .debugMessageControl = true,
    .debugMessageInsert = true,
    .debugMessageCallback = true,
    .getDebugMessageLog = true,
    .pushDebugGroup = true,
    .popDebugGroup = true,
    .objectLabel = true,
    .getObjectLabel = true,
    .objectPtrLabel = true,
    .getObjectPtrLabel = true,
    .bufferStorage = true,
    .clearTexImage = true,
    .clearTexSubImage = true,
    .bindBuffersBase = true,
    .bindBuffersRange = true,
    .bindTextures = true,
    .bindSamplers = true,
    .bindImageTextures = true,
    .bindVertexBuffers = true,
    .clipControl = true,
    .createTransformFeedbacks = true,
    .transformFeedbackBufferBase = true,
    .transformFeedbackBufferRange = true,
    .getTransformFeedbackiv = true,
    .getTransformFeedbacki_v = true,
    .getTransformFeedbacki64_v = true,
    .createBuffers = true,
    .namedBufferStorage = true,
    .namedBufferData = true,
    .namedBufferSubData = true,
    .copyNamedBufferSubData = true,
    .clearNamedBufferData = true,
    .clearNamedBufferSubData = true,
    .mapNamedBuffer = true,
    .mapNamedBufferRange = true,
    .unmapNamedBuffer = true,
    .flushMappedNamedBufferRange = true,
    .getNamedBufferParameteriv = true,
    .getNamedBufferParameteri64v = true,
    .getNamedBufferPointerv = true,
    .getNamedBufferSubData = true,
    .createFramebuffers = true,
    .namedFramebufferRenderbuffer = true,
    .namedFramebufferParameteri = true,
    .namedFramebufferTexture = true,
    .namedFramebufferTextureLayer = true,
    .namedFramebufferDrawBuffer = true,
    .namedFramebufferDrawBuffers = true,
    .namedFramebufferReadBuffer = true,
    .invalidateNamedFramebufferData = true,
    .invalidateNamedFramebufferSubData = true,
    .clearNamedFramebufferiv = true,
    .clearNamedFramebufferuiv = true,
    .clearNamedFramebufferfv = true,
    .clearNamedFramebufferfi = true,
    .blitNamedFramebuffer = true,
    .checkNamedFramebufferStatus = true,
    .getNamedFramebufferParameteriv = true,
    .getNamedFramebufferAttachmentParameteriv = true,
    .createRenderbuffers = true,
    .namedRenderbufferStorage = true,
    .namedRenderbufferStorageMultisample = true,
    .getNamedRenderbufferParameteriv = true,
    .createTextures = true,
    .textureBuffer = true,
    .textureBufferRange = true,
    .textureStorage1D = true,
    .textureStorage2D = true,
    .textureStorage3D = true,
    .textureStorage2DMultisample = true,
    .textureStorage3DMultisample = true,
    .textureSubImage1D = true,
    .textureSubImage2D = true,
    .textureSubImage3D = true,
    .compressedTextureSubImage1D = true,
    .compressedTextureSubImage2D = true,
    .compressedTextureSubImage3D = true,
    .copyTextureSubImage1D = true,
    .copyTextureSubImage2D = true,
    .copyTextureSubImage3D = true,
    .textureParameterf = true,
    .textureParameterfv = true,
    .textureParameteri = true,
    .textureParameterIiv = true,
    .textureParameterIuiv = true,
    .textureParameteriv = true,
    .generateTextureMipmap = true,
    .bindTextureUnit = true,
    .getTextureImage = true,
    .getCompressedTextureImage = true,
    .getTextureLevelParameterfv = true,
    .getTextureLevelParameteriv = true,
    .getTextureParameterfv = true,
    .getTextureParameterIiv = true,
    .getTextureParameterIuiv = true,
    .getTextureParameteriv = true,
    .createVertexArrays = true,
    .disableVertexArrayAttrib = true,
    .enableVertexArrayAttrib = true,
    .vertexArrayElementBuffer = true,
    .vertexArrayVertexBuffer = true,
    .vertexArrayVertexBuffers = true,
    .vertexArrayAttribBinding = true,
    .vertexArrayAttribFormat = true,
    .vertexArrayAttribIFormat = true,
    .vertexArrayAttribLFormat = true,
    .vertexArrayBindingDivisor = true,
    .getVertexArrayiv = true,
    .getVertexArrayIndexediv = true,
    .getVertexArrayIndexed64iv = true,
    .createSamplers = true,
    .createProgramPipelines = true,
    .createQueries = true,
    .getQueryBufferObjecti64v = true,
    .getQueryBufferObjectiv = true,
    .getQueryBufferObjectui64v = true,
    .getQueryBufferObjectuiv = true,
    .memoryBarrierByRegion = true,
    .getTextureSubImage = true,
    .getCompressedTextureSubImage = true,
    .getGraphicsResetStatus = true,
    .getnCompressedTexImage = true,
    .getnTexImage = true,
    .getnUniformdv = true,
    .getnUniformfv = true,
    .getnUniformiv = true,
    .getnUniformuiv = true,
    .readnPixels = true,
    .getnMapdv = true,
    .getnMapfv = true,
    .getnMapiv = true,
    .getnPixelMapfv = true,
    .getnPixelMapuiv = true,
    .getnPixelMapusv = true,
    .getnPolygonStipple = true,
    .getnColorTable = true,
    .getnConvolutionFilter = true,
    .getnSeparableFilter = true,
    .getnHistogram = true,
    .getnMinmax = true,
    .textureBarrier = true,
};

pub const gl46 = CommandFlags{
    .cullFace = true,
    .frontFace = true,
    .hint = true,
    .lineWidth = true,
    .pointSize = true,
    .polygonMode = true,
    .scissor = true,
    .texParameterf = true,
    .texParameterfv = true,
    .texParameteri = true,
    .texParameteriv = true,
    .texImage1D = true,
    .texImage2D = true,
    .drawBuffer = true,
    .clear = true,
    .clearColor = true,
    .clearStencil = true,
    .clearDepth = true,
    .stencilMask = true,
    .colorMask = true,
    .depthMask = true,
    .disable = true,
    .enable = true,
    .finish = true,
    .flush = true,
    .blendFunc = true,
    .logicOp = true,
    .stencilFunc = true,
    .stencilOp = true,
    .depthFunc = true,
    .pixelStoref = true,
    .pixelStorei = true,
    .readBuffer = true,
    .readPixels = true,
    .getBooleanv = true,
    .getDoublev = true,
    .getError = true,
    .getFloatv = true,
    .getIntegerv = true,
    .getString = true,
    .getTexImage = true,
    .getTexParameterfv = true,
    .getTexParameteriv = true,
    .getTexLevelParameterfv = true,
    .getTexLevelParameteriv = true,
    .isEnabled = true,
    .depthRange = true,
    .viewport = true,
    .newList = true,
    .endList = true,
    .callList = true,
    .callLists = true,
    .deleteLists = true,
    .genLists = true,
    .listBase = true,
    .begin = true,
    .bitmap = true,
    .color3b = true,
    .color3bv = true,
    .color3d = true,
    .color3dv = true,
    .color3f = true,
    .color3fv = true,
    .color3i = true,
    .color3iv = true,
    .color3s = true,
    .color3sv = true,
    .color3ub = true,
    .color3ubv = true,
    .color3ui = true,
    .color3uiv = true,
    .color3us = true,
    .color3usv = true,
    .color4b = true,
    .color4bv = true,
    .color4d = true,
    .color4dv = true,
    .color4f = true,
    .color4fv = true,
    .color4i = true,
    .color4iv = true,
    .color4s = true,
    .color4sv = true,
    .color4ub = true,
    .color4ubv = true,
    .color4ui = true,
    .color4uiv = true,
    .color4us = true,
    .color4usv = true,
    .edgeFlag = true,
    .edgeFlagv = true,
    .end = true,
    .indexd = true,
    .indexdv = true,
    .indexf = true,
    .indexfv = true,
    .indexi = true,
    .indexiv = true,
    .indexs = true,
    .indexsv = true,
    .normal3b = true,
    .normal3bv = true,
    .normal3d = true,
    .normal3dv = true,
    .normal3f = true,
    .normal3fv = true,
    .normal3i = true,
    .normal3iv = true,
    .normal3s = true,
    .normal3sv = true,
    .rasterPos2d = true,
    .rasterPos2dv = true,
    .rasterPos2f = true,
    .rasterPos2fv = true,
    .rasterPos2i = true,
    .rasterPos2iv = true,
    .rasterPos2s = true,
    .rasterPos2sv = true,
    .rasterPos3d = true,
    .rasterPos3dv = true,
    .rasterPos3f = true,
    .rasterPos3fv = true,
    .rasterPos3i = true,
    .rasterPos3iv = true,
    .rasterPos3s = true,
    .rasterPos3sv = true,
    .rasterPos4d = true,
    .rasterPos4dv = true,
    .rasterPos4f = true,
    .rasterPos4fv = true,
    .rasterPos4i = true,
    .rasterPos4iv = true,
    .rasterPos4s = true,
    .rasterPos4sv = true,
    .rectd = true,
    .rectdv = true,
    .rectf = true,
    .rectfv = true,
    .recti = true,
    .rectiv = true,
    .rects = true,
    .rectsv = true,
    .texCoord1d = true,
    .texCoord1dv = true,
    .texCoord1f = true,
    .texCoord1fv = true,
    .texCoord1i = true,
    .texCoord1iv = true,
    .texCoord1s = true,
    .texCoord1sv = true,
    .texCoord2d = true,
    .texCoord2dv = true,
    .texCoord2f = true,
    .texCoord2fv = true,
    .texCoord2i = true,
    .texCoord2iv = true,
    .texCoord2s = true,
    .texCoord2sv = true,
    .texCoord3d = true,
    .texCoord3dv = true,
    .texCoord3f = true,
    .texCoord3fv = true,
    .texCoord3i = true,
    .texCoord3iv = true,
    .texCoord3s = true,
    .texCoord3sv = true,
    .texCoord4d = true,
    .texCoord4dv = true,
    .texCoord4f = true,
    .texCoord4fv = true,
    .texCoord4i = true,
    .texCoord4iv = true,
    .texCoord4s = true,
    .texCoord4sv = true,
    .vertex2d = true,
    .vertex2dv = true,
    .vertex2f = true,
    .vertex2fv = true,
    .vertex2i = true,
    .vertex2iv = true,
    .vertex2s = true,
    .vertex2sv = true,
    .vertex3d = true,
    .vertex3dv = true,
    .vertex3f = true,
    .vertex3fv = true,
    .vertex3i = true,
    .vertex3iv = true,
    .vertex3s = true,
    .vertex3sv = true,
    .vertex4d = true,
    .vertex4dv = true,
    .vertex4f = true,
    .vertex4fv = true,
    .vertex4i = true,
    .vertex4iv = true,
    .vertex4s = true,
    .vertex4sv = true,
    .clipPlane = true,
    .colorMaterial = true,
    .fogf = true,
    .fogfv = true,
    .fogi = true,
    .fogiv = true,
    .lightf = true,
    .lightfv = true,
    .lighti = true,
    .lightiv = true,
    .lightModelf = true,
    .lightModelfv = true,
    .lightModeli = true,
    .lightModeliv = true,
    .lineStipple = true,
    .materialf = true,
    .materialfv = true,
    .materiali = true,
    .materialiv = true,
    .polygonStipple = true,
    .shadeModel = true,
    .texEnvf = true,
    .texEnvfv = true,
    .texEnvi = true,
    .texEnviv = true,
    .texGend = true,
    .texGendv = true,
    .texGenf = true,
    .texGenfv = true,
    .texGeni = true,
    .texGeniv = true,
    .feedbackBuffer = true,
    .selectBuffer = true,
    .renderMode = true,
    .initNames = true,
    .loadName = true,
    .passThrough = true,
    .popName = true,
    .pushName = true,
    .clearAccum = true,
    .clearIndex = true,
    .indexMask = true,
    .accum = true,
    .popAttrib = true,
    .pushAttrib = true,
    .map1d = true,
    .map1f = true,
    .map2d = true,
    .map2f = true,
    .mapGrid1d = true,
    .mapGrid1f = true,
    .mapGrid2d = true,
    .mapGrid2f = true,
    .evalCoord1d = true,
    .evalCoord1dv = true,
    .evalCoord1f = true,
    .evalCoord1fv = true,
    .evalCoord2d = true,
    .evalCoord2dv = true,
    .evalCoord2f = true,
    .evalCoord2fv = true,
    .evalMesh1 = true,
    .evalPoint1 = true,
    .evalMesh2 = true,
    .evalPoint2 = true,
    .alphaFunc = true,
    .pixelZoom = true,
    .pixelTransferf = true,
    .pixelTransferi = true,
    .pixelMapfv = true,
    .pixelMapuiv = true,
    .pixelMapusv = true,
    .copyPixels = true,
    .drawPixels = true,
    .getClipPlane = true,
    .getLightfv = true,
    .getLightiv = true,
    .getMapdv = true,
    .getMapfv = true,
    .getMapiv = true,
    .getMaterialfv = true,
    .getMaterialiv = true,
    .getPixelMapfv = true,
    .getPixelMapuiv = true,
    .getPixelMapusv = true,
    .getPolygonStipple = true,
    .getTexEnvfv = true,
    .getTexEnviv = true,
    .getTexGendv = true,
    .getTexGenfv = true,
    .getTexGeniv = true,
    .isList = true,
    .frustum = true,
    .loadIdentity = true,
    .loadMatrixf = true,
    .loadMatrixd = true,
    .matrixMode = true,
    .multMatrixf = true,
    .multMatrixd = true,
    .ortho = true,
    .popMatrix = true,
    .pushMatrix = true,
    .rotated = true,
    .rotatef = true,
    .scaled = true,
    .scalef = true,
    .translated = true,
    .translatef = true,
    .drawArrays = true,
    .drawElements = true,
    .getPointerv = true,
    .polygonOffset = true,
    .copyTexImage1D = true,
    .copyTexImage2D = true,
    .copyTexSubImage1D = true,
    .copyTexSubImage2D = true,
    .texSubImage1D = true,
    .texSubImage2D = true,
    .bindTexture = true,
    .deleteTextures = true,
    .genTextures = true,
    .isTexture = true,
    .arrayElement = true,
    .colorPointer = true,
    .disableClientState = true,
    .edgeFlagPointer = true,
    .enableClientState = true,
    .indexPointer = true,
    .interleavedArrays = true,
    .normalPointer = true,
    .texCoordPointer = true,
    .vertexPointer = true,
    .areTexturesResident = true,
    .prioritizeTextures = true,
    .indexub = true,
    .indexubv = true,
    .popClientAttrib = true,
    .pushClientAttrib = true,
    .drawRangeElements = true,
    .texImage3D = true,
    .texSubImage3D = true,
    .copyTexSubImage3D = true,
    .activeTexture = true,
    .sampleCoverage = true,
    .compressedTexImage3D = true,
    .compressedTexImage2D = true,
    .compressedTexImage1D = true,
    .compressedTexSubImage3D = true,
    .compressedTexSubImage2D = true,
    .compressedTexSubImage1D = true,
    .getCompressedTexImage = true,
    .clientActiveTexture = true,
    .multiTexCoord1d = true,
    .multiTexCoord1dv = true,
    .multiTexCoord1f = true,
    .multiTexCoord1fv = true,
    .multiTexCoord1i = true,
    .multiTexCoord1iv = true,
    .multiTexCoord1s = true,
    .multiTexCoord1sv = true,
    .multiTexCoord2d = true,
    .multiTexCoord2dv = true,
    .multiTexCoord2f = true,
    .multiTexCoord2fv = true,
    .multiTexCoord2i = true,
    .multiTexCoord2iv = true,
    .multiTexCoord2s = true,
    .multiTexCoord2sv = true,
    .multiTexCoord3d = true,
    .multiTexCoord3dv = true,
    .multiTexCoord3f = true,
    .multiTexCoord3fv = true,
    .multiTexCoord3i = true,
    .multiTexCoord3iv = true,
    .multiTexCoord3s = true,
    .multiTexCoord3sv = true,
    .multiTexCoord4d = true,
    .multiTexCoord4dv = true,
    .multiTexCoord4f = true,
    .multiTexCoord4fv = true,
    .multiTexCoord4i = true,
    .multiTexCoord4iv = true,
    .multiTexCoord4s = true,
    .multiTexCoord4sv = true,
    .loadTransposeMatrixf = true,
    .loadTransposeMatrixd = true,
    .multTransposeMatrixf = true,
    .multTransposeMatrixd = true,
    .blendFuncSeparate = true,
    .multiDrawArrays = true,
    .multiDrawElements = true,
    .pointParameterf = true,
    .pointParameterfv = true,
    .pointParameteri = true,
    .pointParameteriv = true,
    .fogCoordf = true,
    .fogCoordfv = true,
    .fogCoordd = true,
    .fogCoorddv = true,
    .fogCoordPointer = true,
    .secondaryColor3b = true,
    .secondaryColor3bv = true,
    .secondaryColor3d = true,
    .secondaryColor3dv = true,
    .secondaryColor3f = true,
    .secondaryColor3fv = true,
    .secondaryColor3i = true,
    .secondaryColor3iv = true,
    .secondaryColor3s = true,
    .secondaryColor3sv = true,
    .secondaryColor3ub = true,
    .secondaryColor3ubv = true,
    .secondaryColor3ui = true,
    .secondaryColor3uiv = true,
    .secondaryColor3us = true,
    .secondaryColor3usv = true,
    .secondaryColorPointer = true,
    .windowPos2d = true,
    .windowPos2dv = true,
    .windowPos2f = true,
    .windowPos2fv = true,
    .windowPos2i = true,
    .windowPos2iv = true,
    .windowPos2s = true,
    .windowPos2sv = true,
    .windowPos3d = true,
    .windowPos3dv = true,
    .windowPos3f = true,
    .windowPos3fv = true,
    .windowPos3i = true,
    .windowPos3iv = true,
    .windowPos3s = true,
    .windowPos3sv = true,
    .blendColor = true,
    .blendEquation = true,
    .genQueries = true,
    .deleteQueries = true,
    .isQuery = true,
    .beginQuery = true,
    .endQuery = true,
    .getQueryiv = true,
    .getQueryObjectiv = true,
    .getQueryObjectuiv = true,
    .bindBuffer = true,
    .deleteBuffers = true,
    .genBuffers = true,
    .isBuffer = true,
    .bufferData = true,
    .bufferSubData = true,
    .getBufferSubData = true,
    .mapBuffer = true,
    .unmapBuffer = true,
    .getBufferParameteriv = true,
    .getBufferPointerv = true,
    .blendEquationSeparate = true,
    .drawBuffers = true,
    .stencilOpSeparate = true,
    .stencilFuncSeparate = true,
    .stencilMaskSeparate = true,
    .attachShader = true,
    .bindAttribLocation = true,
    .compileShader = true,
    .createProgram = true,
    .createShader = true,
    .deleteProgram = true,
    .deleteShader = true,
    .detachShader = true,
    .disableVertexAttribArray = true,
    .enableVertexAttribArray = true,
    .getActiveAttrib = true,
    .getActiveUniform = true,
    .getAttachedShaders = true,
    .getAttribLocation = true,
    .getProgramiv = true,
    .getProgramInfoLog = true,
    .getShaderiv = true,
    .getShaderInfoLog = true,
    .getShaderSource = true,
    .getUniformLocation = true,
    .getUniformfv = true,
    .getUniformiv = true,
    .getVertexAttribdv = true,
    .getVertexAttribfv = true,
    .getVertexAttribiv = true,
    .getVertexAttribPointerv = true,
    .isProgram = true,
    .isShader = true,
    .linkProgram = true,
    .shaderSource = true,
    .useProgram = true,
    .uniform1f = true,
    .uniform2f = true,
    .uniform3f = true,
    .uniform4f = true,
    .uniform1i = true,
    .uniform2i = true,
    .uniform3i = true,
    .uniform4i = true,
    .uniform1fv = true,
    .uniform2fv = true,
    .uniform3fv = true,
    .uniform4fv = true,
    .uniform1iv = true,
    .uniform2iv = true,
    .uniform3iv = true,
    .uniform4iv = true,
    .uniformMatrix2fv = true,
    .uniformMatrix3fv = true,
    .uniformMatrix4fv = true,
    .validateProgram = true,
    .vertexAttrib1d = true,
    .vertexAttrib1dv = true,
    .vertexAttrib1f = true,
    .vertexAttrib1fv = true,
    .vertexAttrib1s = true,
    .vertexAttrib1sv = true,
    .vertexAttrib2d = true,
    .vertexAttrib2dv = true,
    .vertexAttrib2f = true,
    .vertexAttrib2fv = true,
    .vertexAttrib2s = true,
    .vertexAttrib2sv = true,
    .vertexAttrib3d = true,
    .vertexAttrib3dv = true,
    .vertexAttrib3f = true,
    .vertexAttrib3fv = true,
    .vertexAttrib3s = true,
    .vertexAttrib3sv = true,
    .vertexAttrib4Nbv = true,
    .vertexAttrib4Niv = true,
    .vertexAttrib4Nsv = true,
    .vertexAttrib4Nub = true,
    .vertexAttrib4Nubv = true,
    .vertexAttrib4Nuiv = true,
    .vertexAttrib4Nusv = true,
    .vertexAttrib4bv = true,
    .vertexAttrib4d = true,
    .vertexAttrib4dv = true,
    .vertexAttrib4f = true,
    .vertexAttrib4fv = true,
    .vertexAttrib4iv = true,
    .vertexAttrib4s = true,
    .vertexAttrib4sv = true,
    .vertexAttrib4ubv = true,
    .vertexAttrib4uiv = true,
    .vertexAttrib4usv = true,
    .vertexAttribPointer = true,
    .uniformMatrix2x3fv = true,
    .uniformMatrix3x2fv = true,
    .uniformMatrix2x4fv = true,
    .uniformMatrix4x2fv = true,
    .uniformMatrix3x4fv = true,
    .uniformMatrix4x3fv = true,
    .colorMaski = true,
    .getBooleani_v = true,
    .getIntegeri_v = true,
    .enablei = true,
    .disablei = true,
    .isEnabledi = true,
    .beginTransformFeedback = true,
    .endTransformFeedback = true,
    .bindBufferRange = true,
    .bindBufferBase = true,
    .transformFeedbackVaryings = true,
    .getTransformFeedbackVarying = true,
    .clampColor = true,
    .beginConditionalRender = true,
    .endConditionalRender = true,
    .vertexAttribIPointer = true,
    .getVertexAttribIiv = true,
    .getVertexAttribIuiv = true,
    .vertexAttribI1i = true,
    .vertexAttribI2i = true,
    .vertexAttribI3i = true,
    .vertexAttribI4i = true,
    .vertexAttribI1ui = true,
    .vertexAttribI2ui = true,
    .vertexAttribI3ui = true,
    .vertexAttribI4ui = true,
    .vertexAttribI1iv = true,
    .vertexAttribI2iv = true,
    .vertexAttribI3iv = true,
    .vertexAttribI4iv = true,
    .vertexAttribI1uiv = true,
    .vertexAttribI2uiv = true,
    .vertexAttribI3uiv = true,
    .vertexAttribI4uiv = true,
    .vertexAttribI4bv = true,
    .vertexAttribI4sv = true,
    .vertexAttribI4ubv = true,
    .vertexAttribI4usv = true,
    .getUniformuiv = true,
    .bindFragDataLocation = true,
    .getFragDataLocation = true,
    .uniform1ui = true,
    .uniform2ui = true,
    .uniform3ui = true,
    .uniform4ui = true,
    .uniform1uiv = true,
    .uniform2uiv = true,
    .uniform3uiv = true,
    .uniform4uiv = true,
    .texParameterIiv = true,
    .texParameterIuiv = true,
    .getTexParameterIiv = true,
    .getTexParameterIuiv = true,
    .clearBufferiv = true,
    .clearBufferuiv = true,
    .clearBufferfv = true,
    .clearBufferfi = true,
    .getStringi = true,
    .isRenderbuffer = true,
    .bindRenderbuffer = true,
    .deleteRenderbuffers = true,
    .genRenderbuffers = true,
    .renderbufferStorage = true,
    .getRenderbufferParameteriv = true,
    .isFramebuffer = true,
    .bindFramebuffer = true,
    .deleteFramebuffers = true,
    .genFramebuffers = true,
    .checkFramebufferStatus = true,
    .framebufferTexture1D = true,
    .framebufferTexture2D = true,
    .framebufferTexture3D = true,
    .framebufferRenderbuffer = true,
    .getFramebufferAttachmentParameteriv = true,
    .generateMipmap = true,
    .blitFramebuffer = true,
    .renderbufferStorageMultisample = true,
    .framebufferTextureLayer = true,
    .mapBufferRange = true,
    .flushMappedBufferRange = true,
    .bindVertexArray = true,
    .deleteVertexArrays = true,
    .genVertexArrays = true,
    .isVertexArray = true,
    .drawArraysInstanced = true,
    .drawElementsInstanced = true,
    .texBuffer = true,
    .primitiveRestartIndex = true,
    .copyBufferSubData = true,
    .getUniformIndices = true,
    .getActiveUniformsiv = true,
    .getActiveUniformName = true,
    .getUniformBlockIndex = true,
    .getActiveUniformBlockiv = true,
    .getActiveUniformBlockName = true,
    .uniformBlockBinding = true,
    .drawElementsBaseVertex = true,
    .drawRangeElementsBaseVertex = true,
    .drawElementsInstancedBaseVertex = true,
    .multiDrawElementsBaseVertex = true,
    .provokingVertex = true,
    .fenceSync = true,
    .isSync = true,
    .deleteSync = true,
    .clientWaitSync = true,
    .waitSync = true,
    .getInteger64v = true,
    .getSynciv = true,
    .getInteger64i_v = true,
    .getBufferParameteri64v = true,
    .framebufferTexture = true,
    .texImage2DMultisample = true,
    .texImage3DMultisample = true,
    .getMultisamplefv = true,
    .sampleMaski = true,
    .bindFragDataLocationIndexed = true,
    .getFragDataIndex = true,
    .genSamplers = true,
    .deleteSamplers = true,
    .isSampler = true,
    .bindSampler = true,
    .samplerParameteri = true,
    .samplerParameteriv = true,
    .samplerParameterf = true,
    .samplerParameterfv = true,
    .samplerParameterIiv = true,
    .samplerParameterIuiv = true,
    .getSamplerParameteriv = true,
    .getSamplerParameterIiv = true,
    .getSamplerParameterfv = true,
    .getSamplerParameterIuiv = true,
    .queryCounter = true,
    .getQueryObjecti64v = true,
    .getQueryObjectui64v = true,
    .vertexAttribDivisor = true,
    .vertexAttribP1ui = true,
    .vertexAttribP1uiv = true,
    .vertexAttribP2ui = true,
    .vertexAttribP2uiv = true,
    .vertexAttribP3ui = true,
    .vertexAttribP3uiv = true,
    .vertexAttribP4ui = true,
    .vertexAttribP4uiv = true,
    .vertexP2ui = true,
    .vertexP2uiv = true,
    .vertexP3ui = true,
    .vertexP3uiv = true,
    .vertexP4ui = true,
    .vertexP4uiv = true,
    .texCoordP1ui = true,
    .texCoordP1uiv = true,
    .texCoordP2ui = true,
    .texCoordP2uiv = true,
    .texCoordP3ui = true,
    .texCoordP3uiv = true,
    .texCoordP4ui = true,
    .texCoordP4uiv = true,
    .multiTexCoordP1ui = true,
    .multiTexCoordP1uiv = true,
    .multiTexCoordP2ui = true,
    .multiTexCoordP2uiv = true,
    .multiTexCoordP3ui = true,
    .multiTexCoordP3uiv = true,
    .multiTexCoordP4ui = true,
    .multiTexCoordP4uiv = true,
    .normalP3ui = true,
    .normalP3uiv = true,
    .colorP3ui = true,
    .colorP3uiv = true,
    .colorP4ui = true,
    .colorP4uiv = true,
    .secondaryColorP3ui = true,
    .secondaryColorP3uiv = true,
    .minSampleShading = true,
    .blendEquationi = true,
    .blendEquationSeparatei = true,
    .blendFunci = true,
    .blendFuncSeparatei = true,
    .drawArraysIndirect = true,
    .drawElementsIndirect = true,
    .uniform1d = true,
    .uniform2d = true,
    .uniform3d = true,
    .uniform4d = true,
    .uniform1dv = true,
    .uniform2dv = true,
    .uniform3dv = true,
    .uniform4dv = true,
    .uniformMatrix2dv = true,
    .uniformMatrix3dv = true,
    .uniformMatrix4dv = true,
    .uniformMatrix2x3dv = true,
    .uniformMatrix2x4dv = true,
    .uniformMatrix3x2dv = true,
    .uniformMatrix3x4dv = true,
    .uniformMatrix4x2dv = true,
    .uniformMatrix4x3dv = true,
    .getUniformdv = true,
    .getSubroutineUniformLocation = true,
    .getSubroutineIndex = true,
    .getActiveSubroutineUniformiv = true,
    .getActiveSubroutineUniformName = true,
    .getActiveSubroutineName = true,
    .uniformSubroutinesuiv = true,
    .getUniformSubroutineuiv = true,
    .getProgramStageiv = true,
    .patchParameteri = true,
    .patchParameterfv = true,
    .bindTransformFeedback = true,
    .deleteTransformFeedbacks = true,
    .genTransformFeedbacks = true,
    .isTransformFeedback = true,
    .pauseTransformFeedback = true,
    .resumeTransformFeedback = true,
    .drawTransformFeedback = true,
    .drawTransformFeedbackStream = true,
    .beginQueryIndexed = true,
    .endQueryIndexed = true,
    .getQueryIndexediv = true,
    .releaseShaderCompiler = true,
    .shaderBinary = true,
    .getShaderPrecisionFormat = true,
    .depthRangef = true,
    .clearDepthf = true,
    .getProgramBinary = true,
    .programBinary = true,
    .programParameteri = true,
    .useProgramStages = true,
    .activeShaderProgram = true,
    .createShaderProgramv = true,
    .bindProgramPipeline = true,
    .deleteProgramPipelines = true,
    .genProgramPipelines = true,
    .isProgramPipeline = true,
    .getProgramPipelineiv = true,
    .programUniform1i = true,
    .programUniform1iv = true,
    .programUniform1f = true,
    .programUniform1fv = true,
    .programUniform1d = true,
    .programUniform1dv = true,
    .programUniform1ui = true,
    .programUniform1uiv = true,
    .programUniform2i = true,
    .programUniform2iv = true,
    .programUniform2f = true,
    .programUniform2fv = true,
    .programUniform2d = true,
    .programUniform2dv = true,
    .programUniform2ui = true,
    .programUniform2uiv = true,
    .programUniform3i = true,
    .programUniform3iv = true,
    .programUniform3f = true,
    .programUniform3fv = true,
    .programUniform3d = true,
    .programUniform3dv = true,
    .programUniform3ui = true,
    .programUniform3uiv = true,
    .programUniform4i = true,
    .programUniform4iv = true,
    .programUniform4f = true,
    .programUniform4fv = true,
    .programUniform4d = true,
    .programUniform4dv = true,
    .programUniform4ui = true,
    .programUniform4uiv = true,
    .programUniformMatrix2fv = true,
    .programUniformMatrix3fv = true,
    .programUniformMatrix4fv = true,
    .programUniformMatrix2dv = true,
    .programUniformMatrix3dv = true,
    .programUniformMatrix4dv = true,
    .programUniformMatrix2x3fv = true,
    .programUniformMatrix3x2fv = true,
    .programUniformMatrix2x4fv = true,
    .programUniformMatrix4x2fv = true,
    .programUniformMatrix3x4fv = true,
    .programUniformMatrix4x3fv = true,
    .programUniformMatrix2x3dv = true,
    .programUniformMatrix3x2dv = true,
    .programUniformMatrix2x4dv = true,
    .programUniformMatrix4x2dv = true,
    .programUniformMatrix3x4dv = true,
    .programUniformMatrix4x3dv = true,
    .validateProgramPipeline = true,
    .getProgramPipelineInfoLog = true,
    .vertexAttribL1d = true,
    .vertexAttribL2d = true,
    .vertexAttribL3d = true,
    .vertexAttribL4d = true,
    .vertexAttribL1dv = true,
    .vertexAttribL2dv = true,
    .vertexAttribL3dv = true,
    .vertexAttribL4dv = true,
    .vertexAttribLPointer = true,
    .getVertexAttribLdv = true,
    .viewportArrayv = true,
    .viewportIndexedf = true,
    .viewportIndexedfv = true,
    .scissorArrayv = true,
    .scissorIndexed = true,
    .scissorIndexedv = true,
    .depthRangeArrayv = true,
    .depthRangeIndexed = true,
    .getFloati_v = true,
    .getDoublei_v = true,
    .drawArraysInstancedBaseInstance = true,
    .drawElementsInstancedBaseInstance = true,
    .drawElementsInstancedBaseVertexBaseInstance = true,
    .getInternalformativ = true,
    .getActiveAtomicCounterBufferiv = true,
    .bindImageTexture = true,
    .memoryBarrier = true,
    .texStorage1D = true,
    .texStorage2D = true,
    .texStorage3D = true,
    .drawTransformFeedbackInstanced = true,
    .drawTransformFeedbackStreamInstanced = true,
    .clearBufferData = true,
    .clearBufferSubData = true,
    .dispatchCompute = true,
    .dispatchComputeIndirect = true,
    .copyImageSubData = true,
    .framebufferParameteri = true,
    .getFramebufferParameteriv = true,
    .getInternalformati64v = true,
    .invalidateTexSubImage = true,
    .invalidateTexImage = true,
    .invalidateBufferSubData = true,
    .invalidateBufferData = true,
    .invalidateFramebuffer = true,
    .invalidateSubFramebuffer = true,
    .multiDrawArraysIndirect = true,
    .multiDrawElementsIndirect = true,
    .getProgramInterfaceiv = true,
    .getProgramResourceIndex = true,
    .getProgramResourceName = true,
    .getProgramResourceiv = true,
    .getProgramResourceLocation = true,
    .getProgramResourceLocationIndex = true,
    .shaderStorageBlockBinding = true,
    .texBufferRange = true,
    .texStorage2DMultisample = true,
    .texStorage3DMultisample = true,
    .textureView = true,
    .bindVertexBuffer = true,
    .vertexAttribFormat = true,
    .vertexAttribIFormat = true,
    .vertexAttribLFormat = true,
    .vertexAttribBinding = true,
    .vertexBindingDivisor = true,
    .debugMessageControl = true,
    .debugMessageInsert = true,
    .debugMessageCallback = true,
    .getDebugMessageLog = true,
    .pushDebugGroup = true,
    .popDebugGroup = true,
    .objectLabel = true,
    .getObjectLabel = true,
    .objectPtrLabel = true,
    .getObjectPtrLabel = true,
    .bufferStorage = true,
    .clearTexImage = true,
    .clearTexSubImage = true,
    .bindBuffersBase = true,
    .bindBuffersRange = true,
    .bindTextures = true,
    .bindSamplers = true,
    .bindImageTextures = true,
    .bindVertexBuffers = true,
    .clipControl = true,
    .createTransformFeedbacks = true,
    .transformFeedbackBufferBase = true,
    .transformFeedbackBufferRange = true,
    .getTransformFeedbackiv = true,
    .getTransformFeedbacki_v = true,
    .getTransformFeedbacki64_v = true,
    .createBuffers = true,
    .namedBufferStorage = true,
    .namedBufferData = true,
    .namedBufferSubData = true,
    .copyNamedBufferSubData = true,
    .clearNamedBufferData = true,
    .clearNamedBufferSubData = true,
    .mapNamedBuffer = true,
    .mapNamedBufferRange = true,
    .unmapNamedBuffer = true,
    .flushMappedNamedBufferRange = true,
    .getNamedBufferParameteriv = true,
    .getNamedBufferParameteri64v = true,
    .getNamedBufferPointerv = true,
    .getNamedBufferSubData = true,
    .createFramebuffers = true,
    .namedFramebufferRenderbuffer = true,
    .namedFramebufferParameteri = true,
    .namedFramebufferTexture = true,
    .namedFramebufferTextureLayer = true,
    .namedFramebufferDrawBuffer = true,
    .namedFramebufferDrawBuffers = true,
    .namedFramebufferReadBuffer = true,
    .invalidateNamedFramebufferData = true,
    .invalidateNamedFramebufferSubData = true,
    .clearNamedFramebufferiv = true,
    .clearNamedFramebufferuiv = true,
    .clearNamedFramebufferfv = true,
    .clearNamedFramebufferfi = true,
    .blitNamedFramebuffer = true,
    .checkNamedFramebufferStatus = true,
    .getNamedFramebufferParameteriv = true,
    .getNamedFramebufferAttachmentParameteriv = true,
    .createRenderbuffers = true,
    .namedRenderbufferStorage = true,
    .namedRenderbufferStorageMultisample = true,
    .getNamedRenderbufferParameteriv = true,
    .createTextures = true,
    .textureBuffer = true,
    .textureBufferRange = true,
    .textureStorage1D = true,
    .textureStorage2D = true,
    .textureStorage3D = true,
    .textureStorage2DMultisample = true,
    .textureStorage3DMultisample = true,
    .textureSubImage1D = true,
    .textureSubImage2D = true,
    .textureSubImage3D = true,
    .compressedTextureSubImage1D = true,
    .compressedTextureSubImage2D = true,
    .compressedTextureSubImage3D = true,
    .copyTextureSubImage1D = true,
    .copyTextureSubImage2D = true,
    .copyTextureSubImage3D = true,
    .textureParameterf = true,
    .textureParameterfv = true,
    .textureParameteri = true,
    .textureParameterIiv = true,
    .textureParameterIuiv = true,
    .textureParameteriv = true,
    .generateTextureMipmap = true,
    .bindTextureUnit = true,
    .getTextureImage = true,
    .getCompressedTextureImage = true,
    .getTextureLevelParameterfv = true,
    .getTextureLevelParameteriv = true,
    .getTextureParameterfv = true,
    .getTextureParameterIiv = true,
    .getTextureParameterIuiv = true,
    .getTextureParameteriv = true,
    .createVertexArrays = true,
    .disableVertexArrayAttrib = true,
    .enableVertexArrayAttrib = true,
    .vertexArrayElementBuffer = true,
    .vertexArrayVertexBuffer = true,
    .vertexArrayVertexBuffers = true,
    .vertexArrayAttribBinding = true,
    .vertexArrayAttribFormat = true,
    .vertexArrayAttribIFormat = true,
    .vertexArrayAttribLFormat = true,
    .vertexArrayBindingDivisor = true,
    .getVertexArrayiv = true,
    .getVertexArrayIndexediv = true,
    .getVertexArrayIndexed64iv = true,
    .createSamplers = true,
    .createProgramPipelines = true,
    .createQueries = true,
    .getQueryBufferObjecti64v = true,
    .getQueryBufferObjectiv = true,
    .getQueryBufferObjectui64v = true,
    .getQueryBufferObjectuiv = true,
    .memoryBarrierByRegion = true,
    .getTextureSubImage = true,
    .getCompressedTextureSubImage = true,
    .getGraphicsResetStatus = true,
    .getnCompressedTexImage = true,
    .getnTexImage = true,
    .getnUniformdv = true,
    .getnUniformfv = true,
    .getnUniformiv = true,
    .getnUniformuiv = true,
    .readnPixels = true,
    .getnMapdv = true,
    .getnMapfv = true,
    .getnMapiv = true,
    .getnPixelMapfv = true,
    .getnPixelMapuiv = true,
    .getnPixelMapusv = true,
    .getnPolygonStipple = true,
    .getnColorTable = true,
    .getnConvolutionFilter = true,
    .getnSeparableFilter = true,
    .getnHistogram = true,
    .getnMinmax = true,
    .textureBarrier = true,
    .specializeShader = true,
    .multiDrawArraysIndirectCount = true,
    .multiDrawElementsIndirectCount = true,
    .polygonOffsetClamp = true,
};

pub const glescm10 = CommandFlags{
    .alphaFunc = true,
    .clearColor = true,
    .clearDepthf = true,
    .clipPlanef = true,
    .color4f = true,
    .depthRangef = true,
    .fogf = true,
    .fogfv = true,
    .frustumf = true,
    .getClipPlanef = true,
    .getFloatv = true,
    .getLightfv = true,
    .getMaterialfv = true,
    .getTexEnvfv = true,
    .getTexParameterfv = true,
    .lightModelf = true,
    .lightModelfv = true,
    .lightf = true,
    .lightfv = true,
    .lineWidth = true,
    .loadMatrixf = true,
    .materialf = true,
    .materialfv = true,
    .multMatrixf = true,
    .multiTexCoord4f = true,
    .normal3f = true,
    .orthof = true,
    .pointParameterf = true,
    .pointParameterfv = true,
    .pointSize = true,
    .polygonOffset = true,
    .rotatef = true,
    .scalef = true,
    .texEnvf = true,
    .texEnvfv = true,
    .texParameterf = true,
    .texParameterfv = true,
    .translatef = true,
    .activeTexture = true,
    .alphaFuncx = true,
    .bindBuffer = true,
    .bindTexture = true,
    .blendFunc = true,
    .bufferData = true,
    .bufferSubData = true,
    .clear = true,
    .clearColorx = true,
    .clearDepthx = true,
    .clearStencil = true,
    .clientActiveTexture = true,
    .clipPlanex = true,
    .color4ub = true,
    .color4x = true,
    .colorMask = true,
    .colorPointer = true,
    .compressedTexImage2D = true,
    .compressedTexSubImage2D = true,
    .copyTexImage2D = true,
    .copyTexSubImage2D = true,
    .cullFace = true,
    .deleteBuffers = true,
    .deleteTextures = true,
    .depthFunc = true,
    .depthMask = true,
    .depthRangex = true,
    .disable = true,
    .disableClientState = true,
    .drawArrays = true,
    .drawElements = true,
    .enable = true,
    .enableClientState = true,
    .finish = true,
    .flush = true,
    .fogx = true,
    .fogxv = true,
    .frontFace = true,
    .frustumx = true,
    .getBooleanv = true,
    .getBufferParameteriv = true,
    .getClipPlanex = true,
    .genBuffers = true,
    .genTextures = true,
    .getError = true,
    .getFixedv = true,
    .getIntegerv = true,
    .getLightxv = true,
    .getMaterialxv = true,
    .getPointerv = true,
    .getString = true,
    .getTexEnviv = true,
    .getTexEnvxv = true,
    .getTexParameteriv = true,
    .getTexParameterxv = true,
    .hint = true,
    .isBuffer = true,
    .isEnabled = true,
    .isTexture = true,
    .lightModelx = true,
    .lightModelxv = true,
    .lightx = true,
    .lightxv = true,
    .lineWidthx = true,
    .loadIdentity = true,
    .loadMatrixx = true,
    .logicOp = true,
    .materialx = true,
    .materialxv = true,
    .matrixMode = true,
    .multMatrixx = true,
    .multiTexCoord4x = true,
    .normal3x = true,
    .normalPointer = true,
    .orthox = true,
    .pixelStorei = true,
    .pointParameterx = true,
    .pointParameterxv = true,
    .pointSizex = true,
    .polygonOffsetx = true,
    .popMatrix = true,
    .pushMatrix = true,
    .readPixels = true,
    .rotatex = true,
    .sampleCoverage = true,
    .sampleCoveragex = true,
    .scalex = true,
    .scissor = true,
    .shadeModel = true,
    .stencilFunc = true,
    .stencilMask = true,
    .stencilOp = true,
    .texCoordPointer = true,
    .texEnvi = true,
    .texEnvx = true,
    .texEnviv = true,
    .texEnvxv = true,
    .texImage2D = true,
    .texParameteri = true,
    .texParameterx = true,
    .texParameteriv = true,
    .texParameterxv = true,
    .texSubImage2D = true,
    .translatex = true,
    .vertexPointer = true,
    .viewport = true,
};

pub const gles20 = CommandFlags{
    .alphaFunc = true,
    .clearColor = true,
    .clearDepthf = true,
    .clipPlanef = true,
    .color4f = true,
    .depthRangef = true,
    .fogf = true,
    .fogfv = true,
    .frustumf = true,
    .getClipPlanef = true,
    .getFloatv = true,
    .getLightfv = true,
    .getMaterialfv = true,
    .getTexEnvfv = true,
    .getTexParameterfv = true,
    .lightModelf = true,
    .lightModelfv = true,
    .lightf = true,
    .lightfv = true,
    .lineWidth = true,
    .loadMatrixf = true,
    .materialf = true,
    .materialfv = true,
    .multMatrixf = true,
    .multiTexCoord4f = true,
    .normal3f = true,
    .orthof = true,
    .pointParameterf = true,
    .pointParameterfv = true,
    .pointSize = true,
    .polygonOffset = true,
    .rotatef = true,
    .scalef = true,
    .texEnvf = true,
    .texEnvfv = true,
    .texParameterf = true,
    .texParameterfv = true,
    .translatef = true,
    .activeTexture = true,
    .alphaFuncx = true,
    .bindBuffer = true,
    .bindTexture = true,
    .blendFunc = true,
    .bufferData = true,
    .bufferSubData = true,
    .clear = true,
    .clearColorx = true,
    .clearDepthx = true,
    .clearStencil = true,
    .clientActiveTexture = true,
    .clipPlanex = true,
    .color4ub = true,
    .color4x = true,
    .colorMask = true,
    .colorPointer = true,
    .compressedTexImage2D = true,
    .compressedTexSubImage2D = true,
    .copyTexImage2D = true,
    .copyTexSubImage2D = true,
    .cullFace = true,
    .deleteBuffers = true,
    .deleteTextures = true,
    .depthFunc = true,
    .depthMask = true,
    .depthRangex = true,
    .disable = true,
    .disableClientState = true,
    .drawArrays = true,
    .drawElements = true,
    .enable = true,
    .enableClientState = true,
    .finish = true,
    .flush = true,
    .fogx = true,
    .fogxv = true,
    .frontFace = true,
    .frustumx = true,
    .getBooleanv = true,
    .getBufferParameteriv = true,
    .getClipPlanex = true,
    .genBuffers = true,
    .genTextures = true,
    .getError = true,
    .getFixedv = true,
    .getIntegerv = true,
    .getLightxv = true,
    .getMaterialxv = true,
    .getPointerv = true,
    .getString = true,
    .getTexEnviv = true,
    .getTexEnvxv = true,
    .getTexParameteriv = true,
    .getTexParameterxv = true,
    .hint = true,
    .isBuffer = true,
    .isEnabled = true,
    .isTexture = true,
    .lightModelx = true,
    .lightModelxv = true,
    .lightx = true,
    .lightxv = true,
    .lineWidthx = true,
    .loadIdentity = true,
    .loadMatrixx = true,
    .logicOp = true,
    .materialx = true,
    .materialxv = true,
    .matrixMode = true,
    .multMatrixx = true,
    .multiTexCoord4x = true,
    .normal3x = true,
    .normalPointer = true,
    .orthox = true,
    .pixelStorei = true,
    .pointParameterx = true,
    .pointParameterxv = true,
    .pointSizex = true,
    .polygonOffsetx = true,
    .popMatrix = true,
    .pushMatrix = true,
    .readPixels = true,
    .rotatex = true,
    .sampleCoverage = true,
    .sampleCoveragex = true,
    .scalex = true,
    .scissor = true,
    .shadeModel = true,
    .stencilFunc = true,
    .stencilMask = true,
    .stencilOp = true,
    .texCoordPointer = true,
    .texEnvi = true,
    .texEnvx = true,
    .texEnviv = true,
    .texEnvxv = true,
    .texImage2D = true,
    .texParameteri = true,
    .texParameterx = true,
    .texParameteriv = true,
    .texParameterxv = true,
    .texSubImage2D = true,
    .translatex = true,
    .vertexPointer = true,
    .viewport = true,
    .attachShader = true,
    .bindAttribLocation = true,
    .bindFramebuffer = true,
    .bindRenderbuffer = true,
    .blendColor = true,
    .blendEquation = true,
    .blendEquationSeparate = true,
    .blendFuncSeparate = true,
    .checkFramebufferStatus = true,
    .compileShader = true,
    .createProgram = true,
    .createShader = true,
    .deleteFramebuffers = true,
    .deleteProgram = true,
    .deleteRenderbuffers = true,
    .deleteShader = true,
    .detachShader = true,
    .disableVertexAttribArray = true,
    .enableVertexAttribArray = true,
    .framebufferRenderbuffer = true,
    .framebufferTexture2D = true,
    .generateMipmap = true,
    .genFramebuffers = true,
    .genRenderbuffers = true,
    .getActiveAttrib = true,
    .getActiveUniform = true,
    .getAttachedShaders = true,
    .getAttribLocation = true,
    .getFramebufferAttachmentParameteriv = true,
    .getProgramiv = true,
    .getProgramInfoLog = true,
    .getRenderbufferParameteriv = true,
    .getShaderiv = true,
    .getShaderInfoLog = true,
    .getShaderPrecisionFormat = true,
    .getShaderSource = true,
    .getUniformfv = true,
    .getUniformiv = true,
    .getUniformLocation = true,
    .getVertexAttribfv = true,
    .getVertexAttribiv = true,
    .getVertexAttribPointerv = true,
    .isFramebuffer = true,
    .isProgram = true,
    .isRenderbuffer = true,
    .isShader = true,
    .linkProgram = true,
    .releaseShaderCompiler = true,
    .renderbufferStorage = true,
    .shaderBinary = true,
    .shaderSource = true,
    .stencilFuncSeparate = true,
    .stencilMaskSeparate = true,
    .stencilOpSeparate = true,
    .uniform1f = true,
    .uniform1fv = true,
    .uniform1i = true,
    .uniform1iv = true,
    .uniform2f = true,
    .uniform2fv = true,
    .uniform2i = true,
    .uniform2iv = true,
    .uniform3f = true,
    .uniform3fv = true,
    .uniform3i = true,
    .uniform3iv = true,
    .uniform4f = true,
    .uniform4fv = true,
    .uniform4i = true,
    .uniform4iv = true,
    .uniformMatrix2fv = true,
    .uniformMatrix3fv = true,
    .uniformMatrix4fv = true,
    .useProgram = true,
    .validateProgram = true,
    .vertexAttrib1f = true,
    .vertexAttrib1fv = true,
    .vertexAttrib2f = true,
    .vertexAttrib2fv = true,
    .vertexAttrib3f = true,
    .vertexAttrib3fv = true,
    .vertexAttrib4f = true,
    .vertexAttrib4fv = true,
    .vertexAttribPointer = true,
};

pub const gles30 = CommandFlags{
    .alphaFunc = true,
    .clearColor = true,
    .clearDepthf = true,
    .clipPlanef = true,
    .color4f = true,
    .depthRangef = true,
    .fogf = true,
    .fogfv = true,
    .frustumf = true,
    .getClipPlanef = true,
    .getFloatv = true,
    .getLightfv = true,
    .getMaterialfv = true,
    .getTexEnvfv = true,
    .getTexParameterfv = true,
    .lightModelf = true,
    .lightModelfv = true,
    .lightf = true,
    .lightfv = true,
    .lineWidth = true,
    .loadMatrixf = true,
    .materialf = true,
    .materialfv = true,
    .multMatrixf = true,
    .multiTexCoord4f = true,
    .normal3f = true,
    .orthof = true,
    .pointParameterf = true,
    .pointParameterfv = true,
    .pointSize = true,
    .polygonOffset = true,
    .rotatef = true,
    .scalef = true,
    .texEnvf = true,
    .texEnvfv = true,
    .texParameterf = true,
    .texParameterfv = true,
    .translatef = true,
    .activeTexture = true,
    .alphaFuncx = true,
    .bindBuffer = true,
    .bindTexture = true,
    .blendFunc = true,
    .bufferData = true,
    .bufferSubData = true,
    .clear = true,
    .clearColorx = true,
    .clearDepthx = true,
    .clearStencil = true,
    .clientActiveTexture = true,
    .clipPlanex = true,
    .color4ub = true,
    .color4x = true,
    .colorMask = true,
    .colorPointer = true,
    .compressedTexImage2D = true,
    .compressedTexSubImage2D = true,
    .copyTexImage2D = true,
    .copyTexSubImage2D = true,
    .cullFace = true,
    .deleteBuffers = true,
    .deleteTextures = true,
    .depthFunc = true,
    .depthMask = true,
    .depthRangex = true,
    .disable = true,
    .disableClientState = true,
    .drawArrays = true,
    .drawElements = true,
    .enable = true,
    .enableClientState = true,
    .finish = true,
    .flush = true,
    .fogx = true,
    .fogxv = true,
    .frontFace = true,
    .frustumx = true,
    .getBooleanv = true,
    .getBufferParameteriv = true,
    .getClipPlanex = true,
    .genBuffers = true,
    .genTextures = true,
    .getError = true,
    .getFixedv = true,
    .getIntegerv = true,
    .getLightxv = true,
    .getMaterialxv = true,
    .getPointerv = true,
    .getString = true,
    .getTexEnviv = true,
    .getTexEnvxv = true,
    .getTexParameteriv = true,
    .getTexParameterxv = true,
    .hint = true,
    .isBuffer = true,
    .isEnabled = true,
    .isTexture = true,
    .lightModelx = true,
    .lightModelxv = true,
    .lightx = true,
    .lightxv = true,
    .lineWidthx = true,
    .loadIdentity = true,
    .loadMatrixx = true,
    .logicOp = true,
    .materialx = true,
    .materialxv = true,
    .matrixMode = true,
    .multMatrixx = true,
    .multiTexCoord4x = true,
    .normal3x = true,
    .normalPointer = true,
    .orthox = true,
    .pixelStorei = true,
    .pointParameterx = true,
    .pointParameterxv = true,
    .pointSizex = true,
    .polygonOffsetx = true,
    .popMatrix = true,
    .pushMatrix = true,
    .readPixels = true,
    .rotatex = true,
    .sampleCoverage = true,
    .sampleCoveragex = true,
    .scalex = true,
    .scissor = true,
    .shadeModel = true,
    .stencilFunc = true,
    .stencilMask = true,
    .stencilOp = true,
    .texCoordPointer = true,
    .texEnvi = true,
    .texEnvx = true,
    .texEnviv = true,
    .texEnvxv = true,
    .texImage2D = true,
    .texParameteri = true,
    .texParameterx = true,
    .texParameteriv = true,
    .texParameterxv = true,
    .texSubImage2D = true,
    .translatex = true,
    .vertexPointer = true,
    .viewport = true,
    .attachShader = true,
    .bindAttribLocation = true,
    .bindFramebuffer = true,
    .bindRenderbuffer = true,
    .blendColor = true,
    .blendEquation = true,
    .blendEquationSeparate = true,
    .blendFuncSeparate = true,
    .checkFramebufferStatus = true,
    .compileShader = true,
    .createProgram = true,
    .createShader = true,
    .deleteFramebuffers = true,
    .deleteProgram = true,
    .deleteRenderbuffers = true,
    .deleteShader = true,
    .detachShader = true,
    .disableVertexAttribArray = true,
    .enableVertexAttribArray = true,
    .framebufferRenderbuffer = true,
    .framebufferTexture2D = true,
    .generateMipmap = true,
    .genFramebuffers = true,
    .genRenderbuffers = true,
    .getActiveAttrib = true,
    .getActiveUniform = true,
    .getAttachedShaders = true,
    .getAttribLocation = true,
    .getFramebufferAttachmentParameteriv = true,
    .getProgramiv = true,
    .getProgramInfoLog = true,
    .getRenderbufferParameteriv = true,
    .getShaderiv = true,
    .getShaderInfoLog = true,
    .getShaderPrecisionFormat = true,
    .getShaderSource = true,
    .getUniformfv = true,
    .getUniformiv = true,
    .getUniformLocation = true,
    .getVertexAttribfv = true,
    .getVertexAttribiv = true,
    .getVertexAttribPointerv = true,
    .isFramebuffer = true,
    .isProgram = true,
    .isRenderbuffer = true,
    .isShader = true,
    .linkProgram = true,
    .releaseShaderCompiler = true,
    .renderbufferStorage = true,
    .shaderBinary = true,
    .shaderSource = true,
    .stencilFuncSeparate = true,
    .stencilMaskSeparate = true,
    .stencilOpSeparate = true,
    .uniform1f = true,
    .uniform1fv = true,
    .uniform1i = true,
    .uniform1iv = true,
    .uniform2f = true,
    .uniform2fv = true,
    .uniform2i = true,
    .uniform2iv = true,
    .uniform3f = true,
    .uniform3fv = true,
    .uniform3i = true,
    .uniform3iv = true,
    .uniform4f = true,
    .uniform4fv = true,
    .uniform4i = true,
    .uniform4iv = true,
    .uniformMatrix2fv = true,
    .uniformMatrix3fv = true,
    .uniformMatrix4fv = true,
    .useProgram = true,
    .validateProgram = true,
    .vertexAttrib1f = true,
    .vertexAttrib1fv = true,
    .vertexAttrib2f = true,
    .vertexAttrib2fv = true,
    .vertexAttrib3f = true,
    .vertexAttrib3fv = true,
    .vertexAttrib4f = true,
    .vertexAttrib4fv = true,
    .vertexAttribPointer = true,
    .readBuffer = true,
    .drawRangeElements = true,
    .texImage3D = true,
    .texSubImage3D = true,
    .copyTexSubImage3D = true,
    .compressedTexImage3D = true,
    .compressedTexSubImage3D = true,
    .genQueries = true,
    .deleteQueries = true,
    .isQuery = true,
    .beginQuery = true,
    .endQuery = true,
    .getQueryiv = true,
    .getQueryObjectuiv = true,
    .unmapBuffer = true,
    .getBufferPointerv = true,
    .drawBuffers = true,
    .uniformMatrix2x3fv = true,
    .uniformMatrix3x2fv = true,
    .uniformMatrix2x4fv = true,
    .uniformMatrix4x2fv = true,
    .uniformMatrix3x4fv = true,
    .uniformMatrix4x3fv = true,
    .blitFramebuffer = true,
    .renderbufferStorageMultisample = true,
    .framebufferTextureLayer = true,
    .mapBufferRange = true,
    .flushMappedBufferRange = true,
    .bindVertexArray = true,
    .deleteVertexArrays = true,
    .genVertexArrays = true,
    .isVertexArray = true,
    .getIntegeri_v = true,
    .beginTransformFeedback = true,
    .endTransformFeedback = true,
    .bindBufferRange = true,
    .bindBufferBase = true,
    .transformFeedbackVaryings = true,
    .getTransformFeedbackVarying = true,
    .vertexAttribIPointer = true,
    .getVertexAttribIiv = true,
    .getVertexAttribIuiv = true,
    .vertexAttribI4i = true,
    .vertexAttribI4ui = true,
    .vertexAttribI4iv = true,
    .vertexAttribI4uiv = true,
    .getUniformuiv = true,
    .getFragDataLocation = true,
    .uniform1ui = true,
    .uniform2ui = true,
    .uniform3ui = true,
    .uniform4ui = true,
    .uniform1uiv = true,
    .uniform2uiv = true,
    .uniform3uiv = true,
    .uniform4uiv = true,
    .clearBufferiv = true,
    .clearBufferuiv = true,
    .clearBufferfv = true,
    .clearBufferfi = true,
    .getStringi = true,
    .copyBufferSubData = true,
    .getUniformIndices = true,
    .getActiveUniformsiv = true,
    .getUniformBlockIndex = true,
    .getActiveUniformBlockiv = true,
    .getActiveUniformBlockName = true,
    .uniformBlockBinding = true,
    .drawArraysInstanced = true,
    .drawElementsInstanced = true,
    .fenceSync = true,
    .isSync = true,
    .deleteSync = true,
    .clientWaitSync = true,
    .waitSync = true,
    .getInteger64v = true,
    .getSynciv = true,
    .getInteger64i_v = true,
    .getBufferParameteri64v = true,
    .genSamplers = true,
    .deleteSamplers = true,
    .isSampler = true,
    .bindSampler = true,
    .samplerParameteri = true,
    .samplerParameteriv = true,
    .samplerParameterf = true,
    .samplerParameterfv = true,
    .getSamplerParameteriv = true,
    .getSamplerParameterfv = true,
    .vertexAttribDivisor = true,
    .bindTransformFeedback = true,
    .deleteTransformFeedbacks = true,
    .genTransformFeedbacks = true,
    .isTransformFeedback = true,
    .pauseTransformFeedback = true,
    .resumeTransformFeedback = true,
    .getProgramBinary = true,
    .programBinary = true,
    .programParameteri = true,
    .invalidateFramebuffer = true,
    .invalidateSubFramebuffer = true,
    .texStorage2D = true,
    .texStorage3D = true,
    .getInternalformativ = true,
};

pub const gles31 = CommandFlags{
    .alphaFunc = true,
    .clearColor = true,
    .clearDepthf = true,
    .clipPlanef = true,
    .color4f = true,
    .depthRangef = true,
    .fogf = true,
    .fogfv = true,
    .frustumf = true,
    .getClipPlanef = true,
    .getFloatv = true,
    .getLightfv = true,
    .getMaterialfv = true,
    .getTexEnvfv = true,
    .getTexParameterfv = true,
    .lightModelf = true,
    .lightModelfv = true,
    .lightf = true,
    .lightfv = true,
    .lineWidth = true,
    .loadMatrixf = true,
    .materialf = true,
    .materialfv = true,
    .multMatrixf = true,
    .multiTexCoord4f = true,
    .normal3f = true,
    .orthof = true,
    .pointParameterf = true,
    .pointParameterfv = true,
    .pointSize = true,
    .polygonOffset = true,
    .rotatef = true,
    .scalef = true,
    .texEnvf = true,
    .texEnvfv = true,
    .texParameterf = true,
    .texParameterfv = true,
    .translatef = true,
    .activeTexture = true,
    .alphaFuncx = true,
    .bindBuffer = true,
    .bindTexture = true,
    .blendFunc = true,
    .bufferData = true,
    .bufferSubData = true,
    .clear = true,
    .clearColorx = true,
    .clearDepthx = true,
    .clearStencil = true,
    .clientActiveTexture = true,
    .clipPlanex = true,
    .color4ub = true,
    .color4x = true,
    .colorMask = true,
    .colorPointer = true,
    .compressedTexImage2D = true,
    .compressedTexSubImage2D = true,
    .copyTexImage2D = true,
    .copyTexSubImage2D = true,
    .cullFace = true,
    .deleteBuffers = true,
    .deleteTextures = true,
    .depthFunc = true,
    .depthMask = true,
    .depthRangex = true,
    .disable = true,
    .disableClientState = true,
    .drawArrays = true,
    .drawElements = true,
    .enable = true,
    .enableClientState = true,
    .finish = true,
    .flush = true,
    .fogx = true,
    .fogxv = true,
    .frontFace = true,
    .frustumx = true,
    .getBooleanv = true,
    .getBufferParameteriv = true,
    .getClipPlanex = true,
    .genBuffers = true,
    .genTextures = true,
    .getError = true,
    .getFixedv = true,
    .getIntegerv = true,
    .getLightxv = true,
    .getMaterialxv = true,
    .getPointerv = true,
    .getString = true,
    .getTexEnviv = true,
    .getTexEnvxv = true,
    .getTexParameteriv = true,
    .getTexParameterxv = true,
    .hint = true,
    .isBuffer = true,
    .isEnabled = true,
    .isTexture = true,
    .lightModelx = true,
    .lightModelxv = true,
    .lightx = true,
    .lightxv = true,
    .lineWidthx = true,
    .loadIdentity = true,
    .loadMatrixx = true,
    .logicOp = true,
    .materialx = true,
    .materialxv = true,
    .matrixMode = true,
    .multMatrixx = true,
    .multiTexCoord4x = true,
    .normal3x = true,
    .normalPointer = true,
    .orthox = true,
    .pixelStorei = true,
    .pointParameterx = true,
    .pointParameterxv = true,
    .pointSizex = true,
    .polygonOffsetx = true,
    .popMatrix = true,
    .pushMatrix = true,
    .readPixels = true,
    .rotatex = true,
    .sampleCoverage = true,
    .sampleCoveragex = true,
    .scalex = true,
    .scissor = true,
    .shadeModel = true,
    .stencilFunc = true,
    .stencilMask = true,
    .stencilOp = true,
    .texCoordPointer = true,
    .texEnvi = true,
    .texEnvx = true,
    .texEnviv = true,
    .texEnvxv = true,
    .texImage2D = true,
    .texParameteri = true,
    .texParameterx = true,
    .texParameteriv = true,
    .texParameterxv = true,
    .texSubImage2D = true,
    .translatex = true,
    .vertexPointer = true,
    .viewport = true,
    .attachShader = true,
    .bindAttribLocation = true,
    .bindFramebuffer = true,
    .bindRenderbuffer = true,
    .blendColor = true,
    .blendEquation = true,
    .blendEquationSeparate = true,
    .blendFuncSeparate = true,
    .checkFramebufferStatus = true,
    .compileShader = true,
    .createProgram = true,
    .createShader = true,
    .deleteFramebuffers = true,
    .deleteProgram = true,
    .deleteRenderbuffers = true,
    .deleteShader = true,
    .detachShader = true,
    .disableVertexAttribArray = true,
    .enableVertexAttribArray = true,
    .framebufferRenderbuffer = true,
    .framebufferTexture2D = true,
    .generateMipmap = true,
    .genFramebuffers = true,
    .genRenderbuffers = true,
    .getActiveAttrib = true,
    .getActiveUniform = true,
    .getAttachedShaders = true,
    .getAttribLocation = true,
    .getFramebufferAttachmentParameteriv = true,
    .getProgramiv = true,
    .getProgramInfoLog = true,
    .getRenderbufferParameteriv = true,
    .getShaderiv = true,
    .getShaderInfoLog = true,
    .getShaderPrecisionFormat = true,
    .getShaderSource = true,
    .getUniformfv = true,
    .getUniformiv = true,
    .getUniformLocation = true,
    .getVertexAttribfv = true,
    .getVertexAttribiv = true,
    .getVertexAttribPointerv = true,
    .isFramebuffer = true,
    .isProgram = true,
    .isRenderbuffer = true,
    .isShader = true,
    .linkProgram = true,
    .releaseShaderCompiler = true,
    .renderbufferStorage = true,
    .shaderBinary = true,
    .shaderSource = true,
    .stencilFuncSeparate = true,
    .stencilMaskSeparate = true,
    .stencilOpSeparate = true,
    .uniform1f = true,
    .uniform1fv = true,
    .uniform1i = true,
    .uniform1iv = true,
    .uniform2f = true,
    .uniform2fv = true,
    .uniform2i = true,
    .uniform2iv = true,
    .uniform3f = true,
    .uniform3fv = true,
    .uniform3i = true,
    .uniform3iv = true,
    .uniform4f = true,
    .uniform4fv = true,
    .uniform4i = true,
    .uniform4iv = true,
    .uniformMatrix2fv = true,
    .uniformMatrix3fv = true,
    .uniformMatrix4fv = true,
    .useProgram = true,
    .validateProgram = true,
    .vertexAttrib1f = true,
    .vertexAttrib1fv = true,
    .vertexAttrib2f = true,
    .vertexAttrib2fv = true,
    .vertexAttrib3f = true,
    .vertexAttrib3fv = true,
    .vertexAttrib4f = true,
    .vertexAttrib4fv = true,
    .vertexAttribPointer = true,
    .readBuffer = true,
    .drawRangeElements = true,
    .texImage3D = true,
    .texSubImage3D = true,
    .copyTexSubImage3D = true,
    .compressedTexImage3D = true,
    .compressedTexSubImage3D = true,
    .genQueries = true,
    .deleteQueries = true,
    .isQuery = true,
    .beginQuery = true,
    .endQuery = true,
    .getQueryiv = true,
    .getQueryObjectuiv = true,
    .unmapBuffer = true,
    .getBufferPointerv = true,
    .drawBuffers = true,
    .uniformMatrix2x3fv = true,
    .uniformMatrix3x2fv = true,
    .uniformMatrix2x4fv = true,
    .uniformMatrix4x2fv = true,
    .uniformMatrix3x4fv = true,
    .uniformMatrix4x3fv = true,
    .blitFramebuffer = true,
    .renderbufferStorageMultisample = true,
    .framebufferTextureLayer = true,
    .mapBufferRange = true,
    .flushMappedBufferRange = true,
    .bindVertexArray = true,
    .deleteVertexArrays = true,
    .genVertexArrays = true,
    .isVertexArray = true,
    .getIntegeri_v = true,
    .beginTransformFeedback = true,
    .endTransformFeedback = true,
    .bindBufferRange = true,
    .bindBufferBase = true,
    .transformFeedbackVaryings = true,
    .getTransformFeedbackVarying = true,
    .vertexAttribIPointer = true,
    .getVertexAttribIiv = true,
    .getVertexAttribIuiv = true,
    .vertexAttribI4i = true,
    .vertexAttribI4ui = true,
    .vertexAttribI4iv = true,
    .vertexAttribI4uiv = true,
    .getUniformuiv = true,
    .getFragDataLocation = true,
    .uniform1ui = true,
    .uniform2ui = true,
    .uniform3ui = true,
    .uniform4ui = true,
    .uniform1uiv = true,
    .uniform2uiv = true,
    .uniform3uiv = true,
    .uniform4uiv = true,
    .clearBufferiv = true,
    .clearBufferuiv = true,
    .clearBufferfv = true,
    .clearBufferfi = true,
    .getStringi = true,
    .copyBufferSubData = true,
    .getUniformIndices = true,
    .getActiveUniformsiv = true,
    .getUniformBlockIndex = true,
    .getActiveUniformBlockiv = true,
    .getActiveUniformBlockName = true,
    .uniformBlockBinding = true,
    .drawArraysInstanced = true,
    .drawElementsInstanced = true,
    .fenceSync = true,
    .isSync = true,
    .deleteSync = true,
    .clientWaitSync = true,
    .waitSync = true,
    .getInteger64v = true,
    .getSynciv = true,
    .getInteger64i_v = true,
    .getBufferParameteri64v = true,
    .genSamplers = true,
    .deleteSamplers = true,
    .isSampler = true,
    .bindSampler = true,
    .samplerParameteri = true,
    .samplerParameteriv = true,
    .samplerParameterf = true,
    .samplerParameterfv = true,
    .getSamplerParameteriv = true,
    .getSamplerParameterfv = true,
    .vertexAttribDivisor = true,
    .bindTransformFeedback = true,
    .deleteTransformFeedbacks = true,
    .genTransformFeedbacks = true,
    .isTransformFeedback = true,
    .pauseTransformFeedback = true,
    .resumeTransformFeedback = true,
    .getProgramBinary = true,
    .programBinary = true,
    .programParameteri = true,
    .invalidateFramebuffer = true,
    .invalidateSubFramebuffer = true,
    .texStorage2D = true,
    .texStorage3D = true,
    .getInternalformativ = true,
    .dispatchCompute = true,
    .dispatchComputeIndirect = true,
    .drawArraysIndirect = true,
    .drawElementsIndirect = true,
    .framebufferParameteri = true,
    .getFramebufferParameteriv = true,
    .getProgramInterfaceiv = true,
    .getProgramResourceIndex = true,
    .getProgramResourceName = true,
    .getProgramResourceiv = true,
    .getProgramResourceLocation = true,
    .useProgramStages = true,
    .activeShaderProgram = true,
    .createShaderProgramv = true,
    .bindProgramPipeline = true,
    .deleteProgramPipelines = true,
    .genProgramPipelines = true,
    .isProgramPipeline = true,
    .getProgramPipelineiv = true,
    .programUniform1i = true,
    .programUniform2i = true,
    .programUniform3i = true,
    .programUniform4i = true,
    .programUniform1ui = true,
    .programUniform2ui = true,
    .programUniform3ui = true,
    .programUniform4ui = true,
    .programUniform1f = true,
    .programUniform2f = true,
    .programUniform3f = true,
    .programUniform4f = true,
    .programUniform1iv = true,
    .programUniform2iv = true,
    .programUniform3iv = true,
    .programUniform4iv = true,
    .programUniform1uiv = true,
    .programUniform2uiv = true,
    .programUniform3uiv = true,
    .programUniform4uiv = true,
    .programUniform1fv = true,
    .programUniform2fv = true,
    .programUniform3fv = true,
    .programUniform4fv = true,
    .programUniformMatrix2fv = true,
    .programUniformMatrix3fv = true,
    .programUniformMatrix4fv = true,
    .programUniformMatrix2x3fv = true,
    .programUniformMatrix3x2fv = true,
    .programUniformMatrix2x4fv = true,
    .programUniformMatrix4x2fv = true,
    .programUniformMatrix3x4fv = true,
    .programUniformMatrix4x3fv = true,
    .validateProgramPipeline = true,
    .getProgramPipelineInfoLog = true,
    .bindImageTexture = true,
    .getBooleani_v = true,
    .memoryBarrier = true,
    .memoryBarrierByRegion = true,
    .texStorage2DMultisample = true,
    .getMultisamplefv = true,
    .sampleMaski = true,
    .getTexLevelParameteriv = true,
    .getTexLevelParameterfv = true,
    .bindVertexBuffer = true,
    .vertexAttribFormat = true,
    .vertexAttribIFormat = true,
    .vertexAttribBinding = true,
    .vertexBindingDivisor = true,
};

pub const gles32 = CommandFlags{
    .alphaFunc = true,
    .clearColor = true,
    .clearDepthf = true,
    .clipPlanef = true,
    .color4f = true,
    .depthRangef = true,
    .fogf = true,
    .fogfv = true,
    .frustumf = true,
    .getClipPlanef = true,
    .getFloatv = true,
    .getLightfv = true,
    .getMaterialfv = true,
    .getTexEnvfv = true,
    .getTexParameterfv = true,
    .lightModelf = true,
    .lightModelfv = true,
    .lightf = true,
    .lightfv = true,
    .lineWidth = true,
    .loadMatrixf = true,
    .materialf = true,
    .materialfv = true,
    .multMatrixf = true,
    .multiTexCoord4f = true,
    .normal3f = true,
    .orthof = true,
    .pointParameterf = true,
    .pointParameterfv = true,
    .pointSize = true,
    .polygonOffset = true,
    .rotatef = true,
    .scalef = true,
    .texEnvf = true,
    .texEnvfv = true,
    .texParameterf = true,
    .texParameterfv = true,
    .translatef = true,
    .activeTexture = true,
    .alphaFuncx = true,
    .bindBuffer = true,
    .bindTexture = true,
    .blendFunc = true,
    .bufferData = true,
    .bufferSubData = true,
    .clear = true,
    .clearColorx = true,
    .clearDepthx = true,
    .clearStencil = true,
    .clientActiveTexture = true,
    .clipPlanex = true,
    .color4ub = true,
    .color4x = true,
    .colorMask = true,
    .colorPointer = true,
    .compressedTexImage2D = true,
    .compressedTexSubImage2D = true,
    .copyTexImage2D = true,
    .copyTexSubImage2D = true,
    .cullFace = true,
    .deleteBuffers = true,
    .deleteTextures = true,
    .depthFunc = true,
    .depthMask = true,
    .depthRangex = true,
    .disable = true,
    .disableClientState = true,
    .drawArrays = true,
    .drawElements = true,
    .enable = true,
    .enableClientState = true,
    .finish = true,
    .flush = true,
    .fogx = true,
    .fogxv = true,
    .frontFace = true,
    .frustumx = true,
    .getBooleanv = true,
    .getBufferParameteriv = true,
    .getClipPlanex = true,
    .genBuffers = true,
    .genTextures = true,
    .getError = true,
    .getFixedv = true,
    .getIntegerv = true,
    .getLightxv = true,
    .getMaterialxv = true,
    .getPointerv = true,
    .getString = true,
    .getTexEnviv = true,
    .getTexEnvxv = true,
    .getTexParameteriv = true,
    .getTexParameterxv = true,
    .hint = true,
    .isBuffer = true,
    .isEnabled = true,
    .isTexture = true,
    .lightModelx = true,
    .lightModelxv = true,
    .lightx = true,
    .lightxv = true,
    .lineWidthx = true,
    .loadIdentity = true,
    .loadMatrixx = true,
    .logicOp = true,
    .materialx = true,
    .materialxv = true,
    .matrixMode = true,
    .multMatrixx = true,
    .multiTexCoord4x = true,
    .normal3x = true,
    .normalPointer = true,
    .orthox = true,
    .pixelStorei = true,
    .pointParameterx = true,
    .pointParameterxv = true,
    .pointSizex = true,
    .polygonOffsetx = true,
    .popMatrix = true,
    .pushMatrix = true,
    .readPixels = true,
    .rotatex = true,
    .sampleCoverage = true,
    .sampleCoveragex = true,
    .scalex = true,
    .scissor = true,
    .shadeModel = true,
    .stencilFunc = true,
    .stencilMask = true,
    .stencilOp = true,
    .texCoordPointer = true,
    .texEnvi = true,
    .texEnvx = true,
    .texEnviv = true,
    .texEnvxv = true,
    .texImage2D = true,
    .texParameteri = true,
    .texParameterx = true,
    .texParameteriv = true,
    .texParameterxv = true,
    .texSubImage2D = true,
    .translatex = true,
    .vertexPointer = true,
    .viewport = true,
    .attachShader = true,
    .bindAttribLocation = true,
    .bindFramebuffer = true,
    .bindRenderbuffer = true,
    .blendColor = true,
    .blendEquation = true,
    .blendEquationSeparate = true,
    .blendFuncSeparate = true,
    .checkFramebufferStatus = true,
    .compileShader = true,
    .createProgram = true,
    .createShader = true,
    .deleteFramebuffers = true,
    .deleteProgram = true,
    .deleteRenderbuffers = true,
    .deleteShader = true,
    .detachShader = true,
    .disableVertexAttribArray = true,
    .enableVertexAttribArray = true,
    .framebufferRenderbuffer = true,
    .framebufferTexture2D = true,
    .generateMipmap = true,
    .genFramebuffers = true,
    .genRenderbuffers = true,
    .getActiveAttrib = true,
    .getActiveUniform = true,
    .getAttachedShaders = true,
    .getAttribLocation = true,
    .getFramebufferAttachmentParameteriv = true,
    .getProgramiv = true,
    .getProgramInfoLog = true,
    .getRenderbufferParameteriv = true,
    .getShaderiv = true,
    .getShaderInfoLog = true,
    .getShaderPrecisionFormat = true,
    .getShaderSource = true,
    .getUniformfv = true,
    .getUniformiv = true,
    .getUniformLocation = true,
    .getVertexAttribfv = true,
    .getVertexAttribiv = true,
    .getVertexAttribPointerv = true,
    .isFramebuffer = true,
    .isProgram = true,
    .isRenderbuffer = true,
    .isShader = true,
    .linkProgram = true,
    .releaseShaderCompiler = true,
    .renderbufferStorage = true,
    .shaderBinary = true,
    .shaderSource = true,
    .stencilFuncSeparate = true,
    .stencilMaskSeparate = true,
    .stencilOpSeparate = true,
    .uniform1f = true,
    .uniform1fv = true,
    .uniform1i = true,
    .uniform1iv = true,
    .uniform2f = true,
    .uniform2fv = true,
    .uniform2i = true,
    .uniform2iv = true,
    .uniform3f = true,
    .uniform3fv = true,
    .uniform3i = true,
    .uniform3iv = true,
    .uniform4f = true,
    .uniform4fv = true,
    .uniform4i = true,
    .uniform4iv = true,
    .uniformMatrix2fv = true,
    .uniformMatrix3fv = true,
    .uniformMatrix4fv = true,
    .useProgram = true,
    .validateProgram = true,
    .vertexAttrib1f = true,
    .vertexAttrib1fv = true,
    .vertexAttrib2f = true,
    .vertexAttrib2fv = true,
    .vertexAttrib3f = true,
    .vertexAttrib3fv = true,
    .vertexAttrib4f = true,
    .vertexAttrib4fv = true,
    .vertexAttribPointer = true,
    .readBuffer = true,
    .drawRangeElements = true,
    .texImage3D = true,
    .texSubImage3D = true,
    .copyTexSubImage3D = true,
    .compressedTexImage3D = true,
    .compressedTexSubImage3D = true,
    .genQueries = true,
    .deleteQueries = true,
    .isQuery = true,
    .beginQuery = true,
    .endQuery = true,
    .getQueryiv = true,
    .getQueryObjectuiv = true,
    .unmapBuffer = true,
    .getBufferPointerv = true,
    .drawBuffers = true,
    .uniformMatrix2x3fv = true,
    .uniformMatrix3x2fv = true,
    .uniformMatrix2x4fv = true,
    .uniformMatrix4x2fv = true,
    .uniformMatrix3x4fv = true,
    .uniformMatrix4x3fv = true,
    .blitFramebuffer = true,
    .renderbufferStorageMultisample = true,
    .framebufferTextureLayer = true,
    .mapBufferRange = true,
    .flushMappedBufferRange = true,
    .bindVertexArray = true,
    .deleteVertexArrays = true,
    .genVertexArrays = true,
    .isVertexArray = true,
    .getIntegeri_v = true,
    .beginTransformFeedback = true,
    .endTransformFeedback = true,
    .bindBufferRange = true,
    .bindBufferBase = true,
    .transformFeedbackVaryings = true,
    .getTransformFeedbackVarying = true,
    .vertexAttribIPointer = true,
    .getVertexAttribIiv = true,
    .getVertexAttribIuiv = true,
    .vertexAttribI4i = true,
    .vertexAttribI4ui = true,
    .vertexAttribI4iv = true,
    .vertexAttribI4uiv = true,
    .getUniformuiv = true,
    .getFragDataLocation = true,
    .uniform1ui = true,
    .uniform2ui = true,
    .uniform3ui = true,
    .uniform4ui = true,
    .uniform1uiv = true,
    .uniform2uiv = true,
    .uniform3uiv = true,
    .uniform4uiv = true,
    .clearBufferiv = true,
    .clearBufferuiv = true,
    .clearBufferfv = true,
    .clearBufferfi = true,
    .getStringi = true,
    .copyBufferSubData = true,
    .getUniformIndices = true,
    .getActiveUniformsiv = true,
    .getUniformBlockIndex = true,
    .getActiveUniformBlockiv = true,
    .getActiveUniformBlockName = true,
    .uniformBlockBinding = true,
    .drawArraysInstanced = true,
    .drawElementsInstanced = true,
    .fenceSync = true,
    .isSync = true,
    .deleteSync = true,
    .clientWaitSync = true,
    .waitSync = true,
    .getInteger64v = true,
    .getSynciv = true,
    .getInteger64i_v = true,
    .getBufferParameteri64v = true,
    .genSamplers = true,
    .deleteSamplers = true,
    .isSampler = true,
    .bindSampler = true,
    .samplerParameteri = true,
    .samplerParameteriv = true,
    .samplerParameterf = true,
    .samplerParameterfv = true,
    .getSamplerParameteriv = true,
    .getSamplerParameterfv = true,
    .vertexAttribDivisor = true,
    .bindTransformFeedback = true,
    .deleteTransformFeedbacks = true,
    .genTransformFeedbacks = true,
    .isTransformFeedback = true,
    .pauseTransformFeedback = true,
    .resumeTransformFeedback = true,
    .getProgramBinary = true,
    .programBinary = true,
    .programParameteri = true,
    .invalidateFramebuffer = true,
    .invalidateSubFramebuffer = true,
    .texStorage2D = true,
    .texStorage3D = true,
    .getInternalformativ = true,
    .dispatchCompute = true,
    .dispatchComputeIndirect = true,
    .drawArraysIndirect = true,
    .drawElementsIndirect = true,
    .framebufferParameteri = true,
    .getFramebufferParameteriv = true,
    .getProgramInterfaceiv = true,
    .getProgramResourceIndex = true,
    .getProgramResourceName = true,
    .getProgramResourceiv = true,
    .getProgramResourceLocation = true,
    .useProgramStages = true,
    .activeShaderProgram = true,
    .createShaderProgramv = true,
    .bindProgramPipeline = true,
    .deleteProgramPipelines = true,
    .genProgramPipelines = true,
    .isProgramPipeline = true,
    .getProgramPipelineiv = true,
    .programUniform1i = true,
    .programUniform2i = true,
    .programUniform3i = true,
    .programUniform4i = true,
    .programUniform1ui = true,
    .programUniform2ui = true,
    .programUniform3ui = true,
    .programUniform4ui = true,
    .programUniform1f = true,
    .programUniform2f = true,
    .programUniform3f = true,
    .programUniform4f = true,
    .programUniform1iv = true,
    .programUniform2iv = true,
    .programUniform3iv = true,
    .programUniform4iv = true,
    .programUniform1uiv = true,
    .programUniform2uiv = true,
    .programUniform3uiv = true,
    .programUniform4uiv = true,
    .programUniform1fv = true,
    .programUniform2fv = true,
    .programUniform3fv = true,
    .programUniform4fv = true,
    .programUniformMatrix2fv = true,
    .programUniformMatrix3fv = true,
    .programUniformMatrix4fv = true,
    .programUniformMatrix2x3fv = true,
    .programUniformMatrix3x2fv = true,
    .programUniformMatrix2x4fv = true,
    .programUniformMatrix4x2fv = true,
    .programUniformMatrix3x4fv = true,
    .programUniformMatrix4x3fv = true,
    .validateProgramPipeline = true,
    .getProgramPipelineInfoLog = true,
    .bindImageTexture = true,
    .getBooleani_v = true,
    .memoryBarrier = true,
    .memoryBarrierByRegion = true,
    .texStorage2DMultisample = true,
    .getMultisamplefv = true,
    .sampleMaski = true,
    .getTexLevelParameteriv = true,
    .getTexLevelParameterfv = true,
    .bindVertexBuffer = true,
    .vertexAttribFormat = true,
    .vertexAttribIFormat = true,
    .vertexAttribBinding = true,
    .vertexBindingDivisor = true,
    .blendBarrier = true,
    .copyImageSubData = true,
    .debugMessageControl = true,
    .debugMessageInsert = true,
    .debugMessageCallback = true,
    .getDebugMessageLog = true,
    .pushDebugGroup = true,
    .popDebugGroup = true,
    .objectLabel = true,
    .getObjectLabel = true,
    .objectPtrLabel = true,
    .getObjectPtrLabel = true,
    .enablei = true,
    .disablei = true,
    .blendEquationi = true,
    .blendEquationSeparatei = true,
    .blendFunci = true,
    .blendFuncSeparatei = true,
    .colorMaski = true,
    .isEnabledi = true,
    .drawElementsBaseVertex = true,
    .drawRangeElementsBaseVertex = true,
    .drawElementsInstancedBaseVertex = true,
    .framebufferTexture = true,
    .primitiveBoundingBox = true,
    .getGraphicsResetStatus = true,
    .readnPixels = true,
    .getnUniformfv = true,
    .getnUniformiv = true,
    .getnUniformuiv = true,
    .minSampleShading = true,
    .patchParameteri = true,
    .texParameterIiv = true,
    .texParameterIuiv = true,
    .getTexParameterIiv = true,
    .getTexParameterIuiv = true,
    .samplerParameterIiv = true,
    .samplerParameterIuiv = true,
    .getSamplerParameterIiv = true,
    .getSamplerParameterIuiv = true,
    .texBuffer = true,
    .texBufferRange = true,
    .texStorage3DMultisample = true,
};

pub const glsc20 = CommandFlags{
    .activeTexture = true,
    .bindBuffer = true,
    .bindFramebuffer = true,
    .bindRenderbuffer = true,
    .bindTexture = true,
    .blendColor = true,
    .blendEquation = true,
    .blendEquationSeparate = true,
    .blendFunc = true,
    .blendFuncSeparate = true,
    .bufferData = true,
    .bufferSubData = true,
    .checkFramebufferStatus = true,
    .clear = true,
    .clearColor = true,
    .clearDepthf = true,
    .clearStencil = true,
    .colorMask = true,
    .compressedTexSubImage2D = true,
    .createProgram = true,
    .cullFace = true,
    .depthFunc = true,
    .depthMask = true,
    .depthRangef = true,
    .disable = true,
    .disableVertexAttribArray = true,
    .drawArrays = true,
    .drawRangeElements = true,
    .enable = true,
    .enableVertexAttribArray = true,
    .finish = true,
    .flush = true,
    .framebufferRenderbuffer = true,
    .framebufferTexture2D = true,
    .frontFace = true,
    .genBuffers = true,
    .generateMipmap = true,
    .genFramebuffers = true,
    .genRenderbuffers = true,
    .genTextures = true,
    .getAttribLocation = true,
    .getBooleanv = true,
    .getBufferParameteriv = true,
    .getError = true,
    .getFloatv = true,
    .getFramebufferAttachmentParameteriv = true,
    .getGraphicsResetStatus = true,
    .getIntegerv = true,
    .getProgramiv = true,
    .getRenderbufferParameteriv = true,
    .getString = true,
    .getTexParameterfv = true,
    .getTexParameteriv = true,
    .getnUniformfv = true,
    .getnUniformiv = true,
    .getUniformLocation = true,
    .getVertexAttribfv = true,
    .getVertexAttribiv = true,
    .getVertexAttribPointerv = true,
    .hint = true,
    .isEnabled = true,
    .lineWidth = true,
    .pixelStorei = true,
    .polygonOffset = true,
    .programBinary = true,
    .readnPixels = true,
    .renderbufferStorage = true,
    .sampleCoverage = true,
    .scissor = true,
    .stencilFunc = true,
    .stencilFuncSeparate = true,
    .stencilMask = true,
    .stencilMaskSeparate = true,
    .stencilOp = true,
    .stencilOpSeparate = true,
    .texStorage2D = true,
    .texParameterf = true,
    .texParameterfv = true,
    .texParameteri = true,
    .texParameteriv = true,
    .texSubImage2D = true,
    .uniform1f = true,
    .uniform1fv = true,
    .uniform1i = true,
    .uniform1iv = true,
    .uniform2f = true,
    .uniform2fv = true,
    .uniform2i = true,
    .uniform2iv = true,
    .uniform3f = true,
    .uniform3fv = true,
    .uniform3i = true,
    .uniform3iv = true,
    .uniform4f = true,
    .uniform4fv = true,
    .uniform4i = true,
    .uniform4iv = true,
    .uniformMatrix2fv = true,
    .uniformMatrix3fv = true,
    .uniformMatrix4fv = true,
    .useProgram = true,
    .vertexAttrib1f = true,
    .vertexAttrib1fv = true,
    .vertexAttrib2f = true,
    .vertexAttrib2fv = true,
    .vertexAttrib3f = true,
    .vertexAttrib3fv = true,
    .vertexAttrib4f = true,
    .vertexAttrib4fv = true,
    .vertexAttribPointer = true,
    .viewport = true,
};
